Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    RETURN

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID { opVars opFunctions main }
Rule 2     opVars -> vars
Rule 3     opVars -> empty
Rule 4     opFunctions -> function opFunctions
Rule 5     opFunctions -> empty
Rule 6     vars -> VARS declare
Rule 7     type -> INT
Rule 8     type -> FLOAT
Rule 9     type -> STRING
Rule 10    type -> OBJECT
Rule 11    type -> BOOL
Rule 12    main -> MAIN { opVars body }
Rule 13    instr -> c ;
Rule 14    instr -> condition
Rule 15    instr -> cycle
Rule 16    c -> assign
Rule 17    c -> funcCall
Rule 18    declare -> d
Rule 19    declare -> e
Rule 20    declare -> f
Rule 21    init -> = i
Rule 22    i -> expresion
Rule 23    i -> funcCall
Rule 24    initDict -> = ( j : j )
Rule 25    j -> CTES
Rule 26    j -> cte
Rule 27    j -> ID
Rule 28    param -> type ID g k
Rule 29    k -> ; param
Rule 30    k -> empty
Rule 31    function -> FUNC ID opParameters opReturns { opVars body }
Rule 32    opParameters -> ( param )
Rule 33    opParameters -> empty
Rule 34    opReturns -> RETURNS type
Rule 35    opReturns -> empty
Rule 36    d -> type ID g ; h
Rule 37    e -> STRUCT ID struct ; h
Rule 38    f -> DICT ID dict ; h
Rule 39    g -> , ID
Rule 40    g -> empty
Rule 41    h -> declare
Rule 42    h -> empty
Rule 43    body -> cyInstruction
Rule 44    body -> empty
Rule 45    cyInstruction -> instr body
Rule 46    cycle -> forCycle
Rule 47    cycle -> whileCycle
Rule 48    whileCycle -> WHILE ( expresion ) { body }
Rule 49    forCycle -> FOR ( assign ; expresion ; assign ) { body }
Rule 50    assign -> ID assignOptions
Rule 51    assignOptions -> init
Rule 52    assignOptions -> initDict
Rule 53    assignOptions -> [ expresion ] assignMatrix init
Rule 54    assignMatrix -> [ expresion ]
Rule 55    assignMatrix -> empty
Rule 56    funcCall -> ID ( opParamCall )
Rule 57    opParamCall -> expresion cyParamCall
Rule 58    opParamCall -> empty
Rule 59    cyParamCall -> , expresion cyParamCall
Rule 60    cyParamCall -> empty
Rule 61    struct -> type [ CTED ] optionalMatrix
Rule 62    optionalMatrix -> [ CTED ]
Rule 63    optionalMatrix -> empty
Rule 64    condition -> IF ( expresion ) { body } optionalElse
Rule 65    optionalElse -> ELSE { body }
Rule 66    optionalElse -> empty
Rule 67    dict -> ( type : type )
Rule 68    expresion -> sExp cyExpresion
Rule 69    cyExpresion -> AND expresion
Rule 70    cyExpresion -> OR expresion
Rule 71    cyExpresion -> empty
Rule 72    sExp -> exp opSExp
Rule 73    opSExp -> EQ exp
Rule 74    opSExp -> DIF exp
Rule 75    opSExp -> LTOEQ exp
Rule 76    opSExp -> GTOEQ exp
Rule 77    opSExp -> > exp
Rule 78    opSExp -> < exp
Rule 79    opSExp -> empty
Rule 80    exp -> term cyExp
Rule 81    cyExp -> + term
Rule 82    cyExp -> - term
Rule 83    cyExp -> empty
Rule 84    term -> fact cyTerm
Rule 85    cyTerm -> * fact
Rule 86    cyTerm -> / fact
Rule 87    cyTerm -> empty
Rule 88    fact -> CTES
Rule 89    fact -> cte
Rule 90    fact -> funcCall
Rule 91    fact -> ( expresion )
Rule 92    fact -> ID opAccess
Rule 93    opAccess -> opStruct
Rule 94    opAccess -> opDictionary
Rule 95    opAccess -> empty
Rule 96    opStruct -> [ expresion ] opMatrix
Rule 97    opMatrix -> [ expresion ]
Rule 98    opMatrix -> empty
Rule 99    opDictionary -> . dictIndex
Rule 100   dictIndex -> FIRST
Rule 101   dictIndex -> LAST
Rule 102   cte -> CTED
Rule 103   cte -> CTEF
Rule 104   cte -> TRUE
Rule 105   cte -> FALSE
Rule 106   empty -> <empty>

Terminals, with rules where they appear

(                    : 24 32 48 49 56 64 67 91
)                    : 24 32 48 49 56 64 67 91
*                    : 85
+                    : 81
,                    : 39 59
-                    : 82
.                    : 99
/                    : 86
:                    : 24 67
;                    : 13 29 36 37 38 49 49
<                    : 78
=                    : 21 24
>                    : 77
AND                  : 69
BOOL                 : 11
CTED                 : 61 62 102
CTEF                 : 103
CTES                 : 25 88
DICT                 : 38
DIF                  : 74
ELSE                 : 65
EQ                   : 73
FALSE                : 105
FIRST                : 100
FLOAT                : 8
FOR                  : 49
FUNC                 : 31
GTOEQ                : 76
ID                   : 1 27 28 31 36 37 38 39 50 56 92
IF                   : 64
INT                  : 7
LAST                 : 101
LTOEQ                : 75
MAIN                 : 12
OBJECT               : 10
OR                   : 70
PROGRAM              : 1
RETURN               : 
RETURNS              : 34
STRING               : 9
STRUCT               : 37
TRUE                 : 104
VARS                 : 6
WHILE                : 48
[                    : 53 54 61 62 96 97
]                    : 53 54 61 62 96 97
error                : 
{                    : 1 12 31 48 49 64 65
}                    : 1 12 31 48 49 64 65

Nonterminals, with rules where they appear

assign               : 16 49 49
assignMatrix         : 53
assignOptions        : 50
body                 : 12 31 45 48 49 64 65
c                    : 13
condition            : 14
cte                  : 26 89
cyExp                : 80
cyExpresion          : 68
cyInstruction        : 43
cyParamCall          : 57 59
cyTerm               : 84
cycle                : 15
d                    : 18
declare              : 6 41
dict                 : 38
dictIndex            : 99
e                    : 19
empty                : 3 5 30 33 35 40 42 44 55 58 60 63 66 71 79 83 87 95 98
exp                  : 72 73 74 75 76 77 78
expresion            : 22 48 49 53 54 57 59 64 69 70 91 96 97
f                    : 20
fact                 : 84 85 86
forCycle             : 46
funcCall             : 17 23 90
function             : 4
g                    : 28 36
h                    : 36 37 38
i                    : 21
init                 : 51 53
initDict             : 52
instr                : 45
j                    : 24 24
k                    : 28
main                 : 1
opAccess             : 92
opDictionary         : 94
opFunctions          : 1 4
opMatrix             : 96
opParamCall          : 56
opParameters         : 31
opReturns            : 31
opSExp               : 72
opStruct             : 93
opVars               : 1 12 31
optionalElse         : 64
optionalMatrix       : 61
param                : 29 32
program              : 0
sExp                 : 68
struct               : 37
term                 : 80 81 82
type                 : 28 34 36 61 67 67
vars                 : 2
whileCycle           : 47

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID { opVars opFunctions main }

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID { opVars opFunctions main }

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . { opVars opFunctions main }

    {               shift and go to state 4


state 4

    (1) program -> PROGRAM ID { . opVars opFunctions main }
    (2) opVars -> . vars
    (3) opVars -> . empty
    (6) vars -> . VARS declare
    (106) empty -> .

    VARS            shift and go to state 5
    FUNC            reduce using rule 106 (empty -> .)
    MAIN            reduce using rule 106 (empty -> .)

    vars                           shift and go to state 6
    opVars                         shift and go to state 7
    empty                          shift and go to state 8

state 5

    (6) vars -> VARS . declare
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (36) d -> . type ID g ; h
    (37) e -> . STRUCT ID struct ; h
    (38) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    STRUCT          shift and go to state 20
    DICT            shift and go to state 16
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    STRING          shift and go to state 15
    OBJECT          shift and go to state 9
    BOOL            shift and go to state 17

    e                              shift and go to state 10
    d                              shift and go to state 11
    f                              shift and go to state 12
    type                           shift and go to state 18
    declare                        shift and go to state 19

state 6

    (2) opVars -> vars .

    FUNC            reduce using rule 2 (opVars -> vars .)
    MAIN            reduce using rule 2 (opVars -> vars .)
    IF              reduce using rule 2 (opVars -> vars .)
    ID              reduce using rule 2 (opVars -> vars .)
    FOR             reduce using rule 2 (opVars -> vars .)
    WHILE           reduce using rule 2 (opVars -> vars .)
    }               reduce using rule 2 (opVars -> vars .)


state 7

    (1) program -> PROGRAM ID { opVars . opFunctions main }
    (4) opFunctions -> . function opFunctions
    (5) opFunctions -> . empty
    (31) function -> . FUNC ID opParameters opReturns { opVars body }
    (106) empty -> .

    FUNC            shift and go to state 22
    MAIN            reduce using rule 106 (empty -> .)

    function                       shift and go to state 21
    empty                          shift and go to state 23
    opFunctions                    shift and go to state 24

state 8

    (3) opVars -> empty .

    FUNC            reduce using rule 3 (opVars -> empty .)
    MAIN            reduce using rule 3 (opVars -> empty .)
    IF              reduce using rule 3 (opVars -> empty .)
    ID              reduce using rule 3 (opVars -> empty .)
    FOR             reduce using rule 3 (opVars -> empty .)
    WHILE           reduce using rule 3 (opVars -> empty .)
    }               reduce using rule 3 (opVars -> empty .)


state 9

    (10) type -> OBJECT .

    ID              reduce using rule 10 (type -> OBJECT .)
    )               reduce using rule 10 (type -> OBJECT .)
    :               reduce using rule 10 (type -> OBJECT .)
    {               reduce using rule 10 (type -> OBJECT .)
    [               reduce using rule 10 (type -> OBJECT .)


state 10

    (19) declare -> e .

    FUNC            reduce using rule 19 (declare -> e .)
    MAIN            reduce using rule 19 (declare -> e .)
    IF              reduce using rule 19 (declare -> e .)
    ID              reduce using rule 19 (declare -> e .)
    FOR             reduce using rule 19 (declare -> e .)
    WHILE           reduce using rule 19 (declare -> e .)
    }               reduce using rule 19 (declare -> e .)


state 11

    (18) declare -> d .

    FUNC            reduce using rule 18 (declare -> d .)
    MAIN            reduce using rule 18 (declare -> d .)
    IF              reduce using rule 18 (declare -> d .)
    ID              reduce using rule 18 (declare -> d .)
    FOR             reduce using rule 18 (declare -> d .)
    WHILE           reduce using rule 18 (declare -> d .)
    }               reduce using rule 18 (declare -> d .)


state 12

    (20) declare -> f .

    FUNC            reduce using rule 20 (declare -> f .)
    MAIN            reduce using rule 20 (declare -> f .)
    IF              reduce using rule 20 (declare -> f .)
    ID              reduce using rule 20 (declare -> f .)
    FOR             reduce using rule 20 (declare -> f .)
    WHILE           reduce using rule 20 (declare -> f .)
    }               reduce using rule 20 (declare -> f .)


state 13

    (7) type -> INT .

    ID              reduce using rule 7 (type -> INT .)
    )               reduce using rule 7 (type -> INT .)
    :               reduce using rule 7 (type -> INT .)
    {               reduce using rule 7 (type -> INT .)
    [               reduce using rule 7 (type -> INT .)


state 14

    (8) type -> FLOAT .

    ID              reduce using rule 8 (type -> FLOAT .)
    )               reduce using rule 8 (type -> FLOAT .)
    :               reduce using rule 8 (type -> FLOAT .)
    {               reduce using rule 8 (type -> FLOAT .)
    [               reduce using rule 8 (type -> FLOAT .)


state 15

    (9) type -> STRING .

    ID              reduce using rule 9 (type -> STRING .)
    )               reduce using rule 9 (type -> STRING .)
    :               reduce using rule 9 (type -> STRING .)
    {               reduce using rule 9 (type -> STRING .)
    [               reduce using rule 9 (type -> STRING .)


state 16

    (38) f -> DICT . ID dict ; h

    ID              shift and go to state 25


state 17

    (11) type -> BOOL .

    ID              reduce using rule 11 (type -> BOOL .)
    )               reduce using rule 11 (type -> BOOL .)
    :               reduce using rule 11 (type -> BOOL .)
    {               reduce using rule 11 (type -> BOOL .)
    [               reduce using rule 11 (type -> BOOL .)


state 18

    (36) d -> type . ID g ; h

    ID              shift and go to state 26


state 19

    (6) vars -> VARS declare .

    IF              reduce using rule 6 (vars -> VARS declare .)
    ID              reduce using rule 6 (vars -> VARS declare .)
    FOR             reduce using rule 6 (vars -> VARS declare .)
    WHILE           reduce using rule 6 (vars -> VARS declare .)
    }               reduce using rule 6 (vars -> VARS declare .)
    FUNC            reduce using rule 6 (vars -> VARS declare .)
    MAIN            reduce using rule 6 (vars -> VARS declare .)


state 20

    (37) e -> STRUCT . ID struct ; h

    ID              shift and go to state 27


state 21

    (4) opFunctions -> function . opFunctions
    (4) opFunctions -> . function opFunctions
    (5) opFunctions -> . empty
    (31) function -> . FUNC ID opParameters opReturns { opVars body }
    (106) empty -> .

    FUNC            shift and go to state 22
    MAIN            reduce using rule 106 (empty -> .)

    function                       shift and go to state 21
    opFunctions                    shift and go to state 28
    empty                          shift and go to state 23

state 22

    (31) function -> FUNC . ID opParameters opReturns { opVars body }

    ID              shift and go to state 29


state 23

    (5) opFunctions -> empty .

    MAIN            reduce using rule 5 (opFunctions -> empty .)


state 24

    (1) program -> PROGRAM ID { opVars opFunctions . main }
    (12) main -> . MAIN { opVars body }

    MAIN            shift and go to state 30

    main                           shift and go to state 31

state 25

    (38) f -> DICT ID . dict ; h
    (67) dict -> . ( type : type )

    (               shift and go to state 32

    dict                           shift and go to state 33

state 26

    (36) d -> type ID . g ; h
    (39) g -> . , ID
    (40) g -> . empty
    (106) empty -> .

    ,               shift and go to state 35
    ;               reduce using rule 106 (empty -> .)

    empty                          shift and go to state 36
    g                              shift and go to state 34

state 27

    (37) e -> STRUCT ID . struct ; h
    (61) struct -> . type [ CTED ] optionalMatrix
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    STRING          shift and go to state 15
    OBJECT          shift and go to state 9
    BOOL            shift and go to state 17

    type                           shift and go to state 38
    struct                         shift and go to state 37

state 28

    (4) opFunctions -> function opFunctions .

    MAIN            reduce using rule 4 (opFunctions -> function opFunctions .)


state 29

    (31) function -> FUNC ID . opParameters opReturns { opVars body }
    (32) opParameters -> . ( param )
    (33) opParameters -> . empty
    (106) empty -> .

    (               shift and go to state 39
    RETURNS         reduce using rule 106 (empty -> .)
    {               reduce using rule 106 (empty -> .)

    opParameters                   shift and go to state 40
    empty                          shift and go to state 41

state 30

    (12) main -> MAIN . { opVars body }

    {               shift and go to state 42


state 31

    (1) program -> PROGRAM ID { opVars opFunctions main . }

    }               shift and go to state 43


state 32

    (67) dict -> ( . type : type )
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    STRING          shift and go to state 15
    OBJECT          shift and go to state 9
    BOOL            shift and go to state 17

    type                           shift and go to state 44

state 33

    (38) f -> DICT ID dict . ; h

    ;               shift and go to state 45


state 34

    (36) d -> type ID g . ; h

    ;               shift and go to state 46


state 35

    (39) g -> , . ID

    ID              shift and go to state 47


state 36

    (40) g -> empty .

    ;               reduce using rule 40 (g -> empty .)
    )               reduce using rule 40 (g -> empty .)


state 37

    (37) e -> STRUCT ID struct . ; h

    ;               shift and go to state 48


state 38

    (61) struct -> type . [ CTED ] optionalMatrix

    [               shift and go to state 49


state 39

    (32) opParameters -> ( . param )
    (28) param -> . type ID g k
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    STRING          shift and go to state 15
    OBJECT          shift and go to state 9
    BOOL            shift and go to state 17

    type                           shift and go to state 51
    param                          shift and go to state 50

state 40

    (31) function -> FUNC ID opParameters . opReturns { opVars body }
    (34) opReturns -> . RETURNS type
    (35) opReturns -> . empty
    (106) empty -> .

    RETURNS         shift and go to state 52
    {               reduce using rule 106 (empty -> .)

    empty                          shift and go to state 53
    opReturns                      shift and go to state 54

state 41

    (33) opParameters -> empty .

    RETURNS         reduce using rule 33 (opParameters -> empty .)
    {               reduce using rule 33 (opParameters -> empty .)


state 42

    (12) main -> MAIN { . opVars body }
    (2) opVars -> . vars
    (3) opVars -> . empty
    (6) vars -> . VARS declare
    (106) empty -> .

    VARS            shift and go to state 5
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)

    opVars                         shift and go to state 55
    empty                          shift and go to state 8
    vars                           shift and go to state 6

state 43

    (1) program -> PROGRAM ID { opVars opFunctions main } .

    $end            reduce using rule 1 (program -> PROGRAM ID { opVars opFunctions main } .)


state 44

    (67) dict -> ( type . : type )

    :               shift and go to state 56


state 45

    (38) f -> DICT ID dict ; . h
    (41) h -> . declare
    (42) h -> . empty
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (106) empty -> .
    (36) d -> . type ID g ; h
    (37) e -> . STRUCT ID struct ; h
    (38) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 106 (empty -> .)
    MAIN            reduce using rule 106 (empty -> .)
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)
    STRUCT          shift and go to state 20
    DICT            shift and go to state 16
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    STRING          shift and go to state 15
    OBJECT          shift and go to state 9
    BOOL            shift and go to state 17

    e                              shift and go to state 10
    d                              shift and go to state 11
    f                              shift and go to state 12
    h                              shift and go to state 57
    type                           shift and go to state 18
    declare                        shift and go to state 58
    empty                          shift and go to state 59

state 46

    (36) d -> type ID g ; . h
    (41) h -> . declare
    (42) h -> . empty
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (106) empty -> .
    (36) d -> . type ID g ; h
    (37) e -> . STRUCT ID struct ; h
    (38) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 106 (empty -> .)
    MAIN            reduce using rule 106 (empty -> .)
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)
    STRUCT          shift and go to state 20
    DICT            shift and go to state 16
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    STRING          shift and go to state 15
    OBJECT          shift and go to state 9
    BOOL            shift and go to state 17

    e                              shift and go to state 10
    d                              shift and go to state 11
    f                              shift and go to state 12
    h                              shift and go to state 60
    type                           shift and go to state 18
    declare                        shift and go to state 58
    empty                          shift and go to state 59

state 47

    (39) g -> , ID .

    ;               reduce using rule 39 (g -> , ID .)
    )               reduce using rule 39 (g -> , ID .)


state 48

    (37) e -> STRUCT ID struct ; . h
    (41) h -> . declare
    (42) h -> . empty
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (106) empty -> .
    (36) d -> . type ID g ; h
    (37) e -> . STRUCT ID struct ; h
    (38) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 106 (empty -> .)
    MAIN            reduce using rule 106 (empty -> .)
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)
    STRUCT          shift and go to state 20
    DICT            shift and go to state 16
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    STRING          shift and go to state 15
    OBJECT          shift and go to state 9
    BOOL            shift and go to state 17

    e                              shift and go to state 10
    d                              shift and go to state 11
    f                              shift and go to state 12
    h                              shift and go to state 61
    type                           shift and go to state 18
    declare                        shift and go to state 58
    empty                          shift and go to state 59

state 49

    (61) struct -> type [ . CTED ] optionalMatrix

    CTED            shift and go to state 62


state 50

    (32) opParameters -> ( param . )

    )               shift and go to state 63


state 51

    (28) param -> type . ID g k

    ID              shift and go to state 64


state 52

    (34) opReturns -> RETURNS . type
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    STRING          shift and go to state 15
    OBJECT          shift and go to state 9
    BOOL            shift and go to state 17

    type                           shift and go to state 65

state 53

    (35) opReturns -> empty .

    {               reduce using rule 35 (opReturns -> empty .)


state 54

    (31) function -> FUNC ID opParameters opReturns . { opVars body }

    {               shift and go to state 66


state 55

    (12) main -> MAIN { opVars . body }
    (43) body -> . cyInstruction
    (44) body -> . empty
    (45) cyInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 78
    ID              shift and go to state 76
    FOR             shift and go to state 75
    WHILE           shift and go to state 69

    body                           shift and go to state 74
    c                              shift and go to state 79
    funcCall                       shift and go to state 80
    instr                          shift and go to state 67
    forCycle                       shift and go to state 70
    assign                         shift and go to state 81
    whileCycle                     shift and go to state 68
    condition                      shift and go to state 77
    cyInstruction                  shift and go to state 71
    empty                          shift and go to state 73
    cycle                          shift and go to state 72

state 56

    (67) dict -> ( type : . type )
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    STRING          shift and go to state 15
    OBJECT          shift and go to state 9
    BOOL            shift and go to state 17

    type                           shift and go to state 82

state 57

    (38) f -> DICT ID dict ; h .

    FUNC            reduce using rule 38 (f -> DICT ID dict ; h .)
    MAIN            reduce using rule 38 (f -> DICT ID dict ; h .)
    IF              reduce using rule 38 (f -> DICT ID dict ; h .)
    ID              reduce using rule 38 (f -> DICT ID dict ; h .)
    FOR             reduce using rule 38 (f -> DICT ID dict ; h .)
    WHILE           reduce using rule 38 (f -> DICT ID dict ; h .)
    }               reduce using rule 38 (f -> DICT ID dict ; h .)


state 58

    (41) h -> declare .

    FUNC            reduce using rule 41 (h -> declare .)
    MAIN            reduce using rule 41 (h -> declare .)
    IF              reduce using rule 41 (h -> declare .)
    ID              reduce using rule 41 (h -> declare .)
    FOR             reduce using rule 41 (h -> declare .)
    WHILE           reduce using rule 41 (h -> declare .)
    }               reduce using rule 41 (h -> declare .)


state 59

    (42) h -> empty .

    FUNC            reduce using rule 42 (h -> empty .)
    MAIN            reduce using rule 42 (h -> empty .)
    IF              reduce using rule 42 (h -> empty .)
    ID              reduce using rule 42 (h -> empty .)
    FOR             reduce using rule 42 (h -> empty .)
    WHILE           reduce using rule 42 (h -> empty .)
    }               reduce using rule 42 (h -> empty .)


state 60

    (36) d -> type ID g ; h .

    FUNC            reduce using rule 36 (d -> type ID g ; h .)
    MAIN            reduce using rule 36 (d -> type ID g ; h .)
    IF              reduce using rule 36 (d -> type ID g ; h .)
    ID              reduce using rule 36 (d -> type ID g ; h .)
    FOR             reduce using rule 36 (d -> type ID g ; h .)
    WHILE           reduce using rule 36 (d -> type ID g ; h .)
    }               reduce using rule 36 (d -> type ID g ; h .)


state 61

    (37) e -> STRUCT ID struct ; h .

    FUNC            reduce using rule 37 (e -> STRUCT ID struct ; h .)
    MAIN            reduce using rule 37 (e -> STRUCT ID struct ; h .)
    IF              reduce using rule 37 (e -> STRUCT ID struct ; h .)
    ID              reduce using rule 37 (e -> STRUCT ID struct ; h .)
    FOR             reduce using rule 37 (e -> STRUCT ID struct ; h .)
    WHILE           reduce using rule 37 (e -> STRUCT ID struct ; h .)
    }               reduce using rule 37 (e -> STRUCT ID struct ; h .)


state 62

    (61) struct -> type [ CTED . ] optionalMatrix

    ]               shift and go to state 83


state 63

    (32) opParameters -> ( param ) .

    RETURNS         reduce using rule 32 (opParameters -> ( param ) .)
    {               reduce using rule 32 (opParameters -> ( param ) .)


state 64

    (28) param -> type ID . g k
    (39) g -> . , ID
    (40) g -> . empty
    (106) empty -> .

    ,               shift and go to state 35
    ;               reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)

    empty                          shift and go to state 36
    g                              shift and go to state 84

state 65

    (34) opReturns -> RETURNS type .

    {               reduce using rule 34 (opReturns -> RETURNS type .)


state 66

    (31) function -> FUNC ID opParameters opReturns { . opVars body }
    (2) opVars -> . vars
    (3) opVars -> . empty
    (6) vars -> . VARS declare
    (106) empty -> .

    VARS            shift and go to state 5
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)

    vars                           shift and go to state 6
    opVars                         shift and go to state 85
    empty                          shift and go to state 8

state 67

    (45) cyInstruction -> instr . body
    (43) body -> . cyInstruction
    (44) body -> . empty
    (45) cyInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 78
    ID              shift and go to state 76
    FOR             shift and go to state 75
    WHILE           shift and go to state 69

    body                           shift and go to state 86
    c                              shift and go to state 79
    funcCall                       shift and go to state 80
    instr                          shift and go to state 67
    forCycle                       shift and go to state 70
    assign                         shift and go to state 81
    whileCycle                     shift and go to state 68
    empty                          shift and go to state 73
    cyInstruction                  shift and go to state 71
    condition                      shift and go to state 77
    cycle                          shift and go to state 72

state 68

    (47) cycle -> whileCycle .

    IF              reduce using rule 47 (cycle -> whileCycle .)
    ID              reduce using rule 47 (cycle -> whileCycle .)
    FOR             reduce using rule 47 (cycle -> whileCycle .)
    WHILE           reduce using rule 47 (cycle -> whileCycle .)
    }               reduce using rule 47 (cycle -> whileCycle .)


state 69

    (48) whileCycle -> WHILE . ( expresion ) { body }

    (               shift and go to state 87


state 70

    (46) cycle -> forCycle .

    IF              reduce using rule 46 (cycle -> forCycle .)
    ID              reduce using rule 46 (cycle -> forCycle .)
    FOR             reduce using rule 46 (cycle -> forCycle .)
    WHILE           reduce using rule 46 (cycle -> forCycle .)
    }               reduce using rule 46 (cycle -> forCycle .)


state 71

    (43) body -> cyInstruction .

    }               reduce using rule 43 (body -> cyInstruction .)


state 72

    (15) instr -> cycle .

    IF              reduce using rule 15 (instr -> cycle .)
    ID              reduce using rule 15 (instr -> cycle .)
    FOR             reduce using rule 15 (instr -> cycle .)
    WHILE           reduce using rule 15 (instr -> cycle .)
    }               reduce using rule 15 (instr -> cycle .)


state 73

    (44) body -> empty .

    }               reduce using rule 44 (body -> empty .)


state 74

    (12) main -> MAIN { opVars body . }

    }               shift and go to state 88


state 75

    (49) forCycle -> FOR . ( assign ; expresion ; assign ) { body }

    (               shift and go to state 89


state 76

    (50) assign -> ID . assignOptions
    (56) funcCall -> ID . ( opParamCall )
    (51) assignOptions -> . init
    (52) assignOptions -> . initDict
    (53) assignOptions -> . [ expresion ] assignMatrix init
    (21) init -> . = i
    (24) initDict -> . = ( j : j )

    (               shift and go to state 90
    [               shift and go to state 95
    =               shift and go to state 92

    initDict                       shift and go to state 91
    assignOptions                  shift and go to state 93
    init                           shift and go to state 94

state 77

    (14) instr -> condition .

    IF              reduce using rule 14 (instr -> condition .)
    ID              reduce using rule 14 (instr -> condition .)
    FOR             reduce using rule 14 (instr -> condition .)
    WHILE           reduce using rule 14 (instr -> condition .)
    }               reduce using rule 14 (instr -> condition .)


state 78

    (64) condition -> IF . ( expresion ) { body } optionalElse

    (               shift and go to state 96


state 79

    (13) instr -> c . ;

    ;               shift and go to state 97


state 80

    (17) c -> funcCall .

    ;               reduce using rule 17 (c -> funcCall .)


state 81

    (16) c -> assign .

    ;               reduce using rule 16 (c -> assign .)


state 82

    (67) dict -> ( type : type . )

    )               shift and go to state 98


state 83

    (61) struct -> type [ CTED ] . optionalMatrix
    (62) optionalMatrix -> . [ CTED ]
    (63) optionalMatrix -> . empty
    (106) empty -> .

    [               shift and go to state 100
    ;               reduce using rule 106 (empty -> .)

    optionalMatrix                 shift and go to state 99
    empty                          shift and go to state 101

state 84

    (28) param -> type ID g . k
    (29) k -> . ; param
    (30) k -> . empty
    (106) empty -> .

    ;               shift and go to state 103
    )               reduce using rule 106 (empty -> .)

    k                              shift and go to state 102
    empty                          shift and go to state 104

state 85

    (31) function -> FUNC ID opParameters opReturns { opVars . body }
    (43) body -> . cyInstruction
    (44) body -> . empty
    (45) cyInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 78
    ID              shift and go to state 76
    FOR             shift and go to state 75
    WHILE           shift and go to state 69

    body                           shift and go to state 105
    c                              shift and go to state 79
    funcCall                       shift and go to state 80
    instr                          shift and go to state 67
    forCycle                       shift and go to state 70
    assign                         shift and go to state 81
    whileCycle                     shift and go to state 68
    condition                      shift and go to state 77
    cycle                          shift and go to state 72
    cyInstruction                  shift and go to state 71
    empty                          shift and go to state 73

state 86

    (45) cyInstruction -> instr body .

    }               reduce using rule 45 (cyInstruction -> instr body .)


state 87

    (48) whileCycle -> WHILE ( . expresion ) { body }
    (68) expresion -> . sExp cyExpresion
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 111
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 88

    (12) main -> MAIN { opVars body } .

    }               reduce using rule 12 (main -> MAIN { opVars body } .)


state 89

    (49) forCycle -> FOR ( . assign ; expresion ; assign ) { body }
    (50) assign -> . ID assignOptions

    ID              shift and go to state 120

    assign                         shift and go to state 121

state 90

    (56) funcCall -> ID ( . opParamCall )
    (57) opParamCall -> . expresion cyParamCall
    (58) opParamCall -> . empty
    (68) expresion -> . sExp cyExpresion
    (106) empty -> .
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    )               reduce using rule 106 (empty -> .)
    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 124
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    fact                           shift and go to state 119
    exp                            shift and go to state 109
    opParamCall                    shift and go to state 122
    empty                          shift and go to state 123

state 91

    (52) assignOptions -> initDict .

    ;               reduce using rule 52 (assignOptions -> initDict .)
    )               reduce using rule 52 (assignOptions -> initDict .)


state 92

    (21) init -> = . i
    (24) initDict -> = . ( j : j )
    (22) i -> . expresion
    (23) i -> . funcCall
    (68) expresion -> . sExp cyExpresion
    (56) funcCall -> . ID ( opParamCall )
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE

    (               shift and go to state 125
    ID              shift and go to state 126
    CTES            shift and go to state 112
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 127
    term                           shift and go to state 113
    funcCall                       shift and go to state 128
    i                              shift and go to state 129
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 93

    (50) assign -> ID assignOptions .

    ;               reduce using rule 50 (assign -> ID assignOptions .)
    )               reduce using rule 50 (assign -> ID assignOptions .)


state 94

    (51) assignOptions -> init .

    ;               reduce using rule 51 (assignOptions -> init .)
    )               reduce using rule 51 (assignOptions -> init .)


state 95

    (53) assignOptions -> [ . expresion ] assignMatrix init
    (68) expresion -> . sExp cyExpresion
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 130
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 96

    (64) condition -> IF ( . expresion ) { body } optionalElse
    (68) expresion -> . sExp cyExpresion
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 131
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 97

    (13) instr -> c ; .

    IF              reduce using rule 13 (instr -> c ; .)
    ID              reduce using rule 13 (instr -> c ; .)
    FOR             reduce using rule 13 (instr -> c ; .)
    WHILE           reduce using rule 13 (instr -> c ; .)
    }               reduce using rule 13 (instr -> c ; .)


state 98

    (67) dict -> ( type : type ) .

    ;               reduce using rule 67 (dict -> ( type : type ) .)


state 99

    (61) struct -> type [ CTED ] optionalMatrix .

    ;               reduce using rule 61 (struct -> type [ CTED ] optionalMatrix .)


state 100

    (62) optionalMatrix -> [ . CTED ]

    CTED            shift and go to state 132


state 101

    (63) optionalMatrix -> empty .

    ;               reduce using rule 63 (optionalMatrix -> empty .)


state 102

    (28) param -> type ID g k .

    )               reduce using rule 28 (param -> type ID g k .)


state 103

    (29) k -> ; . param
    (28) param -> . type ID g k
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    STRING          shift and go to state 15
    OBJECT          shift and go to state 9
    BOOL            shift and go to state 17

    type                           shift and go to state 51
    param                          shift and go to state 133

state 104

    (30) k -> empty .

    )               reduce using rule 30 (k -> empty .)


state 105

    (31) function -> FUNC ID opParameters opReturns { opVars body . }

    }               shift and go to state 134


state 106

    (104) cte -> TRUE .

    *               reduce using rule 104 (cte -> TRUE .)
    /               reduce using rule 104 (cte -> TRUE .)
    +               reduce using rule 104 (cte -> TRUE .)
    -               reduce using rule 104 (cte -> TRUE .)
    EQ              reduce using rule 104 (cte -> TRUE .)
    DIF             reduce using rule 104 (cte -> TRUE .)
    LTOEQ           reduce using rule 104 (cte -> TRUE .)
    GTOEQ           reduce using rule 104 (cte -> TRUE .)
    >               reduce using rule 104 (cte -> TRUE .)
    <               reduce using rule 104 (cte -> TRUE .)
    AND             reduce using rule 104 (cte -> TRUE .)
    OR              reduce using rule 104 (cte -> TRUE .)
    ]               reduce using rule 104 (cte -> TRUE .)
    ;               reduce using rule 104 (cte -> TRUE .)
    )               reduce using rule 104 (cte -> TRUE .)
    ,               reduce using rule 104 (cte -> TRUE .)
    :               reduce using rule 104 (cte -> TRUE .)


state 107

    (91) fact -> ( . expresion )
    (68) expresion -> . sExp cyExpresion
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 135
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 108

    (68) expresion -> sExp . cyExpresion
    (69) cyExpresion -> . AND expresion
    (70) cyExpresion -> . OR expresion
    (71) cyExpresion -> . empty
    (106) empty -> .

    AND             shift and go to state 136
    OR              shift and go to state 138
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ;               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)

    cyExpresion                    shift and go to state 137
    empty                          shift and go to state 139

state 109

    (72) sExp -> exp . opSExp
    (73) opSExp -> . EQ exp
    (74) opSExp -> . DIF exp
    (75) opSExp -> . LTOEQ exp
    (76) opSExp -> . GTOEQ exp
    (77) opSExp -> . > exp
    (78) opSExp -> . < exp
    (79) opSExp -> . empty
    (106) empty -> .

    EQ              shift and go to state 140
    DIF             shift and go to state 141
    LTOEQ           shift and go to state 144
    GTOEQ           shift and go to state 142
    >               shift and go to state 143
    <               shift and go to state 145
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ;               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)

    empty                          shift and go to state 146
    opSExp                         shift and go to state 147

state 110

    (92) fact -> ID . opAccess
    (56) funcCall -> ID . ( opParamCall )
    (93) opAccess -> . opStruct
    (94) opAccess -> . opDictionary
    (95) opAccess -> . empty
    (96) opStruct -> . [ expresion ] opMatrix
    (99) opDictionary -> . . dictIndex
    (106) empty -> .

    (               shift and go to state 90
    [               shift and go to state 151
    .               shift and go to state 152
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    ;               reduce using rule 106 (empty -> .)

    opDictionary                   shift and go to state 153
    opStruct                       shift and go to state 148
    opAccess                       shift and go to state 149
    empty                          shift and go to state 150

state 111

    (48) whileCycle -> WHILE ( expresion . ) { body }

    )               shift and go to state 154


state 112

    (88) fact -> CTES .

    *               reduce using rule 88 (fact -> CTES .)
    /               reduce using rule 88 (fact -> CTES .)
    +               reduce using rule 88 (fact -> CTES .)
    -               reduce using rule 88 (fact -> CTES .)
    EQ              reduce using rule 88 (fact -> CTES .)
    DIF             reduce using rule 88 (fact -> CTES .)
    LTOEQ           reduce using rule 88 (fact -> CTES .)
    GTOEQ           reduce using rule 88 (fact -> CTES .)
    >               reduce using rule 88 (fact -> CTES .)
    <               reduce using rule 88 (fact -> CTES .)
    AND             reduce using rule 88 (fact -> CTES .)
    OR              reduce using rule 88 (fact -> CTES .)
    ]               reduce using rule 88 (fact -> CTES .)
    )               reduce using rule 88 (fact -> CTES .)
    ,               reduce using rule 88 (fact -> CTES .)
    ;               reduce using rule 88 (fact -> CTES .)


state 113

    (80) exp -> term . cyExp
    (81) cyExp -> . + term
    (82) cyExp -> . - term
    (83) cyExp -> . empty
    (106) empty -> .

    +               shift and go to state 157
    -               shift and go to state 156
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ;               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)

    cyExp                          shift and go to state 155
    empty                          shift and go to state 158

state 114

    (105) cte -> FALSE .

    *               reduce using rule 105 (cte -> FALSE .)
    /               reduce using rule 105 (cte -> FALSE .)
    +               reduce using rule 105 (cte -> FALSE .)
    -               reduce using rule 105 (cte -> FALSE .)
    EQ              reduce using rule 105 (cte -> FALSE .)
    DIF             reduce using rule 105 (cte -> FALSE .)
    LTOEQ           reduce using rule 105 (cte -> FALSE .)
    GTOEQ           reduce using rule 105 (cte -> FALSE .)
    >               reduce using rule 105 (cte -> FALSE .)
    <               reduce using rule 105 (cte -> FALSE .)
    AND             reduce using rule 105 (cte -> FALSE .)
    OR              reduce using rule 105 (cte -> FALSE .)
    ]               reduce using rule 105 (cte -> FALSE .)
    ;               reduce using rule 105 (cte -> FALSE .)
    )               reduce using rule 105 (cte -> FALSE .)
    ,               reduce using rule 105 (cte -> FALSE .)
    :               reduce using rule 105 (cte -> FALSE .)


state 115

    (90) fact -> funcCall .

    *               reduce using rule 90 (fact -> funcCall .)
    /               reduce using rule 90 (fact -> funcCall .)
    +               reduce using rule 90 (fact -> funcCall .)
    -               reduce using rule 90 (fact -> funcCall .)
    EQ              reduce using rule 90 (fact -> funcCall .)
    DIF             reduce using rule 90 (fact -> funcCall .)
    LTOEQ           reduce using rule 90 (fact -> funcCall .)
    GTOEQ           reduce using rule 90 (fact -> funcCall .)
    >               reduce using rule 90 (fact -> funcCall .)
    <               reduce using rule 90 (fact -> funcCall .)
    AND             reduce using rule 90 (fact -> funcCall .)
    OR              reduce using rule 90 (fact -> funcCall .)
    ]               reduce using rule 90 (fact -> funcCall .)
    )               reduce using rule 90 (fact -> funcCall .)
    ,               reduce using rule 90 (fact -> funcCall .)
    ;               reduce using rule 90 (fact -> funcCall .)


state 116

    (89) fact -> cte .

    *               reduce using rule 89 (fact -> cte .)
    /               reduce using rule 89 (fact -> cte .)
    +               reduce using rule 89 (fact -> cte .)
    -               reduce using rule 89 (fact -> cte .)
    EQ              reduce using rule 89 (fact -> cte .)
    DIF             reduce using rule 89 (fact -> cte .)
    LTOEQ           reduce using rule 89 (fact -> cte .)
    GTOEQ           reduce using rule 89 (fact -> cte .)
    >               reduce using rule 89 (fact -> cte .)
    <               reduce using rule 89 (fact -> cte .)
    AND             reduce using rule 89 (fact -> cte .)
    OR              reduce using rule 89 (fact -> cte .)
    ]               reduce using rule 89 (fact -> cte .)
    )               reduce using rule 89 (fact -> cte .)
    ,               reduce using rule 89 (fact -> cte .)
    ;               reduce using rule 89 (fact -> cte .)


state 117

    (103) cte -> CTEF .

    *               reduce using rule 103 (cte -> CTEF .)
    /               reduce using rule 103 (cte -> CTEF .)
    +               reduce using rule 103 (cte -> CTEF .)
    -               reduce using rule 103 (cte -> CTEF .)
    EQ              reduce using rule 103 (cte -> CTEF .)
    DIF             reduce using rule 103 (cte -> CTEF .)
    LTOEQ           reduce using rule 103 (cte -> CTEF .)
    GTOEQ           reduce using rule 103 (cte -> CTEF .)
    >               reduce using rule 103 (cte -> CTEF .)
    <               reduce using rule 103 (cte -> CTEF .)
    AND             reduce using rule 103 (cte -> CTEF .)
    OR              reduce using rule 103 (cte -> CTEF .)
    ]               reduce using rule 103 (cte -> CTEF .)
    ;               reduce using rule 103 (cte -> CTEF .)
    )               reduce using rule 103 (cte -> CTEF .)
    ,               reduce using rule 103 (cte -> CTEF .)
    :               reduce using rule 103 (cte -> CTEF .)


state 118

    (102) cte -> CTED .

    *               reduce using rule 102 (cte -> CTED .)
    /               reduce using rule 102 (cte -> CTED .)
    +               reduce using rule 102 (cte -> CTED .)
    -               reduce using rule 102 (cte -> CTED .)
    EQ              reduce using rule 102 (cte -> CTED .)
    DIF             reduce using rule 102 (cte -> CTED .)
    LTOEQ           reduce using rule 102 (cte -> CTED .)
    GTOEQ           reduce using rule 102 (cte -> CTED .)
    >               reduce using rule 102 (cte -> CTED .)
    <               reduce using rule 102 (cte -> CTED .)
    AND             reduce using rule 102 (cte -> CTED .)
    OR              reduce using rule 102 (cte -> CTED .)
    ]               reduce using rule 102 (cte -> CTED .)
    ;               reduce using rule 102 (cte -> CTED .)
    )               reduce using rule 102 (cte -> CTED .)
    ,               reduce using rule 102 (cte -> CTED .)
    :               reduce using rule 102 (cte -> CTED .)


state 119

    (84) term -> fact . cyTerm
    (85) cyTerm -> . * fact
    (86) cyTerm -> . / fact
    (87) cyTerm -> . empty
    (106) empty -> .

    *               shift and go to state 161
    /               shift and go to state 162
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ;               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)

    cyTerm                         shift and go to state 159
    empty                          shift and go to state 160

state 120

    (50) assign -> ID . assignOptions
    (51) assignOptions -> . init
    (52) assignOptions -> . initDict
    (53) assignOptions -> . [ expresion ] assignMatrix init
    (21) init -> . = i
    (24) initDict -> . = ( j : j )

    [               shift and go to state 95
    =               shift and go to state 92

    initDict                       shift and go to state 91
    assignOptions                  shift and go to state 93
    init                           shift and go to state 94

state 121

    (49) forCycle -> FOR ( assign . ; expresion ; assign ) { body }

    ;               shift and go to state 163


state 122

    (56) funcCall -> ID ( opParamCall . )

    )               shift and go to state 164


state 123

    (58) opParamCall -> empty .

    )               reduce using rule 58 (opParamCall -> empty .)


state 124

    (57) opParamCall -> expresion . cyParamCall
    (59) cyParamCall -> . , expresion cyParamCall
    (60) cyParamCall -> . empty
    (106) empty -> .

    ,               shift and go to state 166
    )               reduce using rule 106 (empty -> .)

    cyParamCall                    shift and go to state 165
    empty                          shift and go to state 167

state 125

    (24) initDict -> = ( . j : j )
    (91) fact -> ( . expresion )
    (25) j -> . CTES
    (26) j -> . cte
    (27) j -> . ID
    (68) expresion -> . sExp cyExpresion
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 169
    ID              shift and go to state 168
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114
    (               shift and go to state 107

    expresion                      shift and go to state 135
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    j                              shift and go to state 170
    sExp                           shift and go to state 108
    cte                            shift and go to state 171
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 126

    (56) funcCall -> ID . ( opParamCall )
    (92) fact -> ID . opAccess
    (93) opAccess -> . opStruct
    (94) opAccess -> . opDictionary
    (95) opAccess -> . empty
    (96) opStruct -> . [ expresion ] opMatrix
    (99) opDictionary -> . . dictIndex
    (106) empty -> .

    (               shift and go to state 90
    [               shift and go to state 151
    .               shift and go to state 152
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    ;               reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)

    opDictionary                   shift and go to state 153
    opStruct                       shift and go to state 148
    opAccess                       shift and go to state 149
    empty                          shift and go to state 150

state 127

    (22) i -> expresion .

    ;               reduce using rule 22 (i -> expresion .)
    )               reduce using rule 22 (i -> expresion .)


state 128

    (23) i -> funcCall .
    (90) fact -> funcCall .

  ! reduce/reduce conflict for ; resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for ) resolved using rule 23 (i -> funcCall .)
    ;               reduce using rule 23 (i -> funcCall .)
    )               reduce using rule 23 (i -> funcCall .)
    *               reduce using rule 90 (fact -> funcCall .)
    /               reduce using rule 90 (fact -> funcCall .)
    +               reduce using rule 90 (fact -> funcCall .)
    -               reduce using rule 90 (fact -> funcCall .)
    EQ              reduce using rule 90 (fact -> funcCall .)
    DIF             reduce using rule 90 (fact -> funcCall .)
    LTOEQ           reduce using rule 90 (fact -> funcCall .)
    GTOEQ           reduce using rule 90 (fact -> funcCall .)
    >               reduce using rule 90 (fact -> funcCall .)
    <               reduce using rule 90 (fact -> funcCall .)
    AND             reduce using rule 90 (fact -> funcCall .)
    OR              reduce using rule 90 (fact -> funcCall .)

  ! ;               [ reduce using rule 90 (fact -> funcCall .) ]
  ! )               [ reduce using rule 90 (fact -> funcCall .) ]


state 129

    (21) init -> = i .

    ;               reduce using rule 21 (init -> = i .)
    )               reduce using rule 21 (init -> = i .)


state 130

    (53) assignOptions -> [ expresion . ] assignMatrix init

    ]               shift and go to state 172


state 131

    (64) condition -> IF ( expresion . ) { body } optionalElse

    )               shift and go to state 173


state 132

    (62) optionalMatrix -> [ CTED . ]

    ]               shift and go to state 174


state 133

    (29) k -> ; param .

    )               reduce using rule 29 (k -> ; param .)


state 134

    (31) function -> FUNC ID opParameters opReturns { opVars body } .

    FUNC            reduce using rule 31 (function -> FUNC ID opParameters opReturns { opVars body } .)
    MAIN            reduce using rule 31 (function -> FUNC ID opParameters opReturns { opVars body } .)


state 135

    (91) fact -> ( expresion . )

    )               shift and go to state 175


state 136

    (69) cyExpresion -> AND . expresion
    (68) expresion -> . sExp cyExpresion
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 176
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 137

    (68) expresion -> sExp cyExpresion .

    ;               reduce using rule 68 (expresion -> sExp cyExpresion .)
    )               reduce using rule 68 (expresion -> sExp cyExpresion .)
    ,               reduce using rule 68 (expresion -> sExp cyExpresion .)
    ]               reduce using rule 68 (expresion -> sExp cyExpresion .)


state 138

    (70) cyExpresion -> OR . expresion
    (68) expresion -> . sExp cyExpresion
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 177
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 139

    (71) cyExpresion -> empty .

    )               reduce using rule 71 (cyExpresion -> empty .)
    ,               reduce using rule 71 (cyExpresion -> empty .)
    ;               reduce using rule 71 (cyExpresion -> empty .)
    ]               reduce using rule 71 (cyExpresion -> empty .)


state 140

    (73) opSExp -> EQ . exp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    cte                            shift and go to state 116
    exp                            shift and go to state 178
    fact                           shift and go to state 119

state 141

    (74) opSExp -> DIF . exp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    cte                            shift and go to state 116
    exp                            shift and go to state 179
    fact                           shift and go to state 119

state 142

    (76) opSExp -> GTOEQ . exp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    cte                            shift and go to state 116
    exp                            shift and go to state 180
    fact                           shift and go to state 119

state 143

    (77) opSExp -> > . exp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    cte                            shift and go to state 116
    exp                            shift and go to state 181
    fact                           shift and go to state 119

state 144

    (75) opSExp -> LTOEQ . exp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    cte                            shift and go to state 116
    exp                            shift and go to state 182
    fact                           shift and go to state 119

state 145

    (78) opSExp -> < . exp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    cte                            shift and go to state 116
    exp                            shift and go to state 183
    fact                           shift and go to state 119

state 146

    (79) opSExp -> empty .

    AND             reduce using rule 79 (opSExp -> empty .)
    OR              reduce using rule 79 (opSExp -> empty .)
    )               reduce using rule 79 (opSExp -> empty .)
    ,               reduce using rule 79 (opSExp -> empty .)
    ;               reduce using rule 79 (opSExp -> empty .)
    ]               reduce using rule 79 (opSExp -> empty .)


state 147

    (72) sExp -> exp opSExp .

    AND             reduce using rule 72 (sExp -> exp opSExp .)
    OR              reduce using rule 72 (sExp -> exp opSExp .)
    )               reduce using rule 72 (sExp -> exp opSExp .)
    ,               reduce using rule 72 (sExp -> exp opSExp .)
    ;               reduce using rule 72 (sExp -> exp opSExp .)
    ]               reduce using rule 72 (sExp -> exp opSExp .)


state 148

    (93) opAccess -> opStruct .

    *               reduce using rule 93 (opAccess -> opStruct .)
    /               reduce using rule 93 (opAccess -> opStruct .)
    +               reduce using rule 93 (opAccess -> opStruct .)
    -               reduce using rule 93 (opAccess -> opStruct .)
    EQ              reduce using rule 93 (opAccess -> opStruct .)
    DIF             reduce using rule 93 (opAccess -> opStruct .)
    LTOEQ           reduce using rule 93 (opAccess -> opStruct .)
    GTOEQ           reduce using rule 93 (opAccess -> opStruct .)
    >               reduce using rule 93 (opAccess -> opStruct .)
    <               reduce using rule 93 (opAccess -> opStruct .)
    AND             reduce using rule 93 (opAccess -> opStruct .)
    OR              reduce using rule 93 (opAccess -> opStruct .)
    )               reduce using rule 93 (opAccess -> opStruct .)
    ;               reduce using rule 93 (opAccess -> opStruct .)
    ,               reduce using rule 93 (opAccess -> opStruct .)
    ]               reduce using rule 93 (opAccess -> opStruct .)


state 149

    (92) fact -> ID opAccess .

    *               reduce using rule 92 (fact -> ID opAccess .)
    /               reduce using rule 92 (fact -> ID opAccess .)
    +               reduce using rule 92 (fact -> ID opAccess .)
    -               reduce using rule 92 (fact -> ID opAccess .)
    EQ              reduce using rule 92 (fact -> ID opAccess .)
    DIF             reduce using rule 92 (fact -> ID opAccess .)
    LTOEQ           reduce using rule 92 (fact -> ID opAccess .)
    GTOEQ           reduce using rule 92 (fact -> ID opAccess .)
    >               reduce using rule 92 (fact -> ID opAccess .)
    <               reduce using rule 92 (fact -> ID opAccess .)
    AND             reduce using rule 92 (fact -> ID opAccess .)
    OR              reduce using rule 92 (fact -> ID opAccess .)
    ]               reduce using rule 92 (fact -> ID opAccess .)
    )               reduce using rule 92 (fact -> ID opAccess .)
    ,               reduce using rule 92 (fact -> ID opAccess .)
    ;               reduce using rule 92 (fact -> ID opAccess .)


state 150

    (95) opAccess -> empty .

    *               reduce using rule 95 (opAccess -> empty .)
    /               reduce using rule 95 (opAccess -> empty .)
    +               reduce using rule 95 (opAccess -> empty .)
    -               reduce using rule 95 (opAccess -> empty .)
    EQ              reduce using rule 95 (opAccess -> empty .)
    DIF             reduce using rule 95 (opAccess -> empty .)
    LTOEQ           reduce using rule 95 (opAccess -> empty .)
    GTOEQ           reduce using rule 95 (opAccess -> empty .)
    >               reduce using rule 95 (opAccess -> empty .)
    <               reduce using rule 95 (opAccess -> empty .)
    AND             reduce using rule 95 (opAccess -> empty .)
    OR              reduce using rule 95 (opAccess -> empty .)
    )               reduce using rule 95 (opAccess -> empty .)
    ;               reduce using rule 95 (opAccess -> empty .)
    ,               reduce using rule 95 (opAccess -> empty .)
    ]               reduce using rule 95 (opAccess -> empty .)


state 151

    (96) opStruct -> [ . expresion ] opMatrix
    (68) expresion -> . sExp cyExpresion
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 184
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 152

    (99) opDictionary -> . . dictIndex
    (100) dictIndex -> . FIRST
    (101) dictIndex -> . LAST

    FIRST           shift and go to state 185
    LAST            shift and go to state 186

    dictIndex                      shift and go to state 187

state 153

    (94) opAccess -> opDictionary .

    *               reduce using rule 94 (opAccess -> opDictionary .)
    /               reduce using rule 94 (opAccess -> opDictionary .)
    +               reduce using rule 94 (opAccess -> opDictionary .)
    -               reduce using rule 94 (opAccess -> opDictionary .)
    EQ              reduce using rule 94 (opAccess -> opDictionary .)
    DIF             reduce using rule 94 (opAccess -> opDictionary .)
    LTOEQ           reduce using rule 94 (opAccess -> opDictionary .)
    GTOEQ           reduce using rule 94 (opAccess -> opDictionary .)
    >               reduce using rule 94 (opAccess -> opDictionary .)
    <               reduce using rule 94 (opAccess -> opDictionary .)
    AND             reduce using rule 94 (opAccess -> opDictionary .)
    OR              reduce using rule 94 (opAccess -> opDictionary .)
    )               reduce using rule 94 (opAccess -> opDictionary .)
    ;               reduce using rule 94 (opAccess -> opDictionary .)
    ,               reduce using rule 94 (opAccess -> opDictionary .)
    ]               reduce using rule 94 (opAccess -> opDictionary .)


state 154

    (48) whileCycle -> WHILE ( expresion ) . { body }

    {               shift and go to state 188


state 155

    (80) exp -> term cyExp .

    EQ              reduce using rule 80 (exp -> term cyExp .)
    DIF             reduce using rule 80 (exp -> term cyExp .)
    LTOEQ           reduce using rule 80 (exp -> term cyExp .)
    GTOEQ           reduce using rule 80 (exp -> term cyExp .)
    >               reduce using rule 80 (exp -> term cyExp .)
    <               reduce using rule 80 (exp -> term cyExp .)
    AND             reduce using rule 80 (exp -> term cyExp .)
    OR              reduce using rule 80 (exp -> term cyExp .)
    ]               reduce using rule 80 (exp -> term cyExp .)
    )               reduce using rule 80 (exp -> term cyExp .)
    ,               reduce using rule 80 (exp -> term cyExp .)
    ;               reduce using rule 80 (exp -> term cyExp .)


state 156

    (82) cyExp -> - . term
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    term                           shift and go to state 189
    funcCall                       shift and go to state 115
    cte                            shift and go to state 116
    fact                           shift and go to state 119

state 157

    (81) cyExp -> + . term
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    term                           shift and go to state 190
    funcCall                       shift and go to state 115
    cte                            shift and go to state 116
    fact                           shift and go to state 119

state 158

    (83) cyExp -> empty .

    EQ              reduce using rule 83 (cyExp -> empty .)
    DIF             reduce using rule 83 (cyExp -> empty .)
    LTOEQ           reduce using rule 83 (cyExp -> empty .)
    GTOEQ           reduce using rule 83 (cyExp -> empty .)
    >               reduce using rule 83 (cyExp -> empty .)
    <               reduce using rule 83 (cyExp -> empty .)
    AND             reduce using rule 83 (cyExp -> empty .)
    OR              reduce using rule 83 (cyExp -> empty .)
    )               reduce using rule 83 (cyExp -> empty .)
    ,               reduce using rule 83 (cyExp -> empty .)
    ;               reduce using rule 83 (cyExp -> empty .)
    ]               reduce using rule 83 (cyExp -> empty .)


state 159

    (84) term -> fact cyTerm .

    +               reduce using rule 84 (term -> fact cyTerm .)
    -               reduce using rule 84 (term -> fact cyTerm .)
    EQ              reduce using rule 84 (term -> fact cyTerm .)
    DIF             reduce using rule 84 (term -> fact cyTerm .)
    LTOEQ           reduce using rule 84 (term -> fact cyTerm .)
    GTOEQ           reduce using rule 84 (term -> fact cyTerm .)
    >               reduce using rule 84 (term -> fact cyTerm .)
    <               reduce using rule 84 (term -> fact cyTerm .)
    AND             reduce using rule 84 (term -> fact cyTerm .)
    OR              reduce using rule 84 (term -> fact cyTerm .)
    )               reduce using rule 84 (term -> fact cyTerm .)
    ,               reduce using rule 84 (term -> fact cyTerm .)
    ;               reduce using rule 84 (term -> fact cyTerm .)
    ]               reduce using rule 84 (term -> fact cyTerm .)


state 160

    (87) cyTerm -> empty .

    +               reduce using rule 87 (cyTerm -> empty .)
    -               reduce using rule 87 (cyTerm -> empty .)
    EQ              reduce using rule 87 (cyTerm -> empty .)
    DIF             reduce using rule 87 (cyTerm -> empty .)
    LTOEQ           reduce using rule 87 (cyTerm -> empty .)
    GTOEQ           reduce using rule 87 (cyTerm -> empty .)
    >               reduce using rule 87 (cyTerm -> empty .)
    <               reduce using rule 87 (cyTerm -> empty .)
    AND             reduce using rule 87 (cyTerm -> empty .)
    OR              reduce using rule 87 (cyTerm -> empty .)
    )               reduce using rule 87 (cyTerm -> empty .)
    ,               reduce using rule 87 (cyTerm -> empty .)
    ;               reduce using rule 87 (cyTerm -> empty .)
    ]               reduce using rule 87 (cyTerm -> empty .)


state 161

    (85) cyTerm -> * . fact
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    funcCall                       shift and go to state 115
    cte                            shift and go to state 116
    fact                           shift and go to state 191

state 162

    (86) cyTerm -> / . fact
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    funcCall                       shift and go to state 115
    cte                            shift and go to state 116
    fact                           shift and go to state 192

state 163

    (49) forCycle -> FOR ( assign ; . expresion ; assign ) { body }
    (68) expresion -> . sExp cyExpresion
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 193
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 164

    (56) funcCall -> ID ( opParamCall ) .

    *               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    /               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    EQ              reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    DIF             reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    LTOEQ           reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    GTOEQ           reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    >               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    <               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    AND             reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    OR              reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    )               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    ,               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    ;               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    ]               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    +               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    -               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)


state 165

    (57) opParamCall -> expresion cyParamCall .

    )               reduce using rule 57 (opParamCall -> expresion cyParamCall .)


state 166

    (59) cyParamCall -> , . expresion cyParamCall
    (68) expresion -> . sExp cyExpresion
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 194
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 167

    (60) cyParamCall -> empty .

    )               reduce using rule 60 (cyParamCall -> empty .)


state 168

    (27) j -> ID .
    (92) fact -> ID . opAccess
    (56) funcCall -> ID . ( opParamCall )
    (93) opAccess -> . opStruct
    (94) opAccess -> . opDictionary
    (95) opAccess -> . empty
    (96) opStruct -> . [ expresion ] opMatrix
    (99) opDictionary -> . . dictIndex
    (106) empty -> .

    :               reduce using rule 27 (j -> ID .)
    (               shift and go to state 90
    [               shift and go to state 151
    .               shift and go to state 152
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)

    opDictionary                   shift and go to state 153
    opStruct                       shift and go to state 148
    opAccess                       shift and go to state 149
    empty                          shift and go to state 150

state 169

    (25) j -> CTES .
    (88) fact -> CTES .

    :               reduce using rule 25 (j -> CTES .)
    *               reduce using rule 88 (fact -> CTES .)
    /               reduce using rule 88 (fact -> CTES .)
    +               reduce using rule 88 (fact -> CTES .)
    -               reduce using rule 88 (fact -> CTES .)
    EQ              reduce using rule 88 (fact -> CTES .)
    DIF             reduce using rule 88 (fact -> CTES .)
    LTOEQ           reduce using rule 88 (fact -> CTES .)
    GTOEQ           reduce using rule 88 (fact -> CTES .)
    >               reduce using rule 88 (fact -> CTES .)
    <               reduce using rule 88 (fact -> CTES .)
    AND             reduce using rule 88 (fact -> CTES .)
    OR              reduce using rule 88 (fact -> CTES .)
    )               reduce using rule 88 (fact -> CTES .)


state 170

    (24) initDict -> = ( j . : j )

    :               shift and go to state 195


state 171

    (26) j -> cte .
    (89) fact -> cte .

    :               reduce using rule 26 (j -> cte .)
    *               reduce using rule 89 (fact -> cte .)
    /               reduce using rule 89 (fact -> cte .)
    +               reduce using rule 89 (fact -> cte .)
    -               reduce using rule 89 (fact -> cte .)
    EQ              reduce using rule 89 (fact -> cte .)
    DIF             reduce using rule 89 (fact -> cte .)
    LTOEQ           reduce using rule 89 (fact -> cte .)
    GTOEQ           reduce using rule 89 (fact -> cte .)
    >               reduce using rule 89 (fact -> cte .)
    <               reduce using rule 89 (fact -> cte .)
    AND             reduce using rule 89 (fact -> cte .)
    OR              reduce using rule 89 (fact -> cte .)
    )               reduce using rule 89 (fact -> cte .)


state 172

    (53) assignOptions -> [ expresion ] . assignMatrix init
    (54) assignMatrix -> . [ expresion ]
    (55) assignMatrix -> . empty
    (106) empty -> .

    [               shift and go to state 197
    =               reduce using rule 106 (empty -> .)

    assignMatrix                   shift and go to state 196
    empty                          shift and go to state 198

state 173

    (64) condition -> IF ( expresion ) . { body } optionalElse

    {               shift and go to state 199


state 174

    (62) optionalMatrix -> [ CTED ] .

    ;               reduce using rule 62 (optionalMatrix -> [ CTED ] .)


state 175

    (91) fact -> ( expresion ) .

    *               reduce using rule 91 (fact -> ( expresion ) .)
    /               reduce using rule 91 (fact -> ( expresion ) .)
    +               reduce using rule 91 (fact -> ( expresion ) .)
    -               reduce using rule 91 (fact -> ( expresion ) .)
    EQ              reduce using rule 91 (fact -> ( expresion ) .)
    DIF             reduce using rule 91 (fact -> ( expresion ) .)
    LTOEQ           reduce using rule 91 (fact -> ( expresion ) .)
    GTOEQ           reduce using rule 91 (fact -> ( expresion ) .)
    >               reduce using rule 91 (fact -> ( expresion ) .)
    <               reduce using rule 91 (fact -> ( expresion ) .)
    AND             reduce using rule 91 (fact -> ( expresion ) .)
    OR              reduce using rule 91 (fact -> ( expresion ) .)
    ]               reduce using rule 91 (fact -> ( expresion ) .)
    )               reduce using rule 91 (fact -> ( expresion ) .)
    ,               reduce using rule 91 (fact -> ( expresion ) .)
    ;               reduce using rule 91 (fact -> ( expresion ) .)


state 176

    (69) cyExpresion -> AND expresion .

    )               reduce using rule 69 (cyExpresion -> AND expresion .)
    ,               reduce using rule 69 (cyExpresion -> AND expresion .)
    ;               reduce using rule 69 (cyExpresion -> AND expresion .)
    ]               reduce using rule 69 (cyExpresion -> AND expresion .)


state 177

    (70) cyExpresion -> OR expresion .

    )               reduce using rule 70 (cyExpresion -> OR expresion .)
    ,               reduce using rule 70 (cyExpresion -> OR expresion .)
    ;               reduce using rule 70 (cyExpresion -> OR expresion .)
    ]               reduce using rule 70 (cyExpresion -> OR expresion .)


state 178

    (73) opSExp -> EQ exp .

    AND             reduce using rule 73 (opSExp -> EQ exp .)
    OR              reduce using rule 73 (opSExp -> EQ exp .)
    )               reduce using rule 73 (opSExp -> EQ exp .)
    ,               reduce using rule 73 (opSExp -> EQ exp .)
    ;               reduce using rule 73 (opSExp -> EQ exp .)
    ]               reduce using rule 73 (opSExp -> EQ exp .)


state 179

    (74) opSExp -> DIF exp .

    AND             reduce using rule 74 (opSExp -> DIF exp .)
    OR              reduce using rule 74 (opSExp -> DIF exp .)
    )               reduce using rule 74 (opSExp -> DIF exp .)
    ,               reduce using rule 74 (opSExp -> DIF exp .)
    ;               reduce using rule 74 (opSExp -> DIF exp .)
    ]               reduce using rule 74 (opSExp -> DIF exp .)


state 180

    (76) opSExp -> GTOEQ exp .

    AND             reduce using rule 76 (opSExp -> GTOEQ exp .)
    OR              reduce using rule 76 (opSExp -> GTOEQ exp .)
    )               reduce using rule 76 (opSExp -> GTOEQ exp .)
    ,               reduce using rule 76 (opSExp -> GTOEQ exp .)
    ;               reduce using rule 76 (opSExp -> GTOEQ exp .)
    ]               reduce using rule 76 (opSExp -> GTOEQ exp .)


state 181

    (77) opSExp -> > exp .

    AND             reduce using rule 77 (opSExp -> > exp .)
    OR              reduce using rule 77 (opSExp -> > exp .)
    )               reduce using rule 77 (opSExp -> > exp .)
    ,               reduce using rule 77 (opSExp -> > exp .)
    ;               reduce using rule 77 (opSExp -> > exp .)
    ]               reduce using rule 77 (opSExp -> > exp .)


state 182

    (75) opSExp -> LTOEQ exp .

    AND             reduce using rule 75 (opSExp -> LTOEQ exp .)
    OR              reduce using rule 75 (opSExp -> LTOEQ exp .)
    )               reduce using rule 75 (opSExp -> LTOEQ exp .)
    ,               reduce using rule 75 (opSExp -> LTOEQ exp .)
    ;               reduce using rule 75 (opSExp -> LTOEQ exp .)
    ]               reduce using rule 75 (opSExp -> LTOEQ exp .)


state 183

    (78) opSExp -> < exp .

    AND             reduce using rule 78 (opSExp -> < exp .)
    OR              reduce using rule 78 (opSExp -> < exp .)
    )               reduce using rule 78 (opSExp -> < exp .)
    ,               reduce using rule 78 (opSExp -> < exp .)
    ;               reduce using rule 78 (opSExp -> < exp .)
    ]               reduce using rule 78 (opSExp -> < exp .)


state 184

    (96) opStruct -> [ expresion . ] opMatrix

    ]               shift and go to state 200


state 185

    (100) dictIndex -> FIRST .

    *               reduce using rule 100 (dictIndex -> FIRST .)
    /               reduce using rule 100 (dictIndex -> FIRST .)
    +               reduce using rule 100 (dictIndex -> FIRST .)
    -               reduce using rule 100 (dictIndex -> FIRST .)
    EQ              reduce using rule 100 (dictIndex -> FIRST .)
    DIF             reduce using rule 100 (dictIndex -> FIRST .)
    LTOEQ           reduce using rule 100 (dictIndex -> FIRST .)
    GTOEQ           reduce using rule 100 (dictIndex -> FIRST .)
    >               reduce using rule 100 (dictIndex -> FIRST .)
    <               reduce using rule 100 (dictIndex -> FIRST .)
    AND             reduce using rule 100 (dictIndex -> FIRST .)
    OR              reduce using rule 100 (dictIndex -> FIRST .)
    )               reduce using rule 100 (dictIndex -> FIRST .)
    ,               reduce using rule 100 (dictIndex -> FIRST .)
    ]               reduce using rule 100 (dictIndex -> FIRST .)
    ;               reduce using rule 100 (dictIndex -> FIRST .)


state 186

    (101) dictIndex -> LAST .

    *               reduce using rule 101 (dictIndex -> LAST .)
    /               reduce using rule 101 (dictIndex -> LAST .)
    +               reduce using rule 101 (dictIndex -> LAST .)
    -               reduce using rule 101 (dictIndex -> LAST .)
    EQ              reduce using rule 101 (dictIndex -> LAST .)
    DIF             reduce using rule 101 (dictIndex -> LAST .)
    LTOEQ           reduce using rule 101 (dictIndex -> LAST .)
    GTOEQ           reduce using rule 101 (dictIndex -> LAST .)
    >               reduce using rule 101 (dictIndex -> LAST .)
    <               reduce using rule 101 (dictIndex -> LAST .)
    AND             reduce using rule 101 (dictIndex -> LAST .)
    OR              reduce using rule 101 (dictIndex -> LAST .)
    )               reduce using rule 101 (dictIndex -> LAST .)
    ,               reduce using rule 101 (dictIndex -> LAST .)
    ]               reduce using rule 101 (dictIndex -> LAST .)
    ;               reduce using rule 101 (dictIndex -> LAST .)


state 187

    (99) opDictionary -> . dictIndex .

    *               reduce using rule 99 (opDictionary -> . dictIndex .)
    /               reduce using rule 99 (opDictionary -> . dictIndex .)
    +               reduce using rule 99 (opDictionary -> . dictIndex .)
    -               reduce using rule 99 (opDictionary -> . dictIndex .)
    EQ              reduce using rule 99 (opDictionary -> . dictIndex .)
    DIF             reduce using rule 99 (opDictionary -> . dictIndex .)
    LTOEQ           reduce using rule 99 (opDictionary -> . dictIndex .)
    GTOEQ           reduce using rule 99 (opDictionary -> . dictIndex .)
    >               reduce using rule 99 (opDictionary -> . dictIndex .)
    <               reduce using rule 99 (opDictionary -> . dictIndex .)
    AND             reduce using rule 99 (opDictionary -> . dictIndex .)
    OR              reduce using rule 99 (opDictionary -> . dictIndex .)
    )               reduce using rule 99 (opDictionary -> . dictIndex .)
    ,               reduce using rule 99 (opDictionary -> . dictIndex .)
    ]               reduce using rule 99 (opDictionary -> . dictIndex .)
    ;               reduce using rule 99 (opDictionary -> . dictIndex .)


state 188

    (48) whileCycle -> WHILE ( expresion ) { . body }
    (43) body -> . cyInstruction
    (44) body -> . empty
    (45) cyInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 78
    ID              shift and go to state 76
    FOR             shift and go to state 75
    WHILE           shift and go to state 69

    body                           shift and go to state 201
    c                              shift and go to state 79
    funcCall                       shift and go to state 80
    instr                          shift and go to state 67
    forCycle                       shift and go to state 70
    assign                         shift and go to state 81
    whileCycle                     shift and go to state 68
    condition                      shift and go to state 77
    cyInstruction                  shift and go to state 71
    empty                          shift and go to state 73
    cycle                          shift and go to state 72

state 189

    (82) cyExp -> - term .

    EQ              reduce using rule 82 (cyExp -> - term .)
    DIF             reduce using rule 82 (cyExp -> - term .)
    LTOEQ           reduce using rule 82 (cyExp -> - term .)
    GTOEQ           reduce using rule 82 (cyExp -> - term .)
    >               reduce using rule 82 (cyExp -> - term .)
    <               reduce using rule 82 (cyExp -> - term .)
    AND             reduce using rule 82 (cyExp -> - term .)
    OR              reduce using rule 82 (cyExp -> - term .)
    )               reduce using rule 82 (cyExp -> - term .)
    ,               reduce using rule 82 (cyExp -> - term .)
    ;               reduce using rule 82 (cyExp -> - term .)
    ]               reduce using rule 82 (cyExp -> - term .)


state 190

    (81) cyExp -> + term .

    EQ              reduce using rule 81 (cyExp -> + term .)
    DIF             reduce using rule 81 (cyExp -> + term .)
    LTOEQ           reduce using rule 81 (cyExp -> + term .)
    GTOEQ           reduce using rule 81 (cyExp -> + term .)
    >               reduce using rule 81 (cyExp -> + term .)
    <               reduce using rule 81 (cyExp -> + term .)
    AND             reduce using rule 81 (cyExp -> + term .)
    OR              reduce using rule 81 (cyExp -> + term .)
    )               reduce using rule 81 (cyExp -> + term .)
    ,               reduce using rule 81 (cyExp -> + term .)
    ;               reduce using rule 81 (cyExp -> + term .)
    ]               reduce using rule 81 (cyExp -> + term .)


state 191

    (85) cyTerm -> * fact .

    +               reduce using rule 85 (cyTerm -> * fact .)
    -               reduce using rule 85 (cyTerm -> * fact .)
    EQ              reduce using rule 85 (cyTerm -> * fact .)
    DIF             reduce using rule 85 (cyTerm -> * fact .)
    LTOEQ           reduce using rule 85 (cyTerm -> * fact .)
    GTOEQ           reduce using rule 85 (cyTerm -> * fact .)
    >               reduce using rule 85 (cyTerm -> * fact .)
    <               reduce using rule 85 (cyTerm -> * fact .)
    AND             reduce using rule 85 (cyTerm -> * fact .)
    OR              reduce using rule 85 (cyTerm -> * fact .)
    )               reduce using rule 85 (cyTerm -> * fact .)
    ,               reduce using rule 85 (cyTerm -> * fact .)
    ;               reduce using rule 85 (cyTerm -> * fact .)
    ]               reduce using rule 85 (cyTerm -> * fact .)


state 192

    (86) cyTerm -> / fact .

    +               reduce using rule 86 (cyTerm -> / fact .)
    -               reduce using rule 86 (cyTerm -> / fact .)
    EQ              reduce using rule 86 (cyTerm -> / fact .)
    DIF             reduce using rule 86 (cyTerm -> / fact .)
    LTOEQ           reduce using rule 86 (cyTerm -> / fact .)
    GTOEQ           reduce using rule 86 (cyTerm -> / fact .)
    >               reduce using rule 86 (cyTerm -> / fact .)
    <               reduce using rule 86 (cyTerm -> / fact .)
    AND             reduce using rule 86 (cyTerm -> / fact .)
    OR              reduce using rule 86 (cyTerm -> / fact .)
    )               reduce using rule 86 (cyTerm -> / fact .)
    ,               reduce using rule 86 (cyTerm -> / fact .)
    ;               reduce using rule 86 (cyTerm -> / fact .)
    ]               reduce using rule 86 (cyTerm -> / fact .)


state 193

    (49) forCycle -> FOR ( assign ; expresion . ; assign ) { body }

    ;               shift and go to state 202


state 194

    (59) cyParamCall -> , expresion . cyParamCall
    (59) cyParamCall -> . , expresion cyParamCall
    (60) cyParamCall -> . empty
    (106) empty -> .

    ,               shift and go to state 166
    )               reduce using rule 106 (empty -> .)

    cyParamCall                    shift and go to state 203
    empty                          shift and go to state 167

state 195

    (24) initDict -> = ( j : . j )
    (25) j -> . CTES
    (26) j -> . cte
    (27) j -> . ID
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE

    CTES            shift and go to state 204
    ID              shift and go to state 207
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    cte                            shift and go to state 206
    j                              shift and go to state 205

state 196

    (53) assignOptions -> [ expresion ] assignMatrix . init
    (21) init -> . = i

    =               shift and go to state 209

    init                           shift and go to state 208

state 197

    (54) assignMatrix -> [ . expresion ]
    (68) expresion -> . sExp cyExpresion
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 210
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 198

    (55) assignMatrix -> empty .

    =               reduce using rule 55 (assignMatrix -> empty .)


state 199

    (64) condition -> IF ( expresion ) { . body } optionalElse
    (43) body -> . cyInstruction
    (44) body -> . empty
    (45) cyInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 78
    ID              shift and go to state 76
    FOR             shift and go to state 75
    WHILE           shift and go to state 69

    body                           shift and go to state 211
    c                              shift and go to state 79
    funcCall                       shift and go to state 80
    instr                          shift and go to state 67
    forCycle                       shift and go to state 70
    assign                         shift and go to state 81
    whileCycle                     shift and go to state 68
    condition                      shift and go to state 77
    cyInstruction                  shift and go to state 71
    empty                          shift and go to state 73
    cycle                          shift and go to state 72

state 200

    (96) opStruct -> [ expresion ] . opMatrix
    (97) opMatrix -> . [ expresion ]
    (98) opMatrix -> . empty
    (106) empty -> .

    [               shift and go to state 212
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    ;               reduce using rule 106 (empty -> .)

    empty                          shift and go to state 213
    opMatrix                       shift and go to state 214

state 201

    (48) whileCycle -> WHILE ( expresion ) { body . }

    }               shift and go to state 215


state 202

    (49) forCycle -> FOR ( assign ; expresion ; . assign ) { body }
    (50) assign -> . ID assignOptions

    ID              shift and go to state 120

    assign                         shift and go to state 216

state 203

    (59) cyParamCall -> , expresion cyParamCall .

    )               reduce using rule 59 (cyParamCall -> , expresion cyParamCall .)


state 204

    (25) j -> CTES .

    )               reduce using rule 25 (j -> CTES .)


state 205

    (24) initDict -> = ( j : j . )

    )               shift and go to state 217


state 206

    (26) j -> cte .

    )               reduce using rule 26 (j -> cte .)


state 207

    (27) j -> ID .

    )               reduce using rule 27 (j -> ID .)


state 208

    (53) assignOptions -> [ expresion ] assignMatrix init .

    ;               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    )               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)


state 209

    (21) init -> = . i
    (22) i -> . expresion
    (23) i -> . funcCall
    (68) expresion -> . sExp cyExpresion
    (56) funcCall -> . ID ( opParamCall )
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE

    ID              shift and go to state 126
    CTES            shift and go to state 112
    (               shift and go to state 107
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 127
    term                           shift and go to state 113
    funcCall                       shift and go to state 128
    i                              shift and go to state 129
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 210

    (54) assignMatrix -> [ expresion . ]

    ]               shift and go to state 218


state 211

    (64) condition -> IF ( expresion ) { body . } optionalElse

    }               shift and go to state 219


state 212

    (97) opMatrix -> [ . expresion ]
    (68) expresion -> . sExp cyExpresion
    (72) sExp -> . exp opSExp
    (80) exp -> . term cyExp
    (84) term -> . fact cyTerm
    (88) fact -> . CTES
    (89) fact -> . cte
    (90) fact -> . funcCall
    (91) fact -> . ( expresion )
    (92) fact -> . ID opAccess
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE
    (56) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 112
    (               shift and go to state 107
    ID              shift and go to state 110
    CTED            shift and go to state 118
    CTEF            shift and go to state 117
    TRUE            shift and go to state 106
    FALSE           shift and go to state 114

    expresion                      shift and go to state 220
    term                           shift and go to state 113
    funcCall                       shift and go to state 115
    sExp                           shift and go to state 108
    cte                            shift and go to state 116
    exp                            shift and go to state 109
    fact                           shift and go to state 119

state 213

    (98) opMatrix -> empty .

    *               reduce using rule 98 (opMatrix -> empty .)
    /               reduce using rule 98 (opMatrix -> empty .)
    +               reduce using rule 98 (opMatrix -> empty .)
    -               reduce using rule 98 (opMatrix -> empty .)
    EQ              reduce using rule 98 (opMatrix -> empty .)
    DIF             reduce using rule 98 (opMatrix -> empty .)
    LTOEQ           reduce using rule 98 (opMatrix -> empty .)
    GTOEQ           reduce using rule 98 (opMatrix -> empty .)
    >               reduce using rule 98 (opMatrix -> empty .)
    <               reduce using rule 98 (opMatrix -> empty .)
    AND             reduce using rule 98 (opMatrix -> empty .)
    OR              reduce using rule 98 (opMatrix -> empty .)
    )               reduce using rule 98 (opMatrix -> empty .)
    ,               reduce using rule 98 (opMatrix -> empty .)
    ]               reduce using rule 98 (opMatrix -> empty .)
    ;               reduce using rule 98 (opMatrix -> empty .)


state 214

    (96) opStruct -> [ expresion ] opMatrix .

    *               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    /               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    +               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    -               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    EQ              reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    DIF             reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    LTOEQ           reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    GTOEQ           reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    >               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    <               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    AND             reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    OR              reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    )               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    ,               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    ]               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    ;               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)


state 215

    (48) whileCycle -> WHILE ( expresion ) { body } .

    IF              reduce using rule 48 (whileCycle -> WHILE ( expresion ) { body } .)
    ID              reduce using rule 48 (whileCycle -> WHILE ( expresion ) { body } .)
    FOR             reduce using rule 48 (whileCycle -> WHILE ( expresion ) { body } .)
    WHILE           reduce using rule 48 (whileCycle -> WHILE ( expresion ) { body } .)
    }               reduce using rule 48 (whileCycle -> WHILE ( expresion ) { body } .)


state 216

    (49) forCycle -> FOR ( assign ; expresion ; assign . ) { body }

    )               shift and go to state 221


state 217

    (24) initDict -> = ( j : j ) .

    ;               reduce using rule 24 (initDict -> = ( j : j ) .)
    )               reduce using rule 24 (initDict -> = ( j : j ) .)


state 218

    (54) assignMatrix -> [ expresion ] .

    =               reduce using rule 54 (assignMatrix -> [ expresion ] .)


state 219

    (64) condition -> IF ( expresion ) { body } . optionalElse
    (65) optionalElse -> . ELSE { body }
    (66) optionalElse -> . empty
    (106) empty -> .

    ELSE            shift and go to state 222
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)

    optionalElse                   shift and go to state 223
    empty                          shift and go to state 224

state 220

    (97) opMatrix -> [ expresion . ]

    ]               shift and go to state 225


state 221

    (49) forCycle -> FOR ( assign ; expresion ; assign ) . { body }

    {               shift and go to state 226


state 222

    (65) optionalElse -> ELSE . { body }

    {               shift and go to state 227


state 223

    (64) condition -> IF ( expresion ) { body } optionalElse .

    IF              reduce using rule 64 (condition -> IF ( expresion ) { body } optionalElse .)
    ID              reduce using rule 64 (condition -> IF ( expresion ) { body } optionalElse .)
    FOR             reduce using rule 64 (condition -> IF ( expresion ) { body } optionalElse .)
    WHILE           reduce using rule 64 (condition -> IF ( expresion ) { body } optionalElse .)
    }               reduce using rule 64 (condition -> IF ( expresion ) { body } optionalElse .)


state 224

    (66) optionalElse -> empty .

    IF              reduce using rule 66 (optionalElse -> empty .)
    ID              reduce using rule 66 (optionalElse -> empty .)
    FOR             reduce using rule 66 (optionalElse -> empty .)
    WHILE           reduce using rule 66 (optionalElse -> empty .)
    }               reduce using rule 66 (optionalElse -> empty .)


state 225

    (97) opMatrix -> [ expresion ] .

    *               reduce using rule 97 (opMatrix -> [ expresion ] .)
    /               reduce using rule 97 (opMatrix -> [ expresion ] .)
    +               reduce using rule 97 (opMatrix -> [ expresion ] .)
    -               reduce using rule 97 (opMatrix -> [ expresion ] .)
    EQ              reduce using rule 97 (opMatrix -> [ expresion ] .)
    DIF             reduce using rule 97 (opMatrix -> [ expresion ] .)
    LTOEQ           reduce using rule 97 (opMatrix -> [ expresion ] .)
    GTOEQ           reduce using rule 97 (opMatrix -> [ expresion ] .)
    >               reduce using rule 97 (opMatrix -> [ expresion ] .)
    <               reduce using rule 97 (opMatrix -> [ expresion ] .)
    AND             reduce using rule 97 (opMatrix -> [ expresion ] .)
    OR              reduce using rule 97 (opMatrix -> [ expresion ] .)
    )               reduce using rule 97 (opMatrix -> [ expresion ] .)
    ,               reduce using rule 97 (opMatrix -> [ expresion ] .)
    ]               reduce using rule 97 (opMatrix -> [ expresion ] .)
    ;               reduce using rule 97 (opMatrix -> [ expresion ] .)


state 226

    (49) forCycle -> FOR ( assign ; expresion ; assign ) { . body }
    (43) body -> . cyInstruction
    (44) body -> . empty
    (45) cyInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 78
    ID              shift and go to state 76
    FOR             shift and go to state 75
    WHILE           shift and go to state 69

    body                           shift and go to state 228
    c                              shift and go to state 79
    funcCall                       shift and go to state 80
    instr                          shift and go to state 67
    forCycle                       shift and go to state 70
    cyInstruction                  shift and go to state 71
    whileCycle                     shift and go to state 68
    condition                      shift and go to state 77
    assign                         shift and go to state 81
    empty                          shift and go to state 73
    cycle                          shift and go to state 72

state 227

    (65) optionalElse -> ELSE { . body }
    (43) body -> . cyInstruction
    (44) body -> . empty
    (45) cyInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 78
    ID              shift and go to state 76
    FOR             shift and go to state 75
    WHILE           shift and go to state 69

    body                           shift and go to state 229
    c                              shift and go to state 79
    funcCall                       shift and go to state 80
    instr                          shift and go to state 67
    forCycle                       shift and go to state 70
    assign                         shift and go to state 81
    whileCycle                     shift and go to state 68
    empty                          shift and go to state 73
    cyInstruction                  shift and go to state 71
    condition                      shift and go to state 77
    cycle                          shift and go to state 72

state 228

    (49) forCycle -> FOR ( assign ; expresion ; assign ) { body . }

    }               shift and go to state 230


state 229

    (65) optionalElse -> ELSE { body . }

    }               shift and go to state 231


state 230

    (49) forCycle -> FOR ( assign ; expresion ; assign ) { body } .

    IF              reduce using rule 49 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    ID              reduce using rule 49 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    FOR             reduce using rule 49 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    WHILE           reduce using rule 49 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    }               reduce using rule 49 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)


state 231

    (65) optionalElse -> ELSE { body } .

    IF              reduce using rule 65 (optionalElse -> ELSE { body } .)
    ID              reduce using rule 65 (optionalElse -> ELSE { body } .)
    FOR             reduce using rule 65 (optionalElse -> ELSE { body } .)
    WHILE           reduce using rule 65 (optionalElse -> ELSE { body } .)
    }               reduce using rule 65 (optionalElse -> ELSE { body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 128 resolved using rule (i -> funcCall)
WARNING: rejected rule (fact -> funcCall) in state 128
