Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> errorProgram PROGRAM ID { opVars opFunctions main }
Rule 2     errorProgram -> <empty>
Rule 3     opVars -> vars
Rule 4     opVars -> empty
Rule 5     opFunctions -> function opFunctions
Rule 6     opFunctions -> empty
Rule 7     vars -> errorVars VARS declare
Rule 8     errorVars -> <empty>
Rule 9     type -> errorType INT
Rule 10    type -> FLOAT
Rule 11    type -> STRING
Rule 12    type -> OBJECT
Rule 13    type -> BOOL
Rule 14    errorType -> <empty>
Rule 15    main -> errorMain MAIN { opVars body }
Rule 16    errorMain -> <empty>
Rule 17    instr -> basicStatements ;
Rule 18    instr -> condition
Rule 19    instr -> cycle
Rule 20    basicStatements -> assign
Rule 21    basicStatements -> funcCall
Rule 22    declare -> basicDeclare
Rule 23    declare -> structDeclare
Rule 24    declare -> dictDeclare
Rule 25    init -> = initWith errorInit
Rule 26    errorInit -> <empty>
Rule 27    initWith -> expresion
Rule 28    initWith -> funcCall
Rule 29    initDict -> = ( dictType : dictType ) errorInitDict
Rule 30    errorInitDict -> <empty>
Rule 31    dictType -> errorDictType CTES
Rule 32    dictType -> cte
Rule 33    dictType -> ID
Rule 34    errorDictType -> <empty>
Rule 35    param -> type errorParam ID cyTypeParam cyParam
Rule 36    errorParam -> <empty>
Rule 37    cyParam -> errorCyParam ; param
Rule 38    cyParam -> empty
Rule 39    errorCyParam -> <empty>
Rule 40    function -> errorFunction FUNC ID opParameters opReturns }
Rule 41    errorFunction -> <empty>
Rule 42    return -> errorReturn RETURN expresion ;
Rule 43    errorReturn -> <empty>
Rule 44    opParameters -> ( param ) errorOpParameters
Rule 45    opParameters -> empty
Rule 46    errorOpParameters -> <empty>
Rule 47    opReturns -> errorOpReturns RETURNS type { opVars body return
Rule 48    opReturns -> { opVars body
Rule 49    errorOpReturns -> <empty>
Rule 50    basicDeclare -> type errorBasicDeclare ID cyTypeParam ; cyDeclare
Rule 51    errorBasicDeclare -> <empty>
Rule 52    structDeclare -> errorStructDeclare STRUCT ID struct ; cyDeclare
Rule 53    errorStructDeclare -> <empty>
Rule 54    dictDeclare -> errorDictDeclare DICT ID dict ; cyDeclare
Rule 55    errorDictDeclare -> <empty>
Rule 56    cyTypeParam -> , ID
Rule 57    cyTypeParam -> empty
Rule 58    cyDeclare -> declare
Rule 59    cyDeclare -> empty
Rule 60    body -> errorBody cyInstruction
Rule 61    body -> empty
Rule 62    errorBody -> <empty>
Rule 63    cyInstruction -> instr body
Rule 64    cycle -> forCycle
Rule 65    cycle -> whileCycle
Rule 66    whileCycle -> errorWhileCycle WHILE ( expresion ) { body }
Rule 67    errorWhileCycle -> <empty>
Rule 68    forCycle -> errorForCycle FOR ( assign ; expresion ; assign ) { body }
Rule 69    errorForCycle -> <empty>
Rule 70    assign -> ID errorAssign assignOptions
Rule 71    errorAssign -> <empty>
Rule 72    assignOptions -> init
Rule 73    assignOptions -> initDict
Rule 74    assignOptions -> [ expresion ] assignMatrix init
Rule 75    assignMatrix -> [ expresion ] errorAssignMatrix
Rule 76    assignMatrix -> empty
Rule 77    errorAssignMatrix -> <empty>
Rule 78    funcCall -> ID ( opParamCall )
Rule 79    opParamCall -> expresion cyParamCall
Rule 80    opParamCall -> empty
Rule 81    cyParamCall -> , expresion cyParamCall
Rule 82    cyParamCall -> empty
Rule 83    struct -> structType [ CTED ] optionalMatrix
Rule 84    structType -> type
Rule 85    structType -> DICT dict
Rule 86    optionalMatrix -> [ CTED ]
Rule 87    optionalMatrix -> empty
Rule 88    condition -> errorCondition IF ( expresion ) { body } optionalElse
Rule 89    errorCondition -> <empty>
Rule 90    optionalElse -> errorElse ELSE { body }
Rule 91    optionalElse -> empty
Rule 92    errorElse -> <empty>
Rule 93    dict -> errorDict ( type : type )
Rule 94    errorDict -> <empty>
Rule 95    expresion -> sExp cyExpresion errorExpresion
Rule 96    errorExpresion -> <empty>
Rule 97    cyExpresion -> AND expresion
Rule 98    cyExpresion -> OR expresion
Rule 99    cyExpresion -> empty
Rule 100   sExp -> exp errorOpSExp opSExp
Rule 101   opSExp -> EQ exp
Rule 102   opSExp -> DIF exp
Rule 103   opSExp -> LTOEQ exp
Rule 104   opSExp -> GTOEQ exp
Rule 105   opSExp -> > exp
Rule 106   opSExp -> < exp
Rule 107   opSExp -> empty
Rule 108   errorOpSExp -> <empty>
Rule 109   exp -> term errorCyExp cyExp
Rule 110   cyExp -> + term
Rule 111   cyExp -> - term
Rule 112   cyExp -> empty
Rule 113   errorCyExp -> <empty>
Rule 114   term -> fact cyTerm
Rule 115   cyTerm -> * errorFact fact
Rule 116   cyTerm -> / fact
Rule 117   cyTerm -> empty
Rule 118   fact -> CTES
Rule 119   fact -> cte
Rule 120   fact -> funcCall
Rule 121   fact -> ( expresion )
Rule 122   fact -> ID opAccess errorOpAccess
Rule 123   errorFact -> <empty>
Rule 124   opAccess -> opStruct
Rule 125   opAccess -> opDictionary
Rule 126   opAccess -> empty
Rule 127   errorOpAccess -> <empty>
Rule 128   opStruct -> errorOpStruct [ expresion ] opMatrix
Rule 129   errorOpStruct -> <empty>
Rule 130   opMatrix -> errorOpMatrix [ expresion ]
Rule 131   opMatrix -> empty
Rule 132   errorOpMatrix -> <empty>
Rule 133   opDictionary -> . dictIndex
Rule 134   dictIndex -> FIRST
Rule 135   dictIndex -> LAST
Rule 136   cte -> CTED
Rule 137   cte -> CTEF
Rule 138   cte -> TRUE
Rule 139   cte -> FALSE
Rule 140   empty -> <empty>

Terminals, with rules where they appear

(                    : 29 44 66 68 78 88 93 121
)                    : 29 44 66 68 78 88 93 121
*                    : 115
+                    : 110
,                    : 56 81
-                    : 111
.                    : 133
/                    : 116
:                    : 29 93
;                    : 17 37 42 50 52 54 68 68
<                    : 106
=                    : 25 29
>                    : 105
AND                  : 97
BOOL                 : 13
CTED                 : 83 86 136
CTEF                 : 137
CTES                 : 31 118
DICT                 : 54 85
DIF                  : 102
ELSE                 : 90
EQ                   : 101
FALSE                : 139
FIRST                : 134
FLOAT                : 10
FOR                  : 68
FUNC                 : 40
GTOEQ                : 104
ID                   : 1 33 35 40 50 52 54 56 70 78 122
IF                   : 88
INT                  : 9
LAST                 : 135
LTOEQ                : 103
MAIN                 : 15
OBJECT               : 12
OR                   : 98
PROGRAM              : 1
RETURN               : 42
RETURNS              : 47
STRING               : 11
STRUCT               : 52
TRUE                 : 138
VARS                 : 7
WHILE                : 66
[                    : 74 75 83 86 128 130
]                    : 74 75 83 86 128 130
error                : 
{                    : 1 15 47 48 66 68 88 90
}                    : 1 15 40 66 68 88 90

Nonterminals, with rules where they appear

assign               : 20 68 68
assignMatrix         : 74
assignOptions        : 70
basicDeclare         : 22
basicStatements      : 17
body                 : 15 47 48 63 66 68 88 90
condition            : 18
cte                  : 32 119
cyDeclare            : 50 52 54
cyExp                : 109
cyExpresion          : 95
cyInstruction        : 60
cyParam              : 35
cyParamCall          : 79 81
cyTerm               : 114
cyTypeParam          : 35 50
cycle                : 19
declare              : 7 58
dict                 : 54 85
dictDeclare          : 24
dictIndex            : 133
dictType             : 29 29
empty                : 4 6 38 45 57 59 61 76 80 82 87 91 99 107 112 117 126 131
errorAssign          : 70
errorAssignMatrix    : 75
errorBasicDeclare    : 50
errorBody            : 60
errorCondition       : 88
errorCyExp           : 109
errorCyParam         : 37
errorDict            : 93
errorDictDeclare     : 54
errorDictType        : 31
errorElse            : 90
errorExpresion       : 95
errorFact            : 115
errorForCycle        : 68
errorFunction        : 40
errorInit            : 25
errorInitDict        : 29
errorMain            : 15
errorOpAccess        : 122
errorOpMatrix        : 130
errorOpParameters    : 44
errorOpReturns       : 47
errorOpSExp          : 100
errorOpStruct        : 128
errorParam           : 35
errorProgram         : 1
errorReturn          : 42
errorStructDeclare   : 52
errorType            : 9
errorVars            : 7
errorWhileCycle      : 66
exp                  : 100 101 102 103 104 105 106
expresion            : 27 42 66 68 74 75 79 81 88 97 98 121 128 130
fact                 : 114 115 116
forCycle             : 64
funcCall             : 21 28 120
function             : 5
init                 : 72 74
initDict             : 73
initWith             : 25
instr                : 63
main                 : 1
opAccess             : 122
opDictionary         : 125
opFunctions          : 1 5
opMatrix             : 128
opParamCall          : 78
opParameters         : 40
opReturns            : 40
opSExp               : 100
opStruct             : 124
opVars               : 1 15 47 48
optionalElse         : 88
optionalMatrix       : 83
param                : 37 44
program              : 0
return               : 47
sExp                 : 95
struct               : 52
structDeclare        : 23
structType           : 83
term                 : 109 110 111
type                 : 35 47 50 84 93 93
vars                 : 3
whileCycle           : 65

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . errorProgram PROGRAM ID { opVars opFunctions main }
    (2) errorProgram -> .

    PROGRAM         reduce using rule 2 (errorProgram -> .)

    program                        shift and go to state 1
    errorProgram                   shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> errorProgram . PROGRAM ID { opVars opFunctions main }

    PROGRAM         shift and go to state 3


state 3

    (1) program -> errorProgram PROGRAM . ID { opVars opFunctions main }

    ID              shift and go to state 4


state 4

    (1) program -> errorProgram PROGRAM ID . { opVars opFunctions main }

    {               shift and go to state 5


state 5

    (1) program -> errorProgram PROGRAM ID { . opVars opFunctions main }
    (3) opVars -> . vars
    (4) opVars -> . empty
    (7) vars -> . errorVars VARS declare
    (140) empty -> .
    (8) errorVars -> .

    MAIN            reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 140 (empty -> .)
    VARS            reduce using rule 8 (errorVars -> .)

    vars                           shift and go to state 6
    opVars                         shift and go to state 7
    errorVars                      shift and go to state 8
    empty                          shift and go to state 9

state 6

    (3) opVars -> vars .

    }               reduce using rule 3 (opVars -> vars .)
    ID              reduce using rule 3 (opVars -> vars .)
    IF              reduce using rule 3 (opVars -> vars .)
    FOR             reduce using rule 3 (opVars -> vars .)
    WHILE           reduce using rule 3 (opVars -> vars .)
    RETURN          reduce using rule 3 (opVars -> vars .)
    MAIN            reduce using rule 3 (opVars -> vars .)
    FUNC            reduce using rule 3 (opVars -> vars .)


state 7

    (1) program -> errorProgram PROGRAM ID { opVars . opFunctions main }
    (5) opFunctions -> . function opFunctions
    (6) opFunctions -> . empty
    (40) function -> . errorFunction FUNC ID opParameters opReturns }
    (140) empty -> .
    (41) errorFunction -> .

    MAIN            reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 41 (errorFunction -> .)

    function                       shift and go to state 10
    errorFunction                  shift and go to state 11
    empty                          shift and go to state 12
    opFunctions                    shift and go to state 13

state 8

    (7) vars -> errorVars . VARS declare

    VARS            shift and go to state 14


state 9

    (4) opVars -> empty .

    }               reduce using rule 4 (opVars -> empty .)
    ID              reduce using rule 4 (opVars -> empty .)
    IF              reduce using rule 4 (opVars -> empty .)
    FOR             reduce using rule 4 (opVars -> empty .)
    WHILE           reduce using rule 4 (opVars -> empty .)
    RETURN          reduce using rule 4 (opVars -> empty .)
    MAIN            reduce using rule 4 (opVars -> empty .)
    FUNC            reduce using rule 4 (opVars -> empty .)


state 10

    (5) opFunctions -> function . opFunctions
    (5) opFunctions -> . function opFunctions
    (6) opFunctions -> . empty
    (40) function -> . errorFunction FUNC ID opParameters opReturns }
    (140) empty -> .
    (41) errorFunction -> .

    MAIN            reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 41 (errorFunction -> .)

    function                       shift and go to state 10
    errorFunction                  shift and go to state 11
    opFunctions                    shift and go to state 15
    empty                          shift and go to state 12

state 11

    (40) function -> errorFunction . FUNC ID opParameters opReturns }

    FUNC            shift and go to state 16


state 12

    (6) opFunctions -> empty .

    MAIN            reduce using rule 6 (opFunctions -> empty .)


state 13

    (1) program -> errorProgram PROGRAM ID { opVars opFunctions . main }
    (15) main -> . errorMain MAIN { opVars body }
    (16) errorMain -> .

    MAIN            reduce using rule 16 (errorMain -> .)

    errorMain                      shift and go to state 17
    main                           shift and go to state 18

state 14

    (7) vars -> errorVars VARS . declare
    (22) declare -> . basicDeclare
    (23) declare -> . structDeclare
    (24) declare -> . dictDeclare
    (50) basicDeclare -> . type errorBasicDeclare ID cyTypeParam ; cyDeclare
    (52) structDeclare -> . errorStructDeclare STRUCT ID struct ; cyDeclare
    (54) dictDeclare -> . errorDictDeclare DICT ID dict ; cyDeclare
    (9) type -> . errorType INT
    (10) type -> . FLOAT
    (11) type -> . STRING
    (12) type -> . OBJECT
    (13) type -> . BOOL
    (53) errorStructDeclare -> .
    (55) errorDictDeclare -> .
    (14) errorType -> .

    FLOAT           shift and go to state 28
    STRING          shift and go to state 24
    OBJECT          shift and go to state 20
    BOOL            shift and go to state 22
    STRUCT          reduce using rule 53 (errorStructDeclare -> .)
    DICT            reduce using rule 55 (errorDictDeclare -> .)
    INT             reduce using rule 14 (errorType -> .)

    dictDeclare                    shift and go to state 19
    errorType                      shift and go to state 25
    basicDeclare                   shift and go to state 27
    errorDictDeclare               shift and go to state 21
    structDeclare                  shift and go to state 26
    errorStructDeclare             shift and go to state 30
    type                           shift and go to state 23
    declare                        shift and go to state 29

state 15

    (5) opFunctions -> function opFunctions .

    MAIN            reduce using rule 5 (opFunctions -> function opFunctions .)


state 16

    (40) function -> errorFunction FUNC . ID opParameters opReturns }

    ID              shift and go to state 31


state 17

    (15) main -> errorMain . MAIN { opVars body }

    MAIN            shift and go to state 32


state 18

    (1) program -> errorProgram PROGRAM ID { opVars opFunctions main . }

    }               shift and go to state 33


state 19

    (24) declare -> dictDeclare .

    MAIN            reduce using rule 24 (declare -> dictDeclare .)
    FUNC            reduce using rule 24 (declare -> dictDeclare .)
    }               reduce using rule 24 (declare -> dictDeclare .)
    ID              reduce using rule 24 (declare -> dictDeclare .)
    IF              reduce using rule 24 (declare -> dictDeclare .)
    FOR             reduce using rule 24 (declare -> dictDeclare .)
    WHILE           reduce using rule 24 (declare -> dictDeclare .)
    RETURN          reduce using rule 24 (declare -> dictDeclare .)


state 20

    (12) type -> OBJECT .

    :               reduce using rule 12 (type -> OBJECT .)
    ID              reduce using rule 12 (type -> OBJECT .)
    [               reduce using rule 12 (type -> OBJECT .)
    )               reduce using rule 12 (type -> OBJECT .)
    {               reduce using rule 12 (type -> OBJECT .)


state 21

    (54) dictDeclare -> errorDictDeclare . DICT ID dict ; cyDeclare

    DICT            shift and go to state 34


state 22

    (13) type -> BOOL .

    :               reduce using rule 13 (type -> BOOL .)
    ID              reduce using rule 13 (type -> BOOL .)
    [               reduce using rule 13 (type -> BOOL .)
    )               reduce using rule 13 (type -> BOOL .)
    {               reduce using rule 13 (type -> BOOL .)


state 23

    (50) basicDeclare -> type . errorBasicDeclare ID cyTypeParam ; cyDeclare
    (51) errorBasicDeclare -> .

    ID              reduce using rule 51 (errorBasicDeclare -> .)

    errorBasicDeclare              shift and go to state 35

state 24

    (11) type -> STRING .

    :               reduce using rule 11 (type -> STRING .)
    ID              reduce using rule 11 (type -> STRING .)
    [               reduce using rule 11 (type -> STRING .)
    )               reduce using rule 11 (type -> STRING .)
    {               reduce using rule 11 (type -> STRING .)


state 25

    (9) type -> errorType . INT

    INT             shift and go to state 36


state 26

    (23) declare -> structDeclare .

    MAIN            reduce using rule 23 (declare -> structDeclare .)
    FUNC            reduce using rule 23 (declare -> structDeclare .)
    }               reduce using rule 23 (declare -> structDeclare .)
    ID              reduce using rule 23 (declare -> structDeclare .)
    IF              reduce using rule 23 (declare -> structDeclare .)
    FOR             reduce using rule 23 (declare -> structDeclare .)
    WHILE           reduce using rule 23 (declare -> structDeclare .)
    RETURN          reduce using rule 23 (declare -> structDeclare .)


state 27

    (22) declare -> basicDeclare .

    MAIN            reduce using rule 22 (declare -> basicDeclare .)
    FUNC            reduce using rule 22 (declare -> basicDeclare .)
    }               reduce using rule 22 (declare -> basicDeclare .)
    ID              reduce using rule 22 (declare -> basicDeclare .)
    IF              reduce using rule 22 (declare -> basicDeclare .)
    FOR             reduce using rule 22 (declare -> basicDeclare .)
    WHILE           reduce using rule 22 (declare -> basicDeclare .)
    RETURN          reduce using rule 22 (declare -> basicDeclare .)


state 28

    (10) type -> FLOAT .

    :               reduce using rule 10 (type -> FLOAT .)
    ID              reduce using rule 10 (type -> FLOAT .)
    [               reduce using rule 10 (type -> FLOAT .)
    )               reduce using rule 10 (type -> FLOAT .)
    {               reduce using rule 10 (type -> FLOAT .)


state 29

    (7) vars -> errorVars VARS declare .

    }               reduce using rule 7 (vars -> errorVars VARS declare .)
    ID              reduce using rule 7 (vars -> errorVars VARS declare .)
    IF              reduce using rule 7 (vars -> errorVars VARS declare .)
    FOR             reduce using rule 7 (vars -> errorVars VARS declare .)
    WHILE           reduce using rule 7 (vars -> errorVars VARS declare .)
    MAIN            reduce using rule 7 (vars -> errorVars VARS declare .)
    FUNC            reduce using rule 7 (vars -> errorVars VARS declare .)
    RETURN          reduce using rule 7 (vars -> errorVars VARS declare .)


state 30

    (52) structDeclare -> errorStructDeclare . STRUCT ID struct ; cyDeclare

    STRUCT          shift and go to state 37


state 31

    (40) function -> errorFunction FUNC ID . opParameters opReturns }
    (44) opParameters -> . ( param ) errorOpParameters
    (45) opParameters -> . empty
    (140) empty -> .

    (               shift and go to state 39
    {               reduce using rule 140 (empty -> .)
    RETURNS         reduce using rule 140 (empty -> .)

    opParameters                   shift and go to state 38
    empty                          shift and go to state 40

state 32

    (15) main -> errorMain MAIN . { opVars body }

    {               shift and go to state 41


state 33

    (1) program -> errorProgram PROGRAM ID { opVars opFunctions main } .

    $end            reduce using rule 1 (program -> errorProgram PROGRAM ID { opVars opFunctions main } .)


state 34

    (54) dictDeclare -> errorDictDeclare DICT . ID dict ; cyDeclare

    ID              shift and go to state 42


state 35

    (50) basicDeclare -> type errorBasicDeclare . ID cyTypeParam ; cyDeclare

    ID              shift and go to state 43


state 36

    (9) type -> errorType INT .

    :               reduce using rule 9 (type -> errorType INT .)
    ID              reduce using rule 9 (type -> errorType INT .)
    [               reduce using rule 9 (type -> errorType INT .)
    )               reduce using rule 9 (type -> errorType INT .)
    {               reduce using rule 9 (type -> errorType INT .)


state 37

    (52) structDeclare -> errorStructDeclare STRUCT . ID struct ; cyDeclare

    ID              shift and go to state 44


state 38

    (40) function -> errorFunction FUNC ID opParameters . opReturns }
    (47) opReturns -> . errorOpReturns RETURNS type { opVars body return
    (48) opReturns -> . { opVars body
    (49) errorOpReturns -> .

    {               shift and go to state 46
    RETURNS         reduce using rule 49 (errorOpReturns -> .)

    errorOpReturns                 shift and go to state 45
    opReturns                      shift and go to state 47

state 39

    (44) opParameters -> ( . param ) errorOpParameters
    (35) param -> . type errorParam ID cyTypeParam cyParam
    (9) type -> . errorType INT
    (10) type -> . FLOAT
    (11) type -> . STRING
    (12) type -> . OBJECT
    (13) type -> . BOOL
    (14) errorType -> .

    FLOAT           shift and go to state 28
    STRING          shift and go to state 24
    OBJECT          shift and go to state 20
    BOOL            shift and go to state 22
    INT             reduce using rule 14 (errorType -> .)

    type                           shift and go to state 49
    errorType                      shift and go to state 25
    param                          shift and go to state 48

state 40

    (45) opParameters -> empty .

    {               reduce using rule 45 (opParameters -> empty .)
    RETURNS         reduce using rule 45 (opParameters -> empty .)


state 41

    (15) main -> errorMain MAIN { . opVars body }
    (3) opVars -> . vars
    (4) opVars -> . empty
    (7) vars -> . errorVars VARS declare
    (140) empty -> .
    (8) errorVars -> .

    }               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    VARS            reduce using rule 8 (errorVars -> .)

    vars                           shift and go to state 6
    opVars                         shift and go to state 50
    errorVars                      shift and go to state 8
    empty                          shift and go to state 9

state 42

    (54) dictDeclare -> errorDictDeclare DICT ID . dict ; cyDeclare
    (93) dict -> . errorDict ( type : type )
    (94) errorDict -> .

    (               reduce using rule 94 (errorDict -> .)

    dict                           shift and go to state 52
    errorDict                      shift and go to state 51

state 43

    (50) basicDeclare -> type errorBasicDeclare ID . cyTypeParam ; cyDeclare
    (56) cyTypeParam -> . , ID
    (57) cyTypeParam -> . empty
    (140) empty -> .

    ,               shift and go to state 53
    ;               reduce using rule 140 (empty -> .)

    cyTypeParam                    shift and go to state 54
    empty                          shift and go to state 55

state 44

    (52) structDeclare -> errorStructDeclare STRUCT ID . struct ; cyDeclare
    (83) struct -> . structType [ CTED ] optionalMatrix
    (84) structType -> . type
    (85) structType -> . DICT dict
    (9) type -> . errorType INT
    (10) type -> . FLOAT
    (11) type -> . STRING
    (12) type -> . OBJECT
    (13) type -> . BOOL
    (14) errorType -> .

    DICT            shift and go to state 58
    FLOAT           shift and go to state 28
    STRING          shift and go to state 24
    OBJECT          shift and go to state 20
    BOOL            shift and go to state 22
    INT             reduce using rule 14 (errorType -> .)

    structType                     shift and go to state 56
    struct                         shift and go to state 57
    errorType                      shift and go to state 25
    type                           shift and go to state 59

state 45

    (47) opReturns -> errorOpReturns . RETURNS type { opVars body return

    RETURNS         shift and go to state 60


state 46

    (48) opReturns -> { . opVars body
    (3) opVars -> . vars
    (4) opVars -> . empty
    (7) vars -> . errorVars VARS declare
    (140) empty -> .
    (8) errorVars -> .

    ID              reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    }               reduce using rule 140 (empty -> .)
    VARS            reduce using rule 8 (errorVars -> .)

    vars                           shift and go to state 6
    opVars                         shift and go to state 61
    errorVars                      shift and go to state 8
    empty                          shift and go to state 9

state 47

    (40) function -> errorFunction FUNC ID opParameters opReturns . }

    }               shift and go to state 62


state 48

    (44) opParameters -> ( param . ) errorOpParameters

    )               shift and go to state 63


state 49

    (35) param -> type . errorParam ID cyTypeParam cyParam
    (36) errorParam -> .

    ID              reduce using rule 36 (errorParam -> .)

    errorParam                     shift and go to state 64

state 50

    (15) main -> errorMain MAIN { opVars . body }
    (60) body -> . errorBody cyInstruction
    (61) body -> . empty
    (62) errorBody -> .
    (140) empty -> .

    ID              reduce using rule 62 (errorBody -> .)
    IF              reduce using rule 62 (errorBody -> .)
    FOR             reduce using rule 62 (errorBody -> .)
    WHILE           reduce using rule 62 (errorBody -> .)
    }               reduce using rule 140 (empty -> .)

    body                           shift and go to state 65
    errorBody                      shift and go to state 66
    empty                          shift and go to state 67

state 51

    (93) dict -> errorDict . ( type : type )

    (               shift and go to state 68


state 52

    (54) dictDeclare -> errorDictDeclare DICT ID dict . ; cyDeclare

    ;               shift and go to state 69


state 53

    (56) cyTypeParam -> , . ID

    ID              shift and go to state 70


state 54

    (50) basicDeclare -> type errorBasicDeclare ID cyTypeParam . ; cyDeclare

    ;               shift and go to state 71


state 55

    (57) cyTypeParam -> empty .

    ;               reduce using rule 57 (cyTypeParam -> empty .)
    )               reduce using rule 57 (cyTypeParam -> empty .)


state 56

    (83) struct -> structType . [ CTED ] optionalMatrix

    [               shift and go to state 72


state 57

    (52) structDeclare -> errorStructDeclare STRUCT ID struct . ; cyDeclare

    ;               shift and go to state 73


state 58

    (85) structType -> DICT . dict
    (93) dict -> . errorDict ( type : type )
    (94) errorDict -> .

    (               reduce using rule 94 (errorDict -> .)

    dict                           shift and go to state 74
    errorDict                      shift and go to state 51

state 59

    (84) structType -> type .

    [               reduce using rule 84 (structType -> type .)


state 60

    (47) opReturns -> errorOpReturns RETURNS . type { opVars body return
    (9) type -> . errorType INT
    (10) type -> . FLOAT
    (11) type -> . STRING
    (12) type -> . OBJECT
    (13) type -> . BOOL
    (14) errorType -> .

    FLOAT           shift and go to state 28
    STRING          shift and go to state 24
    OBJECT          shift and go to state 20
    BOOL            shift and go to state 22
    INT             reduce using rule 14 (errorType -> .)

    errorType                      shift and go to state 25
    type                           shift and go to state 75

state 61

    (48) opReturns -> { opVars . body
    (60) body -> . errorBody cyInstruction
    (61) body -> . empty
    (62) errorBody -> .
    (140) empty -> .

    ID              reduce using rule 62 (errorBody -> .)
    IF              reduce using rule 62 (errorBody -> .)
    FOR             reduce using rule 62 (errorBody -> .)
    WHILE           reduce using rule 62 (errorBody -> .)
    }               reduce using rule 140 (empty -> .)

    body                           shift and go to state 76
    empty                          shift and go to state 67
    errorBody                      shift and go to state 66

state 62

    (40) function -> errorFunction FUNC ID opParameters opReturns } .

    FUNC            reduce using rule 40 (function -> errorFunction FUNC ID opParameters opReturns } .)
    MAIN            reduce using rule 40 (function -> errorFunction FUNC ID opParameters opReturns } .)


state 63

    (44) opParameters -> ( param ) . errorOpParameters
    (46) errorOpParameters -> .

    {               reduce using rule 46 (errorOpParameters -> .)
    RETURNS         reduce using rule 46 (errorOpParameters -> .)

    errorOpParameters              shift and go to state 77

state 64

    (35) param -> type errorParam . ID cyTypeParam cyParam

    ID              shift and go to state 78


state 65

    (15) main -> errorMain MAIN { opVars body . }

    }               shift and go to state 79


state 66

    (60) body -> errorBody . cyInstruction
    (63) cyInstruction -> . instr body
    (17) instr -> . basicStatements ;
    (18) instr -> . condition
    (19) instr -> . cycle
    (20) basicStatements -> . assign
    (21) basicStatements -> . funcCall
    (88) condition -> . errorCondition IF ( expresion ) { body } optionalElse
    (64) cycle -> . forCycle
    (65) cycle -> . whileCycle
    (70) assign -> . ID errorAssign assignOptions
    (78) funcCall -> . ID ( opParamCall )
    (89) errorCondition -> .
    (68) forCycle -> . errorForCycle FOR ( assign ; expresion ; assign ) { body }
    (66) whileCycle -> . errorWhileCycle WHILE ( expresion ) { body }
    (69) errorForCycle -> .
    (67) errorWhileCycle -> .

    ID              shift and go to state 89
    IF              reduce using rule 89 (errorCondition -> .)
    FOR             reduce using rule 69 (errorForCycle -> .)
    WHILE           reduce using rule 67 (errorWhileCycle -> .)

    errorWhileCycle                shift and go to state 83
    funcCall                       shift and go to state 90
    instr                          shift and go to state 80
    forCycle                       shift and go to state 82
    assign                         shift and go to state 92
    whileCycle                     shift and go to state 81
    basicStatements                shift and go to state 87
    errorForCycle                  shift and go to state 88
    errorCondition                 shift and go to state 91
    cyInstruction                  shift and go to state 84
    condition                      shift and go to state 85
    cycle                          shift and go to state 86

state 67

    (61) body -> empty .

    }               reduce using rule 61 (body -> empty .)
    RETURN          reduce using rule 61 (body -> empty .)


state 68

    (93) dict -> errorDict ( . type : type )
    (9) type -> . errorType INT
    (10) type -> . FLOAT
    (11) type -> . STRING
    (12) type -> . OBJECT
    (13) type -> . BOOL
    (14) errorType -> .

    FLOAT           shift and go to state 28
    STRING          shift and go to state 24
    OBJECT          shift and go to state 20
    BOOL            shift and go to state 22
    INT             reduce using rule 14 (errorType -> .)

    errorType                      shift and go to state 25
    type                           shift and go to state 93

state 69

    (54) dictDeclare -> errorDictDeclare DICT ID dict ; . cyDeclare
    (58) cyDeclare -> . declare
    (59) cyDeclare -> . empty
    (22) declare -> . basicDeclare
    (23) declare -> . structDeclare
    (24) declare -> . dictDeclare
    (140) empty -> .
    (50) basicDeclare -> . type errorBasicDeclare ID cyTypeParam ; cyDeclare
    (52) structDeclare -> . errorStructDeclare STRUCT ID struct ; cyDeclare
    (54) dictDeclare -> . errorDictDeclare DICT ID dict ; cyDeclare
    (9) type -> . errorType INT
    (10) type -> . FLOAT
    (11) type -> . STRING
    (12) type -> . OBJECT
    (13) type -> . BOOL
    (53) errorStructDeclare -> .
    (55) errorDictDeclare -> .
    (14) errorType -> .

    MAIN            reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 140 (empty -> .)
    }               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    RETURN          reduce using rule 140 (empty -> .)
    FLOAT           shift and go to state 28
    STRING          shift and go to state 24
    OBJECT          shift and go to state 20
    BOOL            shift and go to state 22
    STRUCT          reduce using rule 53 (errorStructDeclare -> .)
    DICT            reduce using rule 55 (errorDictDeclare -> .)
    INT             reduce using rule 14 (errorType -> .)

    dictDeclare                    shift and go to state 19
    cyDeclare                      shift and go to state 94
    type                           shift and go to state 23
    errorType                      shift and go to state 25
    structDeclare                  shift and go to state 26
    errorDictDeclare               shift and go to state 21
    errorStructDeclare             shift and go to state 30
    basicDeclare                   shift and go to state 27
    declare                        shift and go to state 96
    empty                          shift and go to state 95

state 70

    (56) cyTypeParam -> , ID .

    ;               reduce using rule 56 (cyTypeParam -> , ID .)
    )               reduce using rule 56 (cyTypeParam -> , ID .)


state 71

    (50) basicDeclare -> type errorBasicDeclare ID cyTypeParam ; . cyDeclare
    (58) cyDeclare -> . declare
    (59) cyDeclare -> . empty
    (22) declare -> . basicDeclare
    (23) declare -> . structDeclare
    (24) declare -> . dictDeclare
    (140) empty -> .
    (50) basicDeclare -> . type errorBasicDeclare ID cyTypeParam ; cyDeclare
    (52) structDeclare -> . errorStructDeclare STRUCT ID struct ; cyDeclare
    (54) dictDeclare -> . errorDictDeclare DICT ID dict ; cyDeclare
    (9) type -> . errorType INT
    (10) type -> . FLOAT
    (11) type -> . STRING
    (12) type -> . OBJECT
    (13) type -> . BOOL
    (53) errorStructDeclare -> .
    (55) errorDictDeclare -> .
    (14) errorType -> .

    MAIN            reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 140 (empty -> .)
    }               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    RETURN          reduce using rule 140 (empty -> .)
    FLOAT           shift and go to state 28
    STRING          shift and go to state 24
    OBJECT          shift and go to state 20
    BOOL            shift and go to state 22
    STRUCT          reduce using rule 53 (errorStructDeclare -> .)
    DICT            reduce using rule 55 (errorDictDeclare -> .)
    INT             reduce using rule 14 (errorType -> .)

    dictDeclare                    shift and go to state 19
    cyDeclare                      shift and go to state 97
    basicDeclare                   shift and go to state 27
    errorType                      shift and go to state 25
    errorDictDeclare               shift and go to state 21
    structDeclare                  shift and go to state 26
    errorStructDeclare             shift and go to state 30
    type                           shift and go to state 23
    declare                        shift and go to state 96
    empty                          shift and go to state 95

state 72

    (83) struct -> structType [ . CTED ] optionalMatrix

    CTED            shift and go to state 98


state 73

    (52) structDeclare -> errorStructDeclare STRUCT ID struct ; . cyDeclare
    (58) cyDeclare -> . declare
    (59) cyDeclare -> . empty
    (22) declare -> . basicDeclare
    (23) declare -> . structDeclare
    (24) declare -> . dictDeclare
    (140) empty -> .
    (50) basicDeclare -> . type errorBasicDeclare ID cyTypeParam ; cyDeclare
    (52) structDeclare -> . errorStructDeclare STRUCT ID struct ; cyDeclare
    (54) dictDeclare -> . errorDictDeclare DICT ID dict ; cyDeclare
    (9) type -> . errorType INT
    (10) type -> . FLOAT
    (11) type -> . STRING
    (12) type -> . OBJECT
    (13) type -> . BOOL
    (53) errorStructDeclare -> .
    (55) errorDictDeclare -> .
    (14) errorType -> .

    MAIN            reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 140 (empty -> .)
    }               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    RETURN          reduce using rule 140 (empty -> .)
    FLOAT           shift and go to state 28
    STRING          shift and go to state 24
    OBJECT          shift and go to state 20
    BOOL            shift and go to state 22
    STRUCT          reduce using rule 53 (errorStructDeclare -> .)
    DICT            reduce using rule 55 (errorDictDeclare -> .)
    INT             reduce using rule 14 (errorType -> .)

    dictDeclare                    shift and go to state 19
    cyDeclare                      shift and go to state 99
    type                           shift and go to state 23
    errorType                      shift and go to state 25
    errorDictDeclare               shift and go to state 21
    structDeclare                  shift and go to state 26
    basicDeclare                   shift and go to state 27
    declare                        shift and go to state 96
    empty                          shift and go to state 95
    errorStructDeclare             shift and go to state 30

state 74

    (85) structType -> DICT dict .

    [               reduce using rule 85 (structType -> DICT dict .)


state 75

    (47) opReturns -> errorOpReturns RETURNS type . { opVars body return

    {               shift and go to state 100


state 76

    (48) opReturns -> { opVars body .

    }               reduce using rule 48 (opReturns -> { opVars body .)


state 77

    (44) opParameters -> ( param ) errorOpParameters .

    {               reduce using rule 44 (opParameters -> ( param ) errorOpParameters .)
    RETURNS         reduce using rule 44 (opParameters -> ( param ) errorOpParameters .)


state 78

    (35) param -> type errorParam ID . cyTypeParam cyParam
    (56) cyTypeParam -> . , ID
    (57) cyTypeParam -> . empty
    (140) empty -> .

    ,               shift and go to state 53
    ;               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)

    cyTypeParam                    shift and go to state 101
    empty                          shift and go to state 55

state 79

    (15) main -> errorMain MAIN { opVars body } .

    }               reduce using rule 15 (main -> errorMain MAIN { opVars body } .)


state 80

    (63) cyInstruction -> instr . body
    (60) body -> . errorBody cyInstruction
    (61) body -> . empty
    (62) errorBody -> .
    (140) empty -> .

    ID              reduce using rule 62 (errorBody -> .)
    IF              reduce using rule 62 (errorBody -> .)
    FOR             reduce using rule 62 (errorBody -> .)
    WHILE           reduce using rule 62 (errorBody -> .)
    }               reduce using rule 140 (empty -> .)
    RETURN          reduce using rule 140 (empty -> .)

    body                           shift and go to state 102
    errorBody                      shift and go to state 66
    empty                          shift and go to state 67

state 81

    (65) cycle -> whileCycle .

    ID              reduce using rule 65 (cycle -> whileCycle .)
    IF              reduce using rule 65 (cycle -> whileCycle .)
    FOR             reduce using rule 65 (cycle -> whileCycle .)
    WHILE           reduce using rule 65 (cycle -> whileCycle .)
    }               reduce using rule 65 (cycle -> whileCycle .)
    RETURN          reduce using rule 65 (cycle -> whileCycle .)


state 82

    (64) cycle -> forCycle .

    ID              reduce using rule 64 (cycle -> forCycle .)
    IF              reduce using rule 64 (cycle -> forCycle .)
    FOR             reduce using rule 64 (cycle -> forCycle .)
    WHILE           reduce using rule 64 (cycle -> forCycle .)
    }               reduce using rule 64 (cycle -> forCycle .)
    RETURN          reduce using rule 64 (cycle -> forCycle .)


state 83

    (66) whileCycle -> errorWhileCycle . WHILE ( expresion ) { body }

    WHILE           shift and go to state 103


state 84

    (60) body -> errorBody cyInstruction .

    }               reduce using rule 60 (body -> errorBody cyInstruction .)
    RETURN          reduce using rule 60 (body -> errorBody cyInstruction .)


state 85

    (18) instr -> condition .

    ID              reduce using rule 18 (instr -> condition .)
    IF              reduce using rule 18 (instr -> condition .)
    FOR             reduce using rule 18 (instr -> condition .)
    WHILE           reduce using rule 18 (instr -> condition .)
    }               reduce using rule 18 (instr -> condition .)
    RETURN          reduce using rule 18 (instr -> condition .)


state 86

    (19) instr -> cycle .

    ID              reduce using rule 19 (instr -> cycle .)
    IF              reduce using rule 19 (instr -> cycle .)
    FOR             reduce using rule 19 (instr -> cycle .)
    WHILE           reduce using rule 19 (instr -> cycle .)
    }               reduce using rule 19 (instr -> cycle .)
    RETURN          reduce using rule 19 (instr -> cycle .)


state 87

    (17) instr -> basicStatements . ;

    ;               shift and go to state 104


state 88

    (68) forCycle -> errorForCycle . FOR ( assign ; expresion ; assign ) { body }

    FOR             shift and go to state 105


state 89

    (70) assign -> ID . errorAssign assignOptions
    (78) funcCall -> ID . ( opParamCall )
    (71) errorAssign -> .

    (               shift and go to state 106
    [               reduce using rule 71 (errorAssign -> .)
    =               reduce using rule 71 (errorAssign -> .)

    errorAssign                    shift and go to state 107

state 90

    (21) basicStatements -> funcCall .

    ;               reduce using rule 21 (basicStatements -> funcCall .)


state 91

    (88) condition -> errorCondition . IF ( expresion ) { body } optionalElse

    IF              shift and go to state 108


state 92

    (20) basicStatements -> assign .

    ;               reduce using rule 20 (basicStatements -> assign .)


state 93

    (93) dict -> errorDict ( type . : type )

    :               shift and go to state 109


state 94

    (54) dictDeclare -> errorDictDeclare DICT ID dict ; cyDeclare .

    MAIN            reduce using rule 54 (dictDeclare -> errorDictDeclare DICT ID dict ; cyDeclare .)
    FUNC            reduce using rule 54 (dictDeclare -> errorDictDeclare DICT ID dict ; cyDeclare .)
    }               reduce using rule 54 (dictDeclare -> errorDictDeclare DICT ID dict ; cyDeclare .)
    ID              reduce using rule 54 (dictDeclare -> errorDictDeclare DICT ID dict ; cyDeclare .)
    IF              reduce using rule 54 (dictDeclare -> errorDictDeclare DICT ID dict ; cyDeclare .)
    FOR             reduce using rule 54 (dictDeclare -> errorDictDeclare DICT ID dict ; cyDeclare .)
    WHILE           reduce using rule 54 (dictDeclare -> errorDictDeclare DICT ID dict ; cyDeclare .)
    RETURN          reduce using rule 54 (dictDeclare -> errorDictDeclare DICT ID dict ; cyDeclare .)


state 95

    (59) cyDeclare -> empty .

    MAIN            reduce using rule 59 (cyDeclare -> empty .)
    FUNC            reduce using rule 59 (cyDeclare -> empty .)
    }               reduce using rule 59 (cyDeclare -> empty .)
    ID              reduce using rule 59 (cyDeclare -> empty .)
    IF              reduce using rule 59 (cyDeclare -> empty .)
    FOR             reduce using rule 59 (cyDeclare -> empty .)
    WHILE           reduce using rule 59 (cyDeclare -> empty .)
    RETURN          reduce using rule 59 (cyDeclare -> empty .)


state 96

    (58) cyDeclare -> declare .

    MAIN            reduce using rule 58 (cyDeclare -> declare .)
    FUNC            reduce using rule 58 (cyDeclare -> declare .)
    }               reduce using rule 58 (cyDeclare -> declare .)
    ID              reduce using rule 58 (cyDeclare -> declare .)
    IF              reduce using rule 58 (cyDeclare -> declare .)
    FOR             reduce using rule 58 (cyDeclare -> declare .)
    WHILE           reduce using rule 58 (cyDeclare -> declare .)
    RETURN          reduce using rule 58 (cyDeclare -> declare .)


state 97

    (50) basicDeclare -> type errorBasicDeclare ID cyTypeParam ; cyDeclare .

    MAIN            reduce using rule 50 (basicDeclare -> type errorBasicDeclare ID cyTypeParam ; cyDeclare .)
    FUNC            reduce using rule 50 (basicDeclare -> type errorBasicDeclare ID cyTypeParam ; cyDeclare .)
    }               reduce using rule 50 (basicDeclare -> type errorBasicDeclare ID cyTypeParam ; cyDeclare .)
    ID              reduce using rule 50 (basicDeclare -> type errorBasicDeclare ID cyTypeParam ; cyDeclare .)
    IF              reduce using rule 50 (basicDeclare -> type errorBasicDeclare ID cyTypeParam ; cyDeclare .)
    FOR             reduce using rule 50 (basicDeclare -> type errorBasicDeclare ID cyTypeParam ; cyDeclare .)
    WHILE           reduce using rule 50 (basicDeclare -> type errorBasicDeclare ID cyTypeParam ; cyDeclare .)
    RETURN          reduce using rule 50 (basicDeclare -> type errorBasicDeclare ID cyTypeParam ; cyDeclare .)


state 98

    (83) struct -> structType [ CTED . ] optionalMatrix

    ]               shift and go to state 110


state 99

    (52) structDeclare -> errorStructDeclare STRUCT ID struct ; cyDeclare .

    MAIN            reduce using rule 52 (structDeclare -> errorStructDeclare STRUCT ID struct ; cyDeclare .)
    FUNC            reduce using rule 52 (structDeclare -> errorStructDeclare STRUCT ID struct ; cyDeclare .)
    }               reduce using rule 52 (structDeclare -> errorStructDeclare STRUCT ID struct ; cyDeclare .)
    ID              reduce using rule 52 (structDeclare -> errorStructDeclare STRUCT ID struct ; cyDeclare .)
    IF              reduce using rule 52 (structDeclare -> errorStructDeclare STRUCT ID struct ; cyDeclare .)
    FOR             reduce using rule 52 (structDeclare -> errorStructDeclare STRUCT ID struct ; cyDeclare .)
    WHILE           reduce using rule 52 (structDeclare -> errorStructDeclare STRUCT ID struct ; cyDeclare .)
    RETURN          reduce using rule 52 (structDeclare -> errorStructDeclare STRUCT ID struct ; cyDeclare .)


state 100

    (47) opReturns -> errorOpReturns RETURNS type { . opVars body return
    (3) opVars -> . vars
    (4) opVars -> . empty
    (7) vars -> . errorVars VARS declare
    (140) empty -> .
    (8) errorVars -> .

    RETURN          reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    VARS            reduce using rule 8 (errorVars -> .)

    vars                           shift and go to state 6
    opVars                         shift and go to state 111
    errorVars                      shift and go to state 8
    empty                          shift and go to state 9

state 101

    (35) param -> type errorParam ID cyTypeParam . cyParam
    (37) cyParam -> . errorCyParam ; param
    (38) cyParam -> . empty
    (39) errorCyParam -> .
    (140) empty -> .

    ;               reduce using rule 39 (errorCyParam -> .)
    )               reduce using rule 140 (empty -> .)

    cyParam                        shift and go to state 113
    errorCyParam                   shift and go to state 112
    empty                          shift and go to state 114

state 102

    (63) cyInstruction -> instr body .

    }               reduce using rule 63 (cyInstruction -> instr body .)
    RETURN          reduce using rule 63 (cyInstruction -> instr body .)


state 103

    (66) whileCycle -> errorWhileCycle WHILE . ( expresion ) { body }

    (               shift and go to state 115


state 104

    (17) instr -> basicStatements ; .

    ID              reduce using rule 17 (instr -> basicStatements ; .)
    IF              reduce using rule 17 (instr -> basicStatements ; .)
    FOR             reduce using rule 17 (instr -> basicStatements ; .)
    WHILE           reduce using rule 17 (instr -> basicStatements ; .)
    }               reduce using rule 17 (instr -> basicStatements ; .)
    RETURN          reduce using rule 17 (instr -> basicStatements ; .)


state 105

    (68) forCycle -> errorForCycle FOR . ( assign ; expresion ; assign ) { body }

    (               shift and go to state 116


state 106

    (78) funcCall -> ID ( . opParamCall )
    (79) opParamCall -> . expresion cyParamCall
    (80) opParamCall -> . empty
    (95) expresion -> . sExp cyExpresion errorExpresion
    (140) empty -> .
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    )               reduce using rule 140 (empty -> .)
    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 124
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    fact                           shift and go to state 132
    exp                            shift and go to state 131
    opParamCall                    shift and go to state 117
    empty                          shift and go to state 121

state 107

    (70) assign -> ID errorAssign . assignOptions
    (72) assignOptions -> . init
    (73) assignOptions -> . initDict
    (74) assignOptions -> . [ expresion ] assignMatrix init
    (25) init -> . = initWith errorInit
    (29) initDict -> . = ( dictType : dictType ) errorInitDict

    [               shift and go to state 137
    =               shift and go to state 133

    initDict                       shift and go to state 134
    assignOptions                  shift and go to state 135
    init                           shift and go to state 136

state 108

    (88) condition -> errorCondition IF . ( expresion ) { body } optionalElse

    (               shift and go to state 138


state 109

    (93) dict -> errorDict ( type : . type )
    (9) type -> . errorType INT
    (10) type -> . FLOAT
    (11) type -> . STRING
    (12) type -> . OBJECT
    (13) type -> . BOOL
    (14) errorType -> .

    FLOAT           shift and go to state 28
    STRING          shift and go to state 24
    OBJECT          shift and go to state 20
    BOOL            shift and go to state 22
    INT             reduce using rule 14 (errorType -> .)

    errorType                      shift and go to state 25
    type                           shift and go to state 139

state 110

    (83) struct -> structType [ CTED ] . optionalMatrix
    (86) optionalMatrix -> . [ CTED ]
    (87) optionalMatrix -> . empty
    (140) empty -> .

    [               shift and go to state 141
    ;               reduce using rule 140 (empty -> .)

    empty                          shift and go to state 142
    optionalMatrix                 shift and go to state 140

state 111

    (47) opReturns -> errorOpReturns RETURNS type { opVars . body return
    (60) body -> . errorBody cyInstruction
    (61) body -> . empty
    (62) errorBody -> .
    (140) empty -> .

    ID              reduce using rule 62 (errorBody -> .)
    IF              reduce using rule 62 (errorBody -> .)
    FOR             reduce using rule 62 (errorBody -> .)
    WHILE           reduce using rule 62 (errorBody -> .)
    RETURN          reduce using rule 140 (empty -> .)

    body                           shift and go to state 143
    errorBody                      shift and go to state 66
    empty                          shift and go to state 67

state 112

    (37) cyParam -> errorCyParam . ; param

    ;               shift and go to state 144


state 113

    (35) param -> type errorParam ID cyTypeParam cyParam .

    )               reduce using rule 35 (param -> type errorParam ID cyTypeParam cyParam .)


state 114

    (38) cyParam -> empty .

    )               reduce using rule 38 (cyParam -> empty .)


state 115

    (66) whileCycle -> errorWhileCycle WHILE ( . expresion ) { body }
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 145
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 116

    (68) forCycle -> errorForCycle FOR ( . assign ; expresion ; assign ) { body }
    (70) assign -> . ID errorAssign assignOptions

    ID              shift and go to state 146

    assign                         shift and go to state 147

state 117

    (78) funcCall -> ID ( opParamCall . )

    )               shift and go to state 148


state 118

    (138) cte -> TRUE .

    *               reduce using rule 138 (cte -> TRUE .)
    /               reduce using rule 138 (cte -> TRUE .)
    +               reduce using rule 138 (cte -> TRUE .)
    -               reduce using rule 138 (cte -> TRUE .)
    AND             reduce using rule 138 (cte -> TRUE .)
    OR              reduce using rule 138 (cte -> TRUE .)
    ,               reduce using rule 138 (cte -> TRUE .)
    )               reduce using rule 138 (cte -> TRUE .)
    ;               reduce using rule 138 (cte -> TRUE .)
    ]               reduce using rule 138 (cte -> TRUE .)
    EQ              reduce using rule 138 (cte -> TRUE .)
    DIF             reduce using rule 138 (cte -> TRUE .)
    LTOEQ           reduce using rule 138 (cte -> TRUE .)
    GTOEQ           reduce using rule 138 (cte -> TRUE .)
    >               reduce using rule 138 (cte -> TRUE .)
    <               reduce using rule 138 (cte -> TRUE .)
    :               reduce using rule 138 (cte -> TRUE .)


state 119

    (121) fact -> ( . expresion )
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 149
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 120

    (95) expresion -> sExp . cyExpresion errorExpresion
    (97) cyExpresion -> . AND expresion
    (98) cyExpresion -> . OR expresion
    (99) cyExpresion -> . empty
    (140) empty -> .

    AND             shift and go to state 150
    OR              shift and go to state 152
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)

    cyExpresion                    shift and go to state 151
    empty                          shift and go to state 153

state 121

    (80) opParamCall -> empty .

    )               reduce using rule 80 (opParamCall -> empty .)


state 122

    (136) cte -> CTED .

    *               reduce using rule 136 (cte -> CTED .)
    /               reduce using rule 136 (cte -> CTED .)
    +               reduce using rule 136 (cte -> CTED .)
    -               reduce using rule 136 (cte -> CTED .)
    AND             reduce using rule 136 (cte -> CTED .)
    OR              reduce using rule 136 (cte -> CTED .)
    ,               reduce using rule 136 (cte -> CTED .)
    )               reduce using rule 136 (cte -> CTED .)
    ;               reduce using rule 136 (cte -> CTED .)
    ]               reduce using rule 136 (cte -> CTED .)
    EQ              reduce using rule 136 (cte -> CTED .)
    DIF             reduce using rule 136 (cte -> CTED .)
    LTOEQ           reduce using rule 136 (cte -> CTED .)
    GTOEQ           reduce using rule 136 (cte -> CTED .)
    >               reduce using rule 136 (cte -> CTED .)
    <               reduce using rule 136 (cte -> CTED .)
    :               reduce using rule 136 (cte -> CTED .)


state 123

    (122) fact -> ID . opAccess errorOpAccess
    (78) funcCall -> ID . ( opParamCall )
    (124) opAccess -> . opStruct
    (125) opAccess -> . opDictionary
    (126) opAccess -> . empty
    (128) opStruct -> . errorOpStruct [ expresion ] opMatrix
    (133) opDictionary -> . . dictIndex
    (140) empty -> .
    (129) errorOpStruct -> .

    (               shift and go to state 106
    .               shift and go to state 158
    *               reduce using rule 140 (empty -> .)
    /               reduce using rule 140 (empty -> .)
    +               reduce using rule 140 (empty -> .)
    -               reduce using rule 140 (empty -> .)
    EQ              reduce using rule 140 (empty -> .)
    DIF             reduce using rule 140 (empty -> .)
    LTOEQ           reduce using rule 140 (empty -> .)
    GTOEQ           reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    <               reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    [               reduce using rule 129 (errorOpStruct -> .)

    errorOpStruct                  shift and go to state 154
    opDictionary                   shift and go to state 159
    opStruct                       shift and go to state 155
    opAccess                       shift and go to state 156
    empty                          shift and go to state 157

state 124

    (79) opParamCall -> expresion . cyParamCall
    (81) cyParamCall -> . , expresion cyParamCall
    (82) cyParamCall -> . empty
    (140) empty -> .

    ,               shift and go to state 161
    )               reduce using rule 140 (empty -> .)

    cyParamCall                    shift and go to state 160
    empty                          shift and go to state 162

state 125

    (118) fact -> CTES .

    *               reduce using rule 118 (fact -> CTES .)
    /               reduce using rule 118 (fact -> CTES .)
    +               reduce using rule 118 (fact -> CTES .)
    -               reduce using rule 118 (fact -> CTES .)
    AND             reduce using rule 118 (fact -> CTES .)
    OR              reduce using rule 118 (fact -> CTES .)
    ,               reduce using rule 118 (fact -> CTES .)
    )               reduce using rule 118 (fact -> CTES .)
    ;               reduce using rule 118 (fact -> CTES .)
    ]               reduce using rule 118 (fact -> CTES .)
    EQ              reduce using rule 118 (fact -> CTES .)
    DIF             reduce using rule 118 (fact -> CTES .)
    LTOEQ           reduce using rule 118 (fact -> CTES .)
    GTOEQ           reduce using rule 118 (fact -> CTES .)
    >               reduce using rule 118 (fact -> CTES .)
    <               reduce using rule 118 (fact -> CTES .)


state 126

    (109) exp -> term . errorCyExp cyExp
    (113) errorCyExp -> .

    +               reduce using rule 113 (errorCyExp -> .)
    -               reduce using rule 113 (errorCyExp -> .)
    EQ              reduce using rule 113 (errorCyExp -> .)
    DIF             reduce using rule 113 (errorCyExp -> .)
    LTOEQ           reduce using rule 113 (errorCyExp -> .)
    GTOEQ           reduce using rule 113 (errorCyExp -> .)
    >               reduce using rule 113 (errorCyExp -> .)
    <               reduce using rule 113 (errorCyExp -> .)
    AND             reduce using rule 113 (errorCyExp -> .)
    OR              reduce using rule 113 (errorCyExp -> .)
    ,               reduce using rule 113 (errorCyExp -> .)
    )               reduce using rule 113 (errorCyExp -> .)
    ;               reduce using rule 113 (errorCyExp -> .)
    ]               reduce using rule 113 (errorCyExp -> .)

    errorCyExp                     shift and go to state 163

state 127

    (139) cte -> FALSE .

    *               reduce using rule 139 (cte -> FALSE .)
    /               reduce using rule 139 (cte -> FALSE .)
    +               reduce using rule 139 (cte -> FALSE .)
    -               reduce using rule 139 (cte -> FALSE .)
    AND             reduce using rule 139 (cte -> FALSE .)
    OR              reduce using rule 139 (cte -> FALSE .)
    ,               reduce using rule 139 (cte -> FALSE .)
    )               reduce using rule 139 (cte -> FALSE .)
    ;               reduce using rule 139 (cte -> FALSE .)
    ]               reduce using rule 139 (cte -> FALSE .)
    EQ              reduce using rule 139 (cte -> FALSE .)
    DIF             reduce using rule 139 (cte -> FALSE .)
    LTOEQ           reduce using rule 139 (cte -> FALSE .)
    GTOEQ           reduce using rule 139 (cte -> FALSE .)
    >               reduce using rule 139 (cte -> FALSE .)
    <               reduce using rule 139 (cte -> FALSE .)
    :               reduce using rule 139 (cte -> FALSE .)


state 128

    (120) fact -> funcCall .

    *               reduce using rule 120 (fact -> funcCall .)
    /               reduce using rule 120 (fact -> funcCall .)
    +               reduce using rule 120 (fact -> funcCall .)
    -               reduce using rule 120 (fact -> funcCall .)
    AND             reduce using rule 120 (fact -> funcCall .)
    OR              reduce using rule 120 (fact -> funcCall .)
    ,               reduce using rule 120 (fact -> funcCall .)
    )               reduce using rule 120 (fact -> funcCall .)
    ;               reduce using rule 120 (fact -> funcCall .)
    ]               reduce using rule 120 (fact -> funcCall .)
    EQ              reduce using rule 120 (fact -> funcCall .)
    DIF             reduce using rule 120 (fact -> funcCall .)
    LTOEQ           reduce using rule 120 (fact -> funcCall .)
    GTOEQ           reduce using rule 120 (fact -> funcCall .)
    >               reduce using rule 120 (fact -> funcCall .)
    <               reduce using rule 120 (fact -> funcCall .)


state 129

    (119) fact -> cte .

    *               reduce using rule 119 (fact -> cte .)
    /               reduce using rule 119 (fact -> cte .)
    +               reduce using rule 119 (fact -> cte .)
    -               reduce using rule 119 (fact -> cte .)
    AND             reduce using rule 119 (fact -> cte .)
    OR              reduce using rule 119 (fact -> cte .)
    ,               reduce using rule 119 (fact -> cte .)
    )               reduce using rule 119 (fact -> cte .)
    ;               reduce using rule 119 (fact -> cte .)
    ]               reduce using rule 119 (fact -> cte .)
    EQ              reduce using rule 119 (fact -> cte .)
    DIF             reduce using rule 119 (fact -> cte .)
    LTOEQ           reduce using rule 119 (fact -> cte .)
    GTOEQ           reduce using rule 119 (fact -> cte .)
    >               reduce using rule 119 (fact -> cte .)
    <               reduce using rule 119 (fact -> cte .)


state 130

    (137) cte -> CTEF .

    *               reduce using rule 137 (cte -> CTEF .)
    /               reduce using rule 137 (cte -> CTEF .)
    +               reduce using rule 137 (cte -> CTEF .)
    -               reduce using rule 137 (cte -> CTEF .)
    AND             reduce using rule 137 (cte -> CTEF .)
    OR              reduce using rule 137 (cte -> CTEF .)
    ,               reduce using rule 137 (cte -> CTEF .)
    )               reduce using rule 137 (cte -> CTEF .)
    ;               reduce using rule 137 (cte -> CTEF .)
    ]               reduce using rule 137 (cte -> CTEF .)
    EQ              reduce using rule 137 (cte -> CTEF .)
    DIF             reduce using rule 137 (cte -> CTEF .)
    LTOEQ           reduce using rule 137 (cte -> CTEF .)
    GTOEQ           reduce using rule 137 (cte -> CTEF .)
    >               reduce using rule 137 (cte -> CTEF .)
    <               reduce using rule 137 (cte -> CTEF .)
    :               reduce using rule 137 (cte -> CTEF .)


state 131

    (100) sExp -> exp . errorOpSExp opSExp
    (108) errorOpSExp -> .

    EQ              reduce using rule 108 (errorOpSExp -> .)
    DIF             reduce using rule 108 (errorOpSExp -> .)
    LTOEQ           reduce using rule 108 (errorOpSExp -> .)
    GTOEQ           reduce using rule 108 (errorOpSExp -> .)
    >               reduce using rule 108 (errorOpSExp -> .)
    <               reduce using rule 108 (errorOpSExp -> .)
    AND             reduce using rule 108 (errorOpSExp -> .)
    OR              reduce using rule 108 (errorOpSExp -> .)
    ,               reduce using rule 108 (errorOpSExp -> .)
    )               reduce using rule 108 (errorOpSExp -> .)
    ;               reduce using rule 108 (errorOpSExp -> .)
    ]               reduce using rule 108 (errorOpSExp -> .)

    errorOpSExp                    shift and go to state 164

state 132

    (114) term -> fact . cyTerm
    (115) cyTerm -> . * errorFact fact
    (116) cyTerm -> . / fact
    (117) cyTerm -> . empty
    (140) empty -> .

    *               shift and go to state 165
    /               shift and go to state 166
    +               reduce using rule 140 (empty -> .)
    -               reduce using rule 140 (empty -> .)
    EQ              reduce using rule 140 (empty -> .)
    DIF             reduce using rule 140 (empty -> .)
    LTOEQ           reduce using rule 140 (empty -> .)
    GTOEQ           reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    <               reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)

    cyTerm                         shift and go to state 167
    empty                          shift and go to state 168

state 133

    (25) init -> = . initWith errorInit
    (29) initDict -> = . ( dictType : dictType ) errorInitDict
    (27) initWith -> . expresion
    (28) initWith -> . funcCall
    (95) expresion -> . sExp cyExpresion errorExpresion
    (78) funcCall -> . ID ( opParamCall )
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE

    (               shift and go to state 170
    ID              shift and go to state 171
    CTES            shift and go to state 125
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 172
    initWith                       shift and go to state 169
    funcCall                       shift and go to state 173
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    term                           shift and go to state 126
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 134

    (73) assignOptions -> initDict .

    ;               reduce using rule 73 (assignOptions -> initDict .)
    )               reduce using rule 73 (assignOptions -> initDict .)


state 135

    (70) assign -> ID errorAssign assignOptions .

    ;               reduce using rule 70 (assign -> ID errorAssign assignOptions .)
    )               reduce using rule 70 (assign -> ID errorAssign assignOptions .)


state 136

    (72) assignOptions -> init .

    ;               reduce using rule 72 (assignOptions -> init .)
    )               reduce using rule 72 (assignOptions -> init .)


state 137

    (74) assignOptions -> [ . expresion ] assignMatrix init
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 174
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 138

    (88) condition -> errorCondition IF ( . expresion ) { body } optionalElse
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 175
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 139

    (93) dict -> errorDict ( type : type . )

    )               shift and go to state 176


state 140

    (83) struct -> structType [ CTED ] optionalMatrix .

    ;               reduce using rule 83 (struct -> structType [ CTED ] optionalMatrix .)


state 141

    (86) optionalMatrix -> [ . CTED ]

    CTED            shift and go to state 177


state 142

    (87) optionalMatrix -> empty .

    ;               reduce using rule 87 (optionalMatrix -> empty .)


state 143

    (47) opReturns -> errorOpReturns RETURNS type { opVars body . return
    (42) return -> . errorReturn RETURN expresion ;
    (43) errorReturn -> .

    RETURN          reduce using rule 43 (errorReturn -> .)

    return                         shift and go to state 178
    errorReturn                    shift and go to state 179

state 144

    (37) cyParam -> errorCyParam ; . param
    (35) param -> . type errorParam ID cyTypeParam cyParam
    (9) type -> . errorType INT
    (10) type -> . FLOAT
    (11) type -> . STRING
    (12) type -> . OBJECT
    (13) type -> . BOOL
    (14) errorType -> .

    FLOAT           shift and go to state 28
    STRING          shift and go to state 24
    OBJECT          shift and go to state 20
    BOOL            shift and go to state 22
    INT             reduce using rule 14 (errorType -> .)

    type                           shift and go to state 49
    errorType                      shift and go to state 25
    param                          shift and go to state 180

state 145

    (66) whileCycle -> errorWhileCycle WHILE ( expresion . ) { body }

    )               shift and go to state 181


state 146

    (70) assign -> ID . errorAssign assignOptions
    (71) errorAssign -> .

    [               reduce using rule 71 (errorAssign -> .)
    =               reduce using rule 71 (errorAssign -> .)

    errorAssign                    shift and go to state 107

state 147

    (68) forCycle -> errorForCycle FOR ( assign . ; expresion ; assign ) { body }

    ;               shift and go to state 182


state 148

    (78) funcCall -> ID ( opParamCall ) .

    +               reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    -               reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    EQ              reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    DIF             reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    LTOEQ           reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    GTOEQ           reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    >               reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    <               reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    AND             reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    OR              reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    ,               reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    )               reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    ;               reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    ]               reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    *               reduce using rule 78 (funcCall -> ID ( opParamCall ) .)
    /               reduce using rule 78 (funcCall -> ID ( opParamCall ) .)


state 149

    (121) fact -> ( expresion . )

    )               shift and go to state 183


state 150

    (97) cyExpresion -> AND . expresion
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 184
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 151

    (95) expresion -> sExp cyExpresion . errorExpresion
    (96) errorExpresion -> .

    ,               reduce using rule 96 (errorExpresion -> .)
    )               reduce using rule 96 (errorExpresion -> .)
    ;               reduce using rule 96 (errorExpresion -> .)
    ]               reduce using rule 96 (errorExpresion -> .)

    errorExpresion                 shift and go to state 185

state 152

    (98) cyExpresion -> OR . expresion
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 186
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 153

    (99) cyExpresion -> empty .

    ,               reduce using rule 99 (cyExpresion -> empty .)
    )               reduce using rule 99 (cyExpresion -> empty .)
    ;               reduce using rule 99 (cyExpresion -> empty .)
    ]               reduce using rule 99 (cyExpresion -> empty .)


state 154

    (128) opStruct -> errorOpStruct . [ expresion ] opMatrix

    [               shift and go to state 187


state 155

    (124) opAccess -> opStruct .

    *               reduce using rule 124 (opAccess -> opStruct .)
    /               reduce using rule 124 (opAccess -> opStruct .)
    +               reduce using rule 124 (opAccess -> opStruct .)
    -               reduce using rule 124 (opAccess -> opStruct .)
    EQ              reduce using rule 124 (opAccess -> opStruct .)
    DIF             reduce using rule 124 (opAccess -> opStruct .)
    LTOEQ           reduce using rule 124 (opAccess -> opStruct .)
    GTOEQ           reduce using rule 124 (opAccess -> opStruct .)
    >               reduce using rule 124 (opAccess -> opStruct .)
    <               reduce using rule 124 (opAccess -> opStruct .)
    AND             reduce using rule 124 (opAccess -> opStruct .)
    OR              reduce using rule 124 (opAccess -> opStruct .)
    ;               reduce using rule 124 (opAccess -> opStruct .)
    )               reduce using rule 124 (opAccess -> opStruct .)
    ,               reduce using rule 124 (opAccess -> opStruct .)
    ]               reduce using rule 124 (opAccess -> opStruct .)


state 156

    (122) fact -> ID opAccess . errorOpAccess
    (127) errorOpAccess -> .

    *               reduce using rule 127 (errorOpAccess -> .)
    /               reduce using rule 127 (errorOpAccess -> .)
    +               reduce using rule 127 (errorOpAccess -> .)
    -               reduce using rule 127 (errorOpAccess -> .)
    EQ              reduce using rule 127 (errorOpAccess -> .)
    DIF             reduce using rule 127 (errorOpAccess -> .)
    LTOEQ           reduce using rule 127 (errorOpAccess -> .)
    GTOEQ           reduce using rule 127 (errorOpAccess -> .)
    >               reduce using rule 127 (errorOpAccess -> .)
    <               reduce using rule 127 (errorOpAccess -> .)
    AND             reduce using rule 127 (errorOpAccess -> .)
    OR              reduce using rule 127 (errorOpAccess -> .)
    ,               reduce using rule 127 (errorOpAccess -> .)
    )               reduce using rule 127 (errorOpAccess -> .)
    ;               reduce using rule 127 (errorOpAccess -> .)
    ]               reduce using rule 127 (errorOpAccess -> .)

    errorOpAccess                  shift and go to state 188

state 157

    (126) opAccess -> empty .

    *               reduce using rule 126 (opAccess -> empty .)
    /               reduce using rule 126 (opAccess -> empty .)
    +               reduce using rule 126 (opAccess -> empty .)
    -               reduce using rule 126 (opAccess -> empty .)
    EQ              reduce using rule 126 (opAccess -> empty .)
    DIF             reduce using rule 126 (opAccess -> empty .)
    LTOEQ           reduce using rule 126 (opAccess -> empty .)
    GTOEQ           reduce using rule 126 (opAccess -> empty .)
    >               reduce using rule 126 (opAccess -> empty .)
    <               reduce using rule 126 (opAccess -> empty .)
    AND             reduce using rule 126 (opAccess -> empty .)
    OR              reduce using rule 126 (opAccess -> empty .)
    ;               reduce using rule 126 (opAccess -> empty .)
    )               reduce using rule 126 (opAccess -> empty .)
    ,               reduce using rule 126 (opAccess -> empty .)
    ]               reduce using rule 126 (opAccess -> empty .)


state 158

    (133) opDictionary -> . . dictIndex
    (134) dictIndex -> . FIRST
    (135) dictIndex -> . LAST

    FIRST           shift and go to state 189
    LAST            shift and go to state 190

    dictIndex                      shift and go to state 191

state 159

    (125) opAccess -> opDictionary .

    *               reduce using rule 125 (opAccess -> opDictionary .)
    /               reduce using rule 125 (opAccess -> opDictionary .)
    +               reduce using rule 125 (opAccess -> opDictionary .)
    -               reduce using rule 125 (opAccess -> opDictionary .)
    EQ              reduce using rule 125 (opAccess -> opDictionary .)
    DIF             reduce using rule 125 (opAccess -> opDictionary .)
    LTOEQ           reduce using rule 125 (opAccess -> opDictionary .)
    GTOEQ           reduce using rule 125 (opAccess -> opDictionary .)
    >               reduce using rule 125 (opAccess -> opDictionary .)
    <               reduce using rule 125 (opAccess -> opDictionary .)
    AND             reduce using rule 125 (opAccess -> opDictionary .)
    OR              reduce using rule 125 (opAccess -> opDictionary .)
    ;               reduce using rule 125 (opAccess -> opDictionary .)
    )               reduce using rule 125 (opAccess -> opDictionary .)
    ,               reduce using rule 125 (opAccess -> opDictionary .)
    ]               reduce using rule 125 (opAccess -> opDictionary .)


state 160

    (79) opParamCall -> expresion cyParamCall .

    )               reduce using rule 79 (opParamCall -> expresion cyParamCall .)


state 161

    (81) cyParamCall -> , . expresion cyParamCall
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 192
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 162

    (82) cyParamCall -> empty .

    )               reduce using rule 82 (cyParamCall -> empty .)


state 163

    (109) exp -> term errorCyExp . cyExp
    (110) cyExp -> . + term
    (111) cyExp -> . - term
    (112) cyExp -> . empty
    (140) empty -> .

    +               shift and go to state 194
    -               shift and go to state 195
    EQ              reduce using rule 140 (empty -> .)
    DIF             reduce using rule 140 (empty -> .)
    LTOEQ           reduce using rule 140 (empty -> .)
    GTOEQ           reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    <               reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)

    cyExp                          shift and go to state 193
    empty                          shift and go to state 196

state 164

    (100) sExp -> exp errorOpSExp . opSExp
    (101) opSExp -> . EQ exp
    (102) opSExp -> . DIF exp
    (103) opSExp -> . LTOEQ exp
    (104) opSExp -> . GTOEQ exp
    (105) opSExp -> . > exp
    (106) opSExp -> . < exp
    (107) opSExp -> . empty
    (140) empty -> .

    EQ              shift and go to state 197
    DIF             shift and go to state 198
    LTOEQ           shift and go to state 201
    GTOEQ           shift and go to state 199
    >               shift and go to state 200
    <               shift and go to state 202
    AND             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)

    empty                          shift and go to state 203
    opSExp                         shift and go to state 204

state 165

    (115) cyTerm -> * . errorFact fact
    (123) errorFact -> .

    CTES            reduce using rule 123 (errorFact -> .)
    (               reduce using rule 123 (errorFact -> .)
    ID              reduce using rule 123 (errorFact -> .)
    CTED            reduce using rule 123 (errorFact -> .)
    CTEF            reduce using rule 123 (errorFact -> .)
    TRUE            reduce using rule 123 (errorFact -> .)
    FALSE           reduce using rule 123 (errorFact -> .)

    errorFact                      shift and go to state 205

state 166

    (116) cyTerm -> / . fact
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    funcCall                       shift and go to state 128
    cte                            shift and go to state 129
    fact                           shift and go to state 206

state 167

    (114) term -> fact cyTerm .

    +               reduce using rule 114 (term -> fact cyTerm .)
    -               reduce using rule 114 (term -> fact cyTerm .)
    AND             reduce using rule 114 (term -> fact cyTerm .)
    OR              reduce using rule 114 (term -> fact cyTerm .)
    ,               reduce using rule 114 (term -> fact cyTerm .)
    )               reduce using rule 114 (term -> fact cyTerm .)
    ;               reduce using rule 114 (term -> fact cyTerm .)
    ]               reduce using rule 114 (term -> fact cyTerm .)
    EQ              reduce using rule 114 (term -> fact cyTerm .)
    DIF             reduce using rule 114 (term -> fact cyTerm .)
    LTOEQ           reduce using rule 114 (term -> fact cyTerm .)
    GTOEQ           reduce using rule 114 (term -> fact cyTerm .)
    >               reduce using rule 114 (term -> fact cyTerm .)
    <               reduce using rule 114 (term -> fact cyTerm .)


state 168

    (117) cyTerm -> empty .

    +               reduce using rule 117 (cyTerm -> empty .)
    -               reduce using rule 117 (cyTerm -> empty .)
    EQ              reduce using rule 117 (cyTerm -> empty .)
    DIF             reduce using rule 117 (cyTerm -> empty .)
    LTOEQ           reduce using rule 117 (cyTerm -> empty .)
    GTOEQ           reduce using rule 117 (cyTerm -> empty .)
    >               reduce using rule 117 (cyTerm -> empty .)
    <               reduce using rule 117 (cyTerm -> empty .)
    AND             reduce using rule 117 (cyTerm -> empty .)
    OR              reduce using rule 117 (cyTerm -> empty .)
    ,               reduce using rule 117 (cyTerm -> empty .)
    )               reduce using rule 117 (cyTerm -> empty .)
    ;               reduce using rule 117 (cyTerm -> empty .)
    ]               reduce using rule 117 (cyTerm -> empty .)


state 169

    (25) init -> = initWith . errorInit
    (26) errorInit -> .

    ;               reduce using rule 26 (errorInit -> .)
    )               reduce using rule 26 (errorInit -> .)

    errorInit                      shift and go to state 207

state 170

    (29) initDict -> = ( . dictType : dictType ) errorInitDict
    (121) fact -> ( . expresion )
    (31) dictType -> . errorDictType CTES
    (32) dictType -> . cte
    (33) dictType -> . ID
    (95) expresion -> . sExp cyExpresion errorExpresion
    (34) errorDictType -> .
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (78) funcCall -> . ID ( opParamCall )

  ! shift/reduce conflict for CTES resolved as shift
    ID              shift and go to state 210
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127
    CTES            shift and go to state 125
    (               shift and go to state 119

  ! CTES            [ reduce using rule 34 (errorDictType -> .) ]

    dictType                       shift and go to state 208
    expresion                      shift and go to state 149
    term                           shift and go to state 126
    errorDictType                  shift and go to state 209
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 211
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 171

    (78) funcCall -> ID . ( opParamCall )
    (122) fact -> ID . opAccess errorOpAccess
    (124) opAccess -> . opStruct
    (125) opAccess -> . opDictionary
    (126) opAccess -> . empty
    (128) opStruct -> . errorOpStruct [ expresion ] opMatrix
    (133) opDictionary -> . . dictIndex
    (140) empty -> .
    (129) errorOpStruct -> .

    (               shift and go to state 106
    .               shift and go to state 158
    *               reduce using rule 140 (empty -> .)
    /               reduce using rule 140 (empty -> .)
    +               reduce using rule 140 (empty -> .)
    -               reduce using rule 140 (empty -> .)
    EQ              reduce using rule 140 (empty -> .)
    DIF             reduce using rule 140 (empty -> .)
    LTOEQ           reduce using rule 140 (empty -> .)
    GTOEQ           reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    <               reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    [               reduce using rule 129 (errorOpStruct -> .)

    errorOpStruct                  shift and go to state 154
    opDictionary                   shift and go to state 159
    opStruct                       shift and go to state 155
    opAccess                       shift and go to state 156
    empty                          shift and go to state 157

state 172

    (27) initWith -> expresion .

    ;               reduce using rule 27 (initWith -> expresion .)
    )               reduce using rule 27 (initWith -> expresion .)


state 173

    (28) initWith -> funcCall .
    (120) fact -> funcCall .

  ! reduce/reduce conflict for ; resolved using rule 28 (initWith -> funcCall .)
  ! reduce/reduce conflict for ) resolved using rule 28 (initWith -> funcCall .)
    ;               reduce using rule 28 (initWith -> funcCall .)
    )               reduce using rule 28 (initWith -> funcCall .)
    *               reduce using rule 120 (fact -> funcCall .)
    /               reduce using rule 120 (fact -> funcCall .)
    +               reduce using rule 120 (fact -> funcCall .)
    -               reduce using rule 120 (fact -> funcCall .)
    EQ              reduce using rule 120 (fact -> funcCall .)
    DIF             reduce using rule 120 (fact -> funcCall .)
    LTOEQ           reduce using rule 120 (fact -> funcCall .)
    GTOEQ           reduce using rule 120 (fact -> funcCall .)
    >               reduce using rule 120 (fact -> funcCall .)
    <               reduce using rule 120 (fact -> funcCall .)
    AND             reduce using rule 120 (fact -> funcCall .)
    OR              reduce using rule 120 (fact -> funcCall .)

  ! ;               [ reduce using rule 120 (fact -> funcCall .) ]
  ! )               [ reduce using rule 120 (fact -> funcCall .) ]


state 174

    (74) assignOptions -> [ expresion . ] assignMatrix init

    ]               shift and go to state 212


state 175

    (88) condition -> errorCondition IF ( expresion . ) { body } optionalElse

    )               shift and go to state 213


state 176

    (93) dict -> errorDict ( type : type ) .

    ;               reduce using rule 93 (dict -> errorDict ( type : type ) .)
    [               reduce using rule 93 (dict -> errorDict ( type : type ) .)


state 177

    (86) optionalMatrix -> [ CTED . ]

    ]               shift and go to state 214


state 178

    (47) opReturns -> errorOpReturns RETURNS type { opVars body return .

    }               reduce using rule 47 (opReturns -> errorOpReturns RETURNS type { opVars body return .)


state 179

    (42) return -> errorReturn . RETURN expresion ;

    RETURN          shift and go to state 215


state 180

    (37) cyParam -> errorCyParam ; param .

    )               reduce using rule 37 (cyParam -> errorCyParam ; param .)


state 181

    (66) whileCycle -> errorWhileCycle WHILE ( expresion ) . { body }

    {               shift and go to state 216


state 182

    (68) forCycle -> errorForCycle FOR ( assign ; . expresion ; assign ) { body }
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 217
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 183

    (121) fact -> ( expresion ) .

    *               reduce using rule 121 (fact -> ( expresion ) .)
    /               reduce using rule 121 (fact -> ( expresion ) .)
    +               reduce using rule 121 (fact -> ( expresion ) .)
    -               reduce using rule 121 (fact -> ( expresion ) .)
    AND             reduce using rule 121 (fact -> ( expresion ) .)
    OR              reduce using rule 121 (fact -> ( expresion ) .)
    ,               reduce using rule 121 (fact -> ( expresion ) .)
    )               reduce using rule 121 (fact -> ( expresion ) .)
    ;               reduce using rule 121 (fact -> ( expresion ) .)
    ]               reduce using rule 121 (fact -> ( expresion ) .)
    EQ              reduce using rule 121 (fact -> ( expresion ) .)
    DIF             reduce using rule 121 (fact -> ( expresion ) .)
    LTOEQ           reduce using rule 121 (fact -> ( expresion ) .)
    GTOEQ           reduce using rule 121 (fact -> ( expresion ) .)
    >               reduce using rule 121 (fact -> ( expresion ) .)
    <               reduce using rule 121 (fact -> ( expresion ) .)


state 184

    (97) cyExpresion -> AND expresion .

    ,               reduce using rule 97 (cyExpresion -> AND expresion .)
    )               reduce using rule 97 (cyExpresion -> AND expresion .)
    ;               reduce using rule 97 (cyExpresion -> AND expresion .)
    ]               reduce using rule 97 (cyExpresion -> AND expresion .)


state 185

    (95) expresion -> sExp cyExpresion errorExpresion .

    )               reduce using rule 95 (expresion -> sExp cyExpresion errorExpresion .)
    ,               reduce using rule 95 (expresion -> sExp cyExpresion errorExpresion .)
    ;               reduce using rule 95 (expresion -> sExp cyExpresion errorExpresion .)
    ]               reduce using rule 95 (expresion -> sExp cyExpresion errorExpresion .)


state 186

    (98) cyExpresion -> OR expresion .

    ,               reduce using rule 98 (cyExpresion -> OR expresion .)
    )               reduce using rule 98 (cyExpresion -> OR expresion .)
    ;               reduce using rule 98 (cyExpresion -> OR expresion .)
    ]               reduce using rule 98 (cyExpresion -> OR expresion .)


state 187

    (128) opStruct -> errorOpStruct [ . expresion ] opMatrix
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 218
    term                           shift and go to state 126
    exp                            shift and go to state 131
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    fact                           shift and go to state 132

state 188

    (122) fact -> ID opAccess errorOpAccess .

    *               reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    /               reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    +               reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    -               reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    AND             reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    OR              reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    ,               reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    )               reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    ;               reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    ]               reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    EQ              reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    DIF             reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    LTOEQ           reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    GTOEQ           reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    >               reduce using rule 122 (fact -> ID opAccess errorOpAccess .)
    <               reduce using rule 122 (fact -> ID opAccess errorOpAccess .)


state 189

    (134) dictIndex -> FIRST .

    *               reduce using rule 134 (dictIndex -> FIRST .)
    /               reduce using rule 134 (dictIndex -> FIRST .)
    +               reduce using rule 134 (dictIndex -> FIRST .)
    -               reduce using rule 134 (dictIndex -> FIRST .)
    EQ              reduce using rule 134 (dictIndex -> FIRST .)
    DIF             reduce using rule 134 (dictIndex -> FIRST .)
    LTOEQ           reduce using rule 134 (dictIndex -> FIRST .)
    GTOEQ           reduce using rule 134 (dictIndex -> FIRST .)
    >               reduce using rule 134 (dictIndex -> FIRST .)
    <               reduce using rule 134 (dictIndex -> FIRST .)
    AND             reduce using rule 134 (dictIndex -> FIRST .)
    OR              reduce using rule 134 (dictIndex -> FIRST .)
    ,               reduce using rule 134 (dictIndex -> FIRST .)
    )               reduce using rule 134 (dictIndex -> FIRST .)
    ]               reduce using rule 134 (dictIndex -> FIRST .)
    ;               reduce using rule 134 (dictIndex -> FIRST .)


state 190

    (135) dictIndex -> LAST .

    *               reduce using rule 135 (dictIndex -> LAST .)
    /               reduce using rule 135 (dictIndex -> LAST .)
    +               reduce using rule 135 (dictIndex -> LAST .)
    -               reduce using rule 135 (dictIndex -> LAST .)
    EQ              reduce using rule 135 (dictIndex -> LAST .)
    DIF             reduce using rule 135 (dictIndex -> LAST .)
    LTOEQ           reduce using rule 135 (dictIndex -> LAST .)
    GTOEQ           reduce using rule 135 (dictIndex -> LAST .)
    >               reduce using rule 135 (dictIndex -> LAST .)
    <               reduce using rule 135 (dictIndex -> LAST .)
    AND             reduce using rule 135 (dictIndex -> LAST .)
    OR              reduce using rule 135 (dictIndex -> LAST .)
    ,               reduce using rule 135 (dictIndex -> LAST .)
    )               reduce using rule 135 (dictIndex -> LAST .)
    ]               reduce using rule 135 (dictIndex -> LAST .)
    ;               reduce using rule 135 (dictIndex -> LAST .)


state 191

    (133) opDictionary -> . dictIndex .

    *               reduce using rule 133 (opDictionary -> . dictIndex .)
    /               reduce using rule 133 (opDictionary -> . dictIndex .)
    +               reduce using rule 133 (opDictionary -> . dictIndex .)
    -               reduce using rule 133 (opDictionary -> . dictIndex .)
    EQ              reduce using rule 133 (opDictionary -> . dictIndex .)
    DIF             reduce using rule 133 (opDictionary -> . dictIndex .)
    LTOEQ           reduce using rule 133 (opDictionary -> . dictIndex .)
    GTOEQ           reduce using rule 133 (opDictionary -> . dictIndex .)
    >               reduce using rule 133 (opDictionary -> . dictIndex .)
    <               reduce using rule 133 (opDictionary -> . dictIndex .)
    AND             reduce using rule 133 (opDictionary -> . dictIndex .)
    OR              reduce using rule 133 (opDictionary -> . dictIndex .)
    ,               reduce using rule 133 (opDictionary -> . dictIndex .)
    )               reduce using rule 133 (opDictionary -> . dictIndex .)
    ]               reduce using rule 133 (opDictionary -> . dictIndex .)
    ;               reduce using rule 133 (opDictionary -> . dictIndex .)


state 192

    (81) cyParamCall -> , expresion . cyParamCall
    (81) cyParamCall -> . , expresion cyParamCall
    (82) cyParamCall -> . empty
    (140) empty -> .

    ,               shift and go to state 161
    )               reduce using rule 140 (empty -> .)

    cyParamCall                    shift and go to state 219
    empty                          shift and go to state 162

state 193

    (109) exp -> term errorCyExp cyExp .

    EQ              reduce using rule 109 (exp -> term errorCyExp cyExp .)
    DIF             reduce using rule 109 (exp -> term errorCyExp cyExp .)
    LTOEQ           reduce using rule 109 (exp -> term errorCyExp cyExp .)
    GTOEQ           reduce using rule 109 (exp -> term errorCyExp cyExp .)
    >               reduce using rule 109 (exp -> term errorCyExp cyExp .)
    <               reduce using rule 109 (exp -> term errorCyExp cyExp .)
    AND             reduce using rule 109 (exp -> term errorCyExp cyExp .)
    OR              reduce using rule 109 (exp -> term errorCyExp cyExp .)
    ;               reduce using rule 109 (exp -> term errorCyExp cyExp .)
    )               reduce using rule 109 (exp -> term errorCyExp cyExp .)
    ]               reduce using rule 109 (exp -> term errorCyExp cyExp .)
    ,               reduce using rule 109 (exp -> term errorCyExp cyExp .)


state 194

    (110) cyExp -> + . term
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    term                           shift and go to state 220
    funcCall                       shift and go to state 128
    cte                            shift and go to state 129
    fact                           shift and go to state 132

state 195

    (111) cyExp -> - . term
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    term                           shift and go to state 221
    funcCall                       shift and go to state 128
    cte                            shift and go to state 129
    fact                           shift and go to state 132

state 196

    (112) cyExp -> empty .

    EQ              reduce using rule 112 (cyExp -> empty .)
    DIF             reduce using rule 112 (cyExp -> empty .)
    LTOEQ           reduce using rule 112 (cyExp -> empty .)
    GTOEQ           reduce using rule 112 (cyExp -> empty .)
    >               reduce using rule 112 (cyExp -> empty .)
    <               reduce using rule 112 (cyExp -> empty .)
    AND             reduce using rule 112 (cyExp -> empty .)
    OR              reduce using rule 112 (cyExp -> empty .)
    ,               reduce using rule 112 (cyExp -> empty .)
    )               reduce using rule 112 (cyExp -> empty .)
    ;               reduce using rule 112 (cyExp -> empty .)
    ]               reduce using rule 112 (cyExp -> empty .)


state 197

    (101) opSExp -> EQ . exp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    cte                            shift and go to state 129
    exp                            shift and go to state 222
    fact                           shift and go to state 132

state 198

    (102) opSExp -> DIF . exp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    cte                            shift and go to state 129
    exp                            shift and go to state 223
    fact                           shift and go to state 132

state 199

    (104) opSExp -> GTOEQ . exp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    cte                            shift and go to state 129
    exp                            shift and go to state 224
    fact                           shift and go to state 132

state 200

    (105) opSExp -> > . exp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    cte                            shift and go to state 129
    exp                            shift and go to state 225
    fact                           shift and go to state 132

state 201

    (103) opSExp -> LTOEQ . exp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    cte                            shift and go to state 129
    exp                            shift and go to state 226
    fact                           shift and go to state 132

state 202

    (106) opSExp -> < . exp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    cte                            shift and go to state 129
    exp                            shift and go to state 227
    fact                           shift and go to state 132

state 203

    (107) opSExp -> empty .

    AND             reduce using rule 107 (opSExp -> empty .)
    OR              reduce using rule 107 (opSExp -> empty .)
    ,               reduce using rule 107 (opSExp -> empty .)
    )               reduce using rule 107 (opSExp -> empty .)
    ;               reduce using rule 107 (opSExp -> empty .)
    ]               reduce using rule 107 (opSExp -> empty .)


state 204

    (100) sExp -> exp errorOpSExp opSExp .

    AND             reduce using rule 100 (sExp -> exp errorOpSExp opSExp .)
    OR              reduce using rule 100 (sExp -> exp errorOpSExp opSExp .)
    )               reduce using rule 100 (sExp -> exp errorOpSExp opSExp .)
    ]               reduce using rule 100 (sExp -> exp errorOpSExp opSExp .)
    ;               reduce using rule 100 (sExp -> exp errorOpSExp opSExp .)
    ,               reduce using rule 100 (sExp -> exp errorOpSExp opSExp .)


state 205

    (115) cyTerm -> * errorFact . fact
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    funcCall                       shift and go to state 128
    cte                            shift and go to state 129
    fact                           shift and go to state 228

state 206

    (116) cyTerm -> / fact .

    +               reduce using rule 116 (cyTerm -> / fact .)
    -               reduce using rule 116 (cyTerm -> / fact .)
    EQ              reduce using rule 116 (cyTerm -> / fact .)
    DIF             reduce using rule 116 (cyTerm -> / fact .)
    LTOEQ           reduce using rule 116 (cyTerm -> / fact .)
    GTOEQ           reduce using rule 116 (cyTerm -> / fact .)
    >               reduce using rule 116 (cyTerm -> / fact .)
    <               reduce using rule 116 (cyTerm -> / fact .)
    AND             reduce using rule 116 (cyTerm -> / fact .)
    OR              reduce using rule 116 (cyTerm -> / fact .)
    ,               reduce using rule 116 (cyTerm -> / fact .)
    )               reduce using rule 116 (cyTerm -> / fact .)
    ;               reduce using rule 116 (cyTerm -> / fact .)
    ]               reduce using rule 116 (cyTerm -> / fact .)


state 207

    (25) init -> = initWith errorInit .

    ;               reduce using rule 25 (init -> = initWith errorInit .)
    )               reduce using rule 25 (init -> = initWith errorInit .)


state 208

    (29) initDict -> = ( dictType . : dictType ) errorInitDict

    :               shift and go to state 229


state 209

    (31) dictType -> errorDictType . CTES

    CTES            shift and go to state 230


state 210

    (33) dictType -> ID .
    (122) fact -> ID . opAccess errorOpAccess
    (78) funcCall -> ID . ( opParamCall )
    (124) opAccess -> . opStruct
    (125) opAccess -> . opDictionary
    (126) opAccess -> . empty
    (128) opStruct -> . errorOpStruct [ expresion ] opMatrix
    (133) opDictionary -> . . dictIndex
    (140) empty -> .
    (129) errorOpStruct -> .

    :               reduce using rule 33 (dictType -> ID .)
    (               shift and go to state 106
    .               shift and go to state 158
    *               reduce using rule 140 (empty -> .)
    /               reduce using rule 140 (empty -> .)
    +               reduce using rule 140 (empty -> .)
    -               reduce using rule 140 (empty -> .)
    EQ              reduce using rule 140 (empty -> .)
    DIF             reduce using rule 140 (empty -> .)
    LTOEQ           reduce using rule 140 (empty -> .)
    GTOEQ           reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    <               reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    [               reduce using rule 129 (errorOpStruct -> .)

    errorOpStruct                  shift and go to state 154
    opDictionary                   shift and go to state 159
    opStruct                       shift and go to state 155
    opAccess                       shift and go to state 156
    empty                          shift and go to state 157

state 211

    (32) dictType -> cte .
    (119) fact -> cte .

    :               reduce using rule 32 (dictType -> cte .)
    *               reduce using rule 119 (fact -> cte .)
    /               reduce using rule 119 (fact -> cte .)
    +               reduce using rule 119 (fact -> cte .)
    -               reduce using rule 119 (fact -> cte .)
    EQ              reduce using rule 119 (fact -> cte .)
    DIF             reduce using rule 119 (fact -> cte .)
    LTOEQ           reduce using rule 119 (fact -> cte .)
    GTOEQ           reduce using rule 119 (fact -> cte .)
    >               reduce using rule 119 (fact -> cte .)
    <               reduce using rule 119 (fact -> cte .)
    AND             reduce using rule 119 (fact -> cte .)
    OR              reduce using rule 119 (fact -> cte .)
    )               reduce using rule 119 (fact -> cte .)


state 212

    (74) assignOptions -> [ expresion ] . assignMatrix init
    (75) assignMatrix -> . [ expresion ] errorAssignMatrix
    (76) assignMatrix -> . empty
    (140) empty -> .

    [               shift and go to state 232
    =               reduce using rule 140 (empty -> .)

    assignMatrix                   shift and go to state 231
    empty                          shift and go to state 233

state 213

    (88) condition -> errorCondition IF ( expresion ) . { body } optionalElse

    {               shift and go to state 234


state 214

    (86) optionalMatrix -> [ CTED ] .

    ;               reduce using rule 86 (optionalMatrix -> [ CTED ] .)


state 215

    (42) return -> errorReturn RETURN . expresion ;
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 235
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 216

    (66) whileCycle -> errorWhileCycle WHILE ( expresion ) { . body }
    (60) body -> . errorBody cyInstruction
    (61) body -> . empty
    (62) errorBody -> .
    (140) empty -> .

    ID              reduce using rule 62 (errorBody -> .)
    IF              reduce using rule 62 (errorBody -> .)
    FOR             reduce using rule 62 (errorBody -> .)
    WHILE           reduce using rule 62 (errorBody -> .)
    }               reduce using rule 140 (empty -> .)

    body                           shift and go to state 236
    errorBody                      shift and go to state 66
    empty                          shift and go to state 67

state 217

    (68) forCycle -> errorForCycle FOR ( assign ; expresion . ; assign ) { body }

    ;               shift and go to state 237


state 218

    (128) opStruct -> errorOpStruct [ expresion . ] opMatrix

    ]               shift and go to state 238


state 219

    (81) cyParamCall -> , expresion cyParamCall .

    )               reduce using rule 81 (cyParamCall -> , expresion cyParamCall .)


state 220

    (110) cyExp -> + term .

    EQ              reduce using rule 110 (cyExp -> + term .)
    DIF             reduce using rule 110 (cyExp -> + term .)
    LTOEQ           reduce using rule 110 (cyExp -> + term .)
    GTOEQ           reduce using rule 110 (cyExp -> + term .)
    >               reduce using rule 110 (cyExp -> + term .)
    <               reduce using rule 110 (cyExp -> + term .)
    AND             reduce using rule 110 (cyExp -> + term .)
    OR              reduce using rule 110 (cyExp -> + term .)
    ,               reduce using rule 110 (cyExp -> + term .)
    )               reduce using rule 110 (cyExp -> + term .)
    ;               reduce using rule 110 (cyExp -> + term .)
    ]               reduce using rule 110 (cyExp -> + term .)


state 221

    (111) cyExp -> - term .

    EQ              reduce using rule 111 (cyExp -> - term .)
    DIF             reduce using rule 111 (cyExp -> - term .)
    LTOEQ           reduce using rule 111 (cyExp -> - term .)
    GTOEQ           reduce using rule 111 (cyExp -> - term .)
    >               reduce using rule 111 (cyExp -> - term .)
    <               reduce using rule 111 (cyExp -> - term .)
    AND             reduce using rule 111 (cyExp -> - term .)
    OR              reduce using rule 111 (cyExp -> - term .)
    ,               reduce using rule 111 (cyExp -> - term .)
    )               reduce using rule 111 (cyExp -> - term .)
    ;               reduce using rule 111 (cyExp -> - term .)
    ]               reduce using rule 111 (cyExp -> - term .)


state 222

    (101) opSExp -> EQ exp .

    AND             reduce using rule 101 (opSExp -> EQ exp .)
    OR              reduce using rule 101 (opSExp -> EQ exp .)
    ,               reduce using rule 101 (opSExp -> EQ exp .)
    )               reduce using rule 101 (opSExp -> EQ exp .)
    ;               reduce using rule 101 (opSExp -> EQ exp .)
    ]               reduce using rule 101 (opSExp -> EQ exp .)


state 223

    (102) opSExp -> DIF exp .

    AND             reduce using rule 102 (opSExp -> DIF exp .)
    OR              reduce using rule 102 (opSExp -> DIF exp .)
    ,               reduce using rule 102 (opSExp -> DIF exp .)
    )               reduce using rule 102 (opSExp -> DIF exp .)
    ;               reduce using rule 102 (opSExp -> DIF exp .)
    ]               reduce using rule 102 (opSExp -> DIF exp .)


state 224

    (104) opSExp -> GTOEQ exp .

    AND             reduce using rule 104 (opSExp -> GTOEQ exp .)
    OR              reduce using rule 104 (opSExp -> GTOEQ exp .)
    ,               reduce using rule 104 (opSExp -> GTOEQ exp .)
    )               reduce using rule 104 (opSExp -> GTOEQ exp .)
    ;               reduce using rule 104 (opSExp -> GTOEQ exp .)
    ]               reduce using rule 104 (opSExp -> GTOEQ exp .)


state 225

    (105) opSExp -> > exp .

    AND             reduce using rule 105 (opSExp -> > exp .)
    OR              reduce using rule 105 (opSExp -> > exp .)
    ,               reduce using rule 105 (opSExp -> > exp .)
    )               reduce using rule 105 (opSExp -> > exp .)
    ;               reduce using rule 105 (opSExp -> > exp .)
    ]               reduce using rule 105 (opSExp -> > exp .)


state 226

    (103) opSExp -> LTOEQ exp .

    AND             reduce using rule 103 (opSExp -> LTOEQ exp .)
    OR              reduce using rule 103 (opSExp -> LTOEQ exp .)
    ,               reduce using rule 103 (opSExp -> LTOEQ exp .)
    )               reduce using rule 103 (opSExp -> LTOEQ exp .)
    ;               reduce using rule 103 (opSExp -> LTOEQ exp .)
    ]               reduce using rule 103 (opSExp -> LTOEQ exp .)


state 227

    (106) opSExp -> < exp .

    AND             reduce using rule 106 (opSExp -> < exp .)
    OR              reduce using rule 106 (opSExp -> < exp .)
    ,               reduce using rule 106 (opSExp -> < exp .)
    )               reduce using rule 106 (opSExp -> < exp .)
    ;               reduce using rule 106 (opSExp -> < exp .)
    ]               reduce using rule 106 (opSExp -> < exp .)


state 228

    (115) cyTerm -> * errorFact fact .

    +               reduce using rule 115 (cyTerm -> * errorFact fact .)
    -               reduce using rule 115 (cyTerm -> * errorFact fact .)
    EQ              reduce using rule 115 (cyTerm -> * errorFact fact .)
    DIF             reduce using rule 115 (cyTerm -> * errorFact fact .)
    LTOEQ           reduce using rule 115 (cyTerm -> * errorFact fact .)
    GTOEQ           reduce using rule 115 (cyTerm -> * errorFact fact .)
    >               reduce using rule 115 (cyTerm -> * errorFact fact .)
    <               reduce using rule 115 (cyTerm -> * errorFact fact .)
    AND             reduce using rule 115 (cyTerm -> * errorFact fact .)
    OR              reduce using rule 115 (cyTerm -> * errorFact fact .)
    ,               reduce using rule 115 (cyTerm -> * errorFact fact .)
    )               reduce using rule 115 (cyTerm -> * errorFact fact .)
    ;               reduce using rule 115 (cyTerm -> * errorFact fact .)
    ]               reduce using rule 115 (cyTerm -> * errorFact fact .)


state 229

    (29) initDict -> = ( dictType : . dictType ) errorInitDict
    (31) dictType -> . errorDictType CTES
    (32) dictType -> . cte
    (33) dictType -> . ID
    (34) errorDictType -> .
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE

    ID              shift and go to state 241
    CTES            reduce using rule 34 (errorDictType -> .)
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    dictType                       shift and go to state 239
    errorDictType                  shift and go to state 209
    cte                            shift and go to state 240

state 230

    (31) dictType -> errorDictType CTES .

    :               reduce using rule 31 (dictType -> errorDictType CTES .)
    )               reduce using rule 31 (dictType -> errorDictType CTES .)


state 231

    (74) assignOptions -> [ expresion ] assignMatrix . init
    (25) init -> . = initWith errorInit

    =               shift and go to state 243

    init                           shift and go to state 242

state 232

    (75) assignMatrix -> [ . expresion ] errorAssignMatrix
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 244
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 233

    (76) assignMatrix -> empty .

    =               reduce using rule 76 (assignMatrix -> empty .)


state 234

    (88) condition -> errorCondition IF ( expresion ) { . body } optionalElse
    (60) body -> . errorBody cyInstruction
    (61) body -> . empty
    (62) errorBody -> .
    (140) empty -> .

    ID              reduce using rule 62 (errorBody -> .)
    IF              reduce using rule 62 (errorBody -> .)
    FOR             reduce using rule 62 (errorBody -> .)
    WHILE           reduce using rule 62 (errorBody -> .)
    }               reduce using rule 140 (empty -> .)

    body                           shift and go to state 245
    errorBody                      shift and go to state 66
    empty                          shift and go to state 67

state 235

    (42) return -> errorReturn RETURN expresion . ;

    ;               shift and go to state 246


state 236

    (66) whileCycle -> errorWhileCycle WHILE ( expresion ) { body . }

    }               shift and go to state 247


state 237

    (68) forCycle -> errorForCycle FOR ( assign ; expresion ; . assign ) { body }
    (70) assign -> . ID errorAssign assignOptions

    ID              shift and go to state 146

    assign                         shift and go to state 248

state 238

    (128) opStruct -> errorOpStruct [ expresion ] . opMatrix
    (130) opMatrix -> . errorOpMatrix [ expresion ]
    (131) opMatrix -> . empty
    (132) errorOpMatrix -> .
    (140) empty -> .

    [               reduce using rule 132 (errorOpMatrix -> .)
    *               reduce using rule 140 (empty -> .)
    /               reduce using rule 140 (empty -> .)
    +               reduce using rule 140 (empty -> .)
    -               reduce using rule 140 (empty -> .)
    EQ              reduce using rule 140 (empty -> .)
    DIF             reduce using rule 140 (empty -> .)
    LTOEQ           reduce using rule 140 (empty -> .)
    GTOEQ           reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    <               reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)

    empty                          shift and go to state 251
    errorOpMatrix                  shift and go to state 249
    opMatrix                       shift and go to state 250

state 239

    (29) initDict -> = ( dictType : dictType . ) errorInitDict

    )               shift and go to state 252


state 240

    (32) dictType -> cte .

    )               reduce using rule 32 (dictType -> cte .)


state 241

    (33) dictType -> ID .

    )               reduce using rule 33 (dictType -> ID .)


state 242

    (74) assignOptions -> [ expresion ] assignMatrix init .

    ;               reduce using rule 74 (assignOptions -> [ expresion ] assignMatrix init .)
    )               reduce using rule 74 (assignOptions -> [ expresion ] assignMatrix init .)


state 243

    (25) init -> = . initWith errorInit
    (27) initWith -> . expresion
    (28) initWith -> . funcCall
    (95) expresion -> . sExp cyExpresion errorExpresion
    (78) funcCall -> . ID ( opParamCall )
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE

    ID              shift and go to state 171
    CTES            shift and go to state 125
    (               shift and go to state 119
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 172
    initWith                       shift and go to state 169
    funcCall                       shift and go to state 173
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    term                           shift and go to state 126
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 244

    (75) assignMatrix -> [ expresion . ] errorAssignMatrix

    ]               shift and go to state 253


state 245

    (88) condition -> errorCondition IF ( expresion ) { body . } optionalElse

    }               shift and go to state 254


state 246

    (42) return -> errorReturn RETURN expresion ; .

    }               reduce using rule 42 (return -> errorReturn RETURN expresion ; .)


state 247

    (66) whileCycle -> errorWhileCycle WHILE ( expresion ) { body } .

    ID              reduce using rule 66 (whileCycle -> errorWhileCycle WHILE ( expresion ) { body } .)
    IF              reduce using rule 66 (whileCycle -> errorWhileCycle WHILE ( expresion ) { body } .)
    FOR             reduce using rule 66 (whileCycle -> errorWhileCycle WHILE ( expresion ) { body } .)
    WHILE           reduce using rule 66 (whileCycle -> errorWhileCycle WHILE ( expresion ) { body } .)
    }               reduce using rule 66 (whileCycle -> errorWhileCycle WHILE ( expresion ) { body } .)
    RETURN          reduce using rule 66 (whileCycle -> errorWhileCycle WHILE ( expresion ) { body } .)


state 248

    (68) forCycle -> errorForCycle FOR ( assign ; expresion ; assign . ) { body }

    )               shift and go to state 255


state 249

    (130) opMatrix -> errorOpMatrix . [ expresion ]

    [               shift and go to state 256


state 250

    (128) opStruct -> errorOpStruct [ expresion ] opMatrix .

    *               reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    /               reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    +               reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    -               reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    EQ              reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    DIF             reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    LTOEQ           reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    GTOEQ           reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    >               reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    <               reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    AND             reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    OR              reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    ,               reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    )               reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    ]               reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)
    ;               reduce using rule 128 (opStruct -> errorOpStruct [ expresion ] opMatrix .)


state 251

    (131) opMatrix -> empty .

    *               reduce using rule 131 (opMatrix -> empty .)
    /               reduce using rule 131 (opMatrix -> empty .)
    +               reduce using rule 131 (opMatrix -> empty .)
    -               reduce using rule 131 (opMatrix -> empty .)
    EQ              reduce using rule 131 (opMatrix -> empty .)
    DIF             reduce using rule 131 (opMatrix -> empty .)
    LTOEQ           reduce using rule 131 (opMatrix -> empty .)
    GTOEQ           reduce using rule 131 (opMatrix -> empty .)
    >               reduce using rule 131 (opMatrix -> empty .)
    <               reduce using rule 131 (opMatrix -> empty .)
    AND             reduce using rule 131 (opMatrix -> empty .)
    OR              reduce using rule 131 (opMatrix -> empty .)
    ,               reduce using rule 131 (opMatrix -> empty .)
    )               reduce using rule 131 (opMatrix -> empty .)
    ]               reduce using rule 131 (opMatrix -> empty .)
    ;               reduce using rule 131 (opMatrix -> empty .)


state 252

    (29) initDict -> = ( dictType : dictType ) . errorInitDict
    (30) errorInitDict -> .

    ;               reduce using rule 30 (errorInitDict -> .)
    )               reduce using rule 30 (errorInitDict -> .)

    errorInitDict                  shift and go to state 257

state 253

    (75) assignMatrix -> [ expresion ] . errorAssignMatrix
    (77) errorAssignMatrix -> .

    =               reduce using rule 77 (errorAssignMatrix -> .)

    errorAssignMatrix              shift and go to state 258

state 254

    (88) condition -> errorCondition IF ( expresion ) { body } . optionalElse
    (90) optionalElse -> . errorElse ELSE { body }
    (91) optionalElse -> . empty
    (92) errorElse -> .
    (140) empty -> .

    ELSE            reduce using rule 92 (errorElse -> .)
    ID              reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    }               reduce using rule 140 (empty -> .)
    RETURN          reduce using rule 140 (empty -> .)

    errorElse                      shift and go to state 259
    optionalElse                   shift and go to state 260
    empty                          shift and go to state 261

state 255

    (68) forCycle -> errorForCycle FOR ( assign ; expresion ; assign ) . { body }

    {               shift and go to state 262


state 256

    (130) opMatrix -> errorOpMatrix [ . expresion ]
    (95) expresion -> . sExp cyExpresion errorExpresion
    (100) sExp -> . exp errorOpSExp opSExp
    (109) exp -> . term errorCyExp cyExp
    (114) term -> . fact cyTerm
    (118) fact -> . CTES
    (119) fact -> . cte
    (120) fact -> . funcCall
    (121) fact -> . ( expresion )
    (122) fact -> . ID opAccess errorOpAccess
    (136) cte -> . CTED
    (137) cte -> . CTEF
    (138) cte -> . TRUE
    (139) cte -> . FALSE
    (78) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 125
    (               shift and go to state 119
    ID              shift and go to state 123
    CTED            shift and go to state 122
    CTEF            shift and go to state 130
    TRUE            shift and go to state 118
    FALSE           shift and go to state 127

    expresion                      shift and go to state 263
    term                           shift and go to state 126
    funcCall                       shift and go to state 128
    sExp                           shift and go to state 120
    cte                            shift and go to state 129
    exp                            shift and go to state 131
    fact                           shift and go to state 132

state 257

    (29) initDict -> = ( dictType : dictType ) errorInitDict .

    ;               reduce using rule 29 (initDict -> = ( dictType : dictType ) errorInitDict .)
    )               reduce using rule 29 (initDict -> = ( dictType : dictType ) errorInitDict .)


state 258

    (75) assignMatrix -> [ expresion ] errorAssignMatrix .

    =               reduce using rule 75 (assignMatrix -> [ expresion ] errorAssignMatrix .)


state 259

    (90) optionalElse -> errorElse . ELSE { body }

    ELSE            shift and go to state 264


state 260

    (88) condition -> errorCondition IF ( expresion ) { body } optionalElse .

    ID              reduce using rule 88 (condition -> errorCondition IF ( expresion ) { body } optionalElse .)
    IF              reduce using rule 88 (condition -> errorCondition IF ( expresion ) { body } optionalElse .)
    FOR             reduce using rule 88 (condition -> errorCondition IF ( expresion ) { body } optionalElse .)
    WHILE           reduce using rule 88 (condition -> errorCondition IF ( expresion ) { body } optionalElse .)
    }               reduce using rule 88 (condition -> errorCondition IF ( expresion ) { body } optionalElse .)
    RETURN          reduce using rule 88 (condition -> errorCondition IF ( expresion ) { body } optionalElse .)


state 261

    (91) optionalElse -> empty .

    ID              reduce using rule 91 (optionalElse -> empty .)
    IF              reduce using rule 91 (optionalElse -> empty .)
    FOR             reduce using rule 91 (optionalElse -> empty .)
    WHILE           reduce using rule 91 (optionalElse -> empty .)
    }               reduce using rule 91 (optionalElse -> empty .)
    RETURN          reduce using rule 91 (optionalElse -> empty .)


state 262

    (68) forCycle -> errorForCycle FOR ( assign ; expresion ; assign ) { . body }
    (60) body -> . errorBody cyInstruction
    (61) body -> . empty
    (62) errorBody -> .
    (140) empty -> .

    ID              reduce using rule 62 (errorBody -> .)
    IF              reduce using rule 62 (errorBody -> .)
    FOR             reduce using rule 62 (errorBody -> .)
    WHILE           reduce using rule 62 (errorBody -> .)
    }               reduce using rule 140 (empty -> .)

    body                           shift and go to state 265
    errorBody                      shift and go to state 66
    empty                          shift and go to state 67

state 263

    (130) opMatrix -> errorOpMatrix [ expresion . ]

    ]               shift and go to state 266


state 264

    (90) optionalElse -> errorElse ELSE . { body }

    {               shift and go to state 267


state 265

    (68) forCycle -> errorForCycle FOR ( assign ; expresion ; assign ) { body . }

    }               shift and go to state 268


state 266

    (130) opMatrix -> errorOpMatrix [ expresion ] .

    *               reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    /               reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    +               reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    -               reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    EQ              reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    DIF             reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    LTOEQ           reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    GTOEQ           reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    >               reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    <               reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    AND             reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    OR              reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    ,               reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    )               reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    ]               reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)
    ;               reduce using rule 130 (opMatrix -> errorOpMatrix [ expresion ] .)


state 267

    (90) optionalElse -> errorElse ELSE { . body }
    (60) body -> . errorBody cyInstruction
    (61) body -> . empty
    (62) errorBody -> .
    (140) empty -> .

    ID              reduce using rule 62 (errorBody -> .)
    IF              reduce using rule 62 (errorBody -> .)
    FOR             reduce using rule 62 (errorBody -> .)
    WHILE           reduce using rule 62 (errorBody -> .)
    }               reduce using rule 140 (empty -> .)

    body                           shift and go to state 269
    empty                          shift and go to state 67
    errorBody                      shift and go to state 66

state 268

    (68) forCycle -> errorForCycle FOR ( assign ; expresion ; assign ) { body } .

    ID              reduce using rule 68 (forCycle -> errorForCycle FOR ( assign ; expresion ; assign ) { body } .)
    IF              reduce using rule 68 (forCycle -> errorForCycle FOR ( assign ; expresion ; assign ) { body } .)
    FOR             reduce using rule 68 (forCycle -> errorForCycle FOR ( assign ; expresion ; assign ) { body } .)
    WHILE           reduce using rule 68 (forCycle -> errorForCycle FOR ( assign ; expresion ; assign ) { body } .)
    }               reduce using rule 68 (forCycle -> errorForCycle FOR ( assign ; expresion ; assign ) { body } .)
    RETURN          reduce using rule 68 (forCycle -> errorForCycle FOR ( assign ; expresion ; assign ) { body } .)


state 269

    (90) optionalElse -> errorElse ELSE { body . }

    }               shift and go to state 270


state 270

    (90) optionalElse -> errorElse ELSE { body } .

    ID              reduce using rule 90 (optionalElse -> errorElse ELSE { body } .)
    IF              reduce using rule 90 (optionalElse -> errorElse ELSE { body } .)
    FOR             reduce using rule 90 (optionalElse -> errorElse ELSE { body } .)
    WHILE           reduce using rule 90 (optionalElse -> errorElse ELSE { body } .)
    }               reduce using rule 90 (optionalElse -> errorElse ELSE { body } .)
    RETURN          reduce using rule 90 (optionalElse -> errorElse ELSE { body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for CTES in state 170 resolved as shift
WARNING: reduce/reduce conflict in state 173 resolved using rule (initWith -> funcCall)
WARNING: rejected rule (fact -> funcCall) in state 173
