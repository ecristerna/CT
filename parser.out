Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM errorProgram ID { opVars opFunctions main }
Rule 2     errorProgram -> <empty>
Rule 3     opVars -> vars
Rule 4     opVars -> empty
Rule 5     opFunctions -> function opFunctions
Rule 6     opFunctions -> empty
Rule 7     vars -> VARS declare
Rule 8     type -> INT
Rule 9     type -> FLOAT
Rule 10    type -> STRING
Rule 11    type -> OBJECT
Rule 12    type -> BOOL
Rule 13    main -> MAIN { opVars body }
Rule 14    instr -> basicStatements ;
Rule 15    instr -> condition
Rule 16    instr -> cycle
Rule 17    basicStatements -> assign
Rule 18    basicStatements -> funcCall
Rule 19    declare -> basicDeclare
Rule 20    declare -> structDeclare
Rule 21    declare -> dictDeclare
Rule 22    init -> = initWith
Rule 23    initWith -> expresion
Rule 24    initWith -> funcCall
Rule 25    initDict -> = ( dictType : dictType )
Rule 26    dictType -> CTES
Rule 27    dictType -> cte
Rule 28    dictType -> ID
Rule 29    param -> type ID cyTypeParam cyParam
Rule 30    cyParam -> ; param
Rule 31    cyParam -> empty
Rule 32    function -> FUNC ID opParameters opReturns }
Rule 33    return -> RETURN expresion ;
Rule 34    opParameters -> ( param )
Rule 35    opParameters -> empty
Rule 36    opReturns -> RETURNS type { opVars body return
Rule 37    opReturns -> { opVars body
Rule 38    basicDeclare -> type ID cyTypeParam ; cyDeclare
Rule 39    structDeclare -> STRUCT ID struct ; cyDeclare
Rule 40    dictDeclare -> DICT ID dict ; cyDeclare
Rule 41    cyTypeParam -> , ID
Rule 42    cyTypeParam -> empty
Rule 43    cyDeclare -> declare
Rule 44    cyDeclare -> empty
Rule 45    body -> cyInstruction
Rule 46    body -> empty
Rule 47    cyInstruction -> instr body
Rule 48    cycle -> forCycle
Rule 49    cycle -> whileCycle
Rule 50    whileCycle -> WHILE ( expresion ) { body }
Rule 51    forCycle -> FOR ( assign ; expresion ; assign ) { body }
Rule 52    assign -> ID assignOptions
Rule 53    assignOptions -> init
Rule 54    assignOptions -> initDict
Rule 55    assignOptions -> [ expresion ] assignMatrix init
Rule 56    assignMatrix -> [ expresion ]
Rule 57    assignMatrix -> empty
Rule 58    funcCall -> ID ( opParamCall )
Rule 59    opParamCall -> expresion cyParamCall
Rule 60    opParamCall -> empty
Rule 61    cyParamCall -> , expresion cyParamCall
Rule 62    cyParamCall -> empty
Rule 63    struct -> structType [ CTED ] optionalMatrix
Rule 64    structType -> type
Rule 65    structType -> DICT dict
Rule 66    optionalMatrix -> [ CTED ]
Rule 67    optionalMatrix -> empty
Rule 68    condition -> IF ( expresion ) { body } optionalElse
Rule 69    optionalElse -> ELSE { body }
Rule 70    optionalElse -> empty
Rule 71    dict -> ( type : type )
Rule 72    expresion -> sExp cyExpresion
Rule 73    cyExpresion -> AND expresion
Rule 74    cyExpresion -> OR expresion
Rule 75    cyExpresion -> empty
Rule 76    sExp -> exp opSExp
Rule 77    opSExp -> EQ exp
Rule 78    opSExp -> DIF exp
Rule 79    opSExp -> LTOEQ exp
Rule 80    opSExp -> GTOEQ exp
Rule 81    opSExp -> > exp
Rule 82    opSExp -> < exp
Rule 83    opSExp -> empty
Rule 84    exp -> term cyExp
Rule 85    cyExp -> + term
Rule 86    cyExp -> - term
Rule 87    cyExp -> empty
Rule 88    term -> fact cyTerm
Rule 89    cyTerm -> * fact
Rule 90    cyTerm -> / fact
Rule 91    cyTerm -> empty
Rule 92    fact -> CTES
Rule 93    fact -> cte
Rule 94    fact -> funcCall
Rule 95    fact -> ( expresion )
Rule 96    fact -> ID opAccess
Rule 97    opAccess -> opStruct
Rule 98    opAccess -> opDictionary
Rule 99    opAccess -> empty
Rule 100   opStruct -> [ expresion ] opMatrix
Rule 101   opMatrix -> [ expresion ]
Rule 102   opMatrix -> empty
Rule 103   opDictionary -> . dictIndex
Rule 104   dictIndex -> FIRST
Rule 105   dictIndex -> LAST
Rule 106   cte -> CTED
Rule 107   cte -> CTEF
Rule 108   cte -> TRUE
Rule 109   cte -> FALSE
Rule 110   empty -> <empty>

Terminals, with rules where they appear

(                    : 25 34 50 51 58 68 71 95
)                    : 25 34 50 51 58 68 71 95
*                    : 89
+                    : 85
,                    : 41 61
-                    : 86
.                    : 103
/                    : 90
:                    : 25 71
;                    : 14 30 33 38 39 40 51 51
<                    : 82
=                    : 22 25
>                    : 81
AND                  : 73
BOOL                 : 12
CTED                 : 63 66 106
CTEF                 : 107
CTES                 : 26 92
DICT                 : 40 65
DIF                  : 78
ELSE                 : 69
EQ                   : 77
FALSE                : 109
FIRST                : 104
FLOAT                : 9
FOR                  : 51
FUNC                 : 32
GTOEQ                : 80
ID                   : 1 28 29 32 38 39 40 41 52 58 96
IF                   : 68
INT                  : 8
LAST                 : 105
LTOEQ                : 79
MAIN                 : 13
OBJECT               : 11
OR                   : 74
PROGRAM              : 1
RETURN               : 33
RETURNS              : 36
STRING               : 10
STRUCT               : 39
TRUE                 : 108
VARS                 : 7
WHILE                : 50
[                    : 55 56 63 66 100 101
]                    : 55 56 63 66 100 101
error                : 
{                    : 1 13 36 37 50 51 68 69
}                    : 1 13 32 50 51 68 69

Nonterminals, with rules where they appear

assign               : 17 51 51
assignMatrix         : 55
assignOptions        : 52
basicDeclare         : 19
basicStatements      : 14
body                 : 13 36 37 47 50 51 68 69
condition            : 15
cte                  : 27 93
cyDeclare            : 38 39 40
cyExp                : 84
cyExpresion          : 72
cyInstruction        : 45
cyParam              : 29
cyParamCall          : 59 61
cyTerm               : 88
cyTypeParam          : 29 38
cycle                : 16
declare              : 7 43
dict                 : 40 65
dictDeclare          : 21
dictIndex            : 103
dictType             : 25 25
empty                : 4 6 31 35 42 44 46 57 60 62 67 70 75 83 87 91 99 102
errorProgram         : 1
exp                  : 76 77 78 79 80 81 82
expresion            : 23 33 50 51 55 56 59 61 68 73 74 95 100 101
fact                 : 88 89 90
forCycle             : 48
funcCall             : 18 24 94
function             : 5
init                 : 53 55
initDict             : 54
initWith             : 22
instr                : 47
main                 : 1
opAccess             : 96
opDictionary         : 98
opFunctions          : 1 5
opMatrix             : 100
opParamCall          : 58
opParameters         : 32
opReturns            : 32
opSExp               : 76
opStruct             : 97
opVars               : 1 13 36 37
optionalElse         : 68
optionalMatrix       : 63
param                : 30 34
program              : 0
return               : 36
sExp                 : 72
struct               : 39
structDeclare        : 20
structType           : 63
term                 : 84 85 86
type                 : 29 36 38 64 71 71
vars                 : 3
whileCycle           : 49

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM errorProgram ID { opVars opFunctions main }

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . errorProgram ID { opVars opFunctions main }
    (2) errorProgram -> .

    ID              reduce using rule 2 (errorProgram -> .)

    errorProgram                   shift and go to state 3

state 3

    (1) program -> PROGRAM errorProgram . ID { opVars opFunctions main }

    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM errorProgram ID . { opVars opFunctions main }

    {               shift and go to state 5


state 5

    (1) program -> PROGRAM errorProgram ID { . opVars opFunctions main }
    (3) opVars -> . vars
    (4) opVars -> . empty
    (7) vars -> . VARS declare
    (110) empty -> .

    VARS            shift and go to state 6
    FUNC            reduce using rule 110 (empty -> .)
    MAIN            reduce using rule 110 (empty -> .)

    vars                           shift and go to state 7
    opVars                         shift and go to state 8
    empty                          shift and go to state 9

state 6

    (7) vars -> VARS . declare
    (19) declare -> . basicDeclare
    (20) declare -> . structDeclare
    (21) declare -> . dictDeclare
    (38) basicDeclare -> . type ID cyTypeParam ; cyDeclare
    (39) structDeclare -> . STRUCT ID struct ; cyDeclare
    (40) dictDeclare -> . DICT ID dict ; cyDeclare
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . STRING
    (11) type -> . OBJECT
    (12) type -> . BOOL

    STRUCT          shift and go to state 11
    DICT            shift and go to state 17
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 16
    OBJECT          shift and go to state 15
    BOOL            shift and go to state 18

    dictDeclare                    shift and go to state 10
    type                           shift and go to state 13
    structDeclare                  shift and go to state 19
    basicDeclare                   shift and go to state 20
    declare                        shift and go to state 21

state 7

    (3) opVars -> vars .

    IF              reduce using rule 3 (opVars -> vars .)
    ID              reduce using rule 3 (opVars -> vars .)
    FOR             reduce using rule 3 (opVars -> vars .)
    WHILE           reduce using rule 3 (opVars -> vars .)
    }               reduce using rule 3 (opVars -> vars .)
    FUNC            reduce using rule 3 (opVars -> vars .)
    MAIN            reduce using rule 3 (opVars -> vars .)
    RETURN          reduce using rule 3 (opVars -> vars .)


state 8

    (1) program -> PROGRAM errorProgram ID { opVars . opFunctions main }
    (5) opFunctions -> . function opFunctions
    (6) opFunctions -> . empty
    (32) function -> . FUNC ID opParameters opReturns }
    (110) empty -> .

    FUNC            shift and go to state 23
    MAIN            reduce using rule 110 (empty -> .)

    function                       shift and go to state 22
    empty                          shift and go to state 24
    opFunctions                    shift and go to state 25

state 9

    (4) opVars -> empty .

    IF              reduce using rule 4 (opVars -> empty .)
    ID              reduce using rule 4 (opVars -> empty .)
    FOR             reduce using rule 4 (opVars -> empty .)
    WHILE           reduce using rule 4 (opVars -> empty .)
    }               reduce using rule 4 (opVars -> empty .)
    FUNC            reduce using rule 4 (opVars -> empty .)
    MAIN            reduce using rule 4 (opVars -> empty .)
    RETURN          reduce using rule 4 (opVars -> empty .)


state 10

    (21) declare -> dictDeclare .

    FUNC            reduce using rule 21 (declare -> dictDeclare .)
    MAIN            reduce using rule 21 (declare -> dictDeclare .)
    IF              reduce using rule 21 (declare -> dictDeclare .)
    ID              reduce using rule 21 (declare -> dictDeclare .)
    FOR             reduce using rule 21 (declare -> dictDeclare .)
    WHILE           reduce using rule 21 (declare -> dictDeclare .)
    }               reduce using rule 21 (declare -> dictDeclare .)
    RETURN          reduce using rule 21 (declare -> dictDeclare .)


state 11

    (39) structDeclare -> STRUCT . ID struct ; cyDeclare

    ID              shift and go to state 26


state 12

    (8) type -> INT .

    ID              reduce using rule 8 (type -> INT .)
    [               reduce using rule 8 (type -> INT .)
    )               reduce using rule 8 (type -> INT .)
    :               reduce using rule 8 (type -> INT .)
    {               reduce using rule 8 (type -> INT .)


state 13

    (38) basicDeclare -> type . ID cyTypeParam ; cyDeclare

    ID              shift and go to state 27


state 14

    (9) type -> FLOAT .

    ID              reduce using rule 9 (type -> FLOAT .)
    [               reduce using rule 9 (type -> FLOAT .)
    )               reduce using rule 9 (type -> FLOAT .)
    :               reduce using rule 9 (type -> FLOAT .)
    {               reduce using rule 9 (type -> FLOAT .)


state 15

    (11) type -> OBJECT .

    ID              reduce using rule 11 (type -> OBJECT .)
    [               reduce using rule 11 (type -> OBJECT .)
    )               reduce using rule 11 (type -> OBJECT .)
    :               reduce using rule 11 (type -> OBJECT .)
    {               reduce using rule 11 (type -> OBJECT .)


state 16

    (10) type -> STRING .

    ID              reduce using rule 10 (type -> STRING .)
    [               reduce using rule 10 (type -> STRING .)
    )               reduce using rule 10 (type -> STRING .)
    :               reduce using rule 10 (type -> STRING .)
    {               reduce using rule 10 (type -> STRING .)


state 17

    (40) dictDeclare -> DICT . ID dict ; cyDeclare

    ID              shift and go to state 28


state 18

    (12) type -> BOOL .

    ID              reduce using rule 12 (type -> BOOL .)
    [               reduce using rule 12 (type -> BOOL .)
    )               reduce using rule 12 (type -> BOOL .)
    :               reduce using rule 12 (type -> BOOL .)
    {               reduce using rule 12 (type -> BOOL .)


state 19

    (20) declare -> structDeclare .

    FUNC            reduce using rule 20 (declare -> structDeclare .)
    MAIN            reduce using rule 20 (declare -> structDeclare .)
    IF              reduce using rule 20 (declare -> structDeclare .)
    ID              reduce using rule 20 (declare -> structDeclare .)
    FOR             reduce using rule 20 (declare -> structDeclare .)
    WHILE           reduce using rule 20 (declare -> structDeclare .)
    }               reduce using rule 20 (declare -> structDeclare .)
    RETURN          reduce using rule 20 (declare -> structDeclare .)


state 20

    (19) declare -> basicDeclare .

    FUNC            reduce using rule 19 (declare -> basicDeclare .)
    MAIN            reduce using rule 19 (declare -> basicDeclare .)
    IF              reduce using rule 19 (declare -> basicDeclare .)
    ID              reduce using rule 19 (declare -> basicDeclare .)
    FOR             reduce using rule 19 (declare -> basicDeclare .)
    WHILE           reduce using rule 19 (declare -> basicDeclare .)
    }               reduce using rule 19 (declare -> basicDeclare .)
    RETURN          reduce using rule 19 (declare -> basicDeclare .)


state 21

    (7) vars -> VARS declare .

    IF              reduce using rule 7 (vars -> VARS declare .)
    ID              reduce using rule 7 (vars -> VARS declare .)
    FOR             reduce using rule 7 (vars -> VARS declare .)
    WHILE           reduce using rule 7 (vars -> VARS declare .)
    RETURN          reduce using rule 7 (vars -> VARS declare .)
    FUNC            reduce using rule 7 (vars -> VARS declare .)
    MAIN            reduce using rule 7 (vars -> VARS declare .)
    }               reduce using rule 7 (vars -> VARS declare .)


state 22

    (5) opFunctions -> function . opFunctions
    (5) opFunctions -> . function opFunctions
    (6) opFunctions -> . empty
    (32) function -> . FUNC ID opParameters opReturns }
    (110) empty -> .

    FUNC            shift and go to state 23
    MAIN            reduce using rule 110 (empty -> .)

    function                       shift and go to state 22
    empty                          shift and go to state 24
    opFunctions                    shift and go to state 29

state 23

    (32) function -> FUNC . ID opParameters opReturns }

    ID              shift and go to state 30


state 24

    (6) opFunctions -> empty .

    MAIN            reduce using rule 6 (opFunctions -> empty .)


state 25

    (1) program -> PROGRAM errorProgram ID { opVars opFunctions . main }
    (13) main -> . MAIN { opVars body }

    MAIN            shift and go to state 31

    main                           shift and go to state 32

state 26

    (39) structDeclare -> STRUCT ID . struct ; cyDeclare
    (63) struct -> . structType [ CTED ] optionalMatrix
    (64) structType -> . type
    (65) structType -> . DICT dict
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . STRING
    (11) type -> . OBJECT
    (12) type -> . BOOL

    DICT            shift and go to state 35
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 16
    OBJECT          shift and go to state 15
    BOOL            shift and go to state 18

    structType                     shift and go to state 33
    struct                         shift and go to state 34
    type                           shift and go to state 36

state 27

    (38) basicDeclare -> type ID . cyTypeParam ; cyDeclare
    (41) cyTypeParam -> . , ID
    (42) cyTypeParam -> . empty
    (110) empty -> .

    ,               shift and go to state 37
    ;               reduce using rule 110 (empty -> .)

    cyTypeParam                    shift and go to state 38
    empty                          shift and go to state 39

state 28

    (40) dictDeclare -> DICT ID . dict ; cyDeclare
    (71) dict -> . ( type : type )

    (               shift and go to state 40

    dict                           shift and go to state 41

state 29

    (5) opFunctions -> function opFunctions .

    MAIN            reduce using rule 5 (opFunctions -> function opFunctions .)


state 30

    (32) function -> FUNC ID . opParameters opReturns }
    (34) opParameters -> . ( param )
    (35) opParameters -> . empty
    (110) empty -> .

    (               shift and go to state 42
    RETURNS         reduce using rule 110 (empty -> .)
    {               reduce using rule 110 (empty -> .)

    opParameters                   shift and go to state 43
    empty                          shift and go to state 44

state 31

    (13) main -> MAIN . { opVars body }

    {               shift and go to state 45


state 32

    (1) program -> PROGRAM errorProgram ID { opVars opFunctions main . }

    }               shift and go to state 46


state 33

    (63) struct -> structType . [ CTED ] optionalMatrix

    [               shift and go to state 47


state 34

    (39) structDeclare -> STRUCT ID struct . ; cyDeclare

    ;               shift and go to state 48


state 35

    (65) structType -> DICT . dict
    (71) dict -> . ( type : type )

    (               shift and go to state 40

    dict                           shift and go to state 49

state 36

    (64) structType -> type .

    [               reduce using rule 64 (structType -> type .)


state 37

    (41) cyTypeParam -> , . ID

    ID              shift and go to state 50


state 38

    (38) basicDeclare -> type ID cyTypeParam . ; cyDeclare

    ;               shift and go to state 51


state 39

    (42) cyTypeParam -> empty .

    ;               reduce using rule 42 (cyTypeParam -> empty .)
    )               reduce using rule 42 (cyTypeParam -> empty .)


state 40

    (71) dict -> ( . type : type )
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . STRING
    (11) type -> . OBJECT
    (12) type -> . BOOL

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 16
    OBJECT          shift and go to state 15
    BOOL            shift and go to state 18

    type                           shift and go to state 52

state 41

    (40) dictDeclare -> DICT ID dict . ; cyDeclare

    ;               shift and go to state 53


state 42

    (34) opParameters -> ( . param )
    (29) param -> . type ID cyTypeParam cyParam
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . STRING
    (11) type -> . OBJECT
    (12) type -> . BOOL

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 16
    OBJECT          shift and go to state 15
    BOOL            shift and go to state 18

    type                           shift and go to state 55
    param                          shift and go to state 54

state 43

    (32) function -> FUNC ID opParameters . opReturns }
    (36) opReturns -> . RETURNS type { opVars body return
    (37) opReturns -> . { opVars body

    RETURNS         shift and go to state 56
    {               shift and go to state 57

    opReturns                      shift and go to state 58

state 44

    (35) opParameters -> empty .

    RETURNS         reduce using rule 35 (opParameters -> empty .)
    {               reduce using rule 35 (opParameters -> empty .)


state 45

    (13) main -> MAIN { . opVars body }
    (3) opVars -> . vars
    (4) opVars -> . empty
    (7) vars -> . VARS declare
    (110) empty -> .

    VARS            shift and go to state 6
    IF              reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    FOR             reduce using rule 110 (empty -> .)
    WHILE           reduce using rule 110 (empty -> .)
    }               reduce using rule 110 (empty -> .)

    opVars                         shift and go to state 59
    empty                          shift and go to state 9
    vars                           shift and go to state 7

state 46

    (1) program -> PROGRAM errorProgram ID { opVars opFunctions main } .

    $end            reduce using rule 1 (program -> PROGRAM errorProgram ID { opVars opFunctions main } .)


state 47

    (63) struct -> structType [ . CTED ] optionalMatrix

    CTED            shift and go to state 60


state 48

    (39) structDeclare -> STRUCT ID struct ; . cyDeclare
    (43) cyDeclare -> . declare
    (44) cyDeclare -> . empty
    (19) declare -> . basicDeclare
    (20) declare -> . structDeclare
    (21) declare -> . dictDeclare
    (110) empty -> .
    (38) basicDeclare -> . type ID cyTypeParam ; cyDeclare
    (39) structDeclare -> . STRUCT ID struct ; cyDeclare
    (40) dictDeclare -> . DICT ID dict ; cyDeclare
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . STRING
    (11) type -> . OBJECT
    (12) type -> . BOOL

    FUNC            reduce using rule 110 (empty -> .)
    MAIN            reduce using rule 110 (empty -> .)
    IF              reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    FOR             reduce using rule 110 (empty -> .)
    WHILE           reduce using rule 110 (empty -> .)
    }               reduce using rule 110 (empty -> .)
    RETURN          reduce using rule 110 (empty -> .)
    STRUCT          shift and go to state 11
    DICT            shift and go to state 17
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 16
    OBJECT          shift and go to state 15
    BOOL            shift and go to state 18

    dictDeclare                    shift and go to state 10
    cyDeclare                      shift and go to state 61
    type                           shift and go to state 13
    structDeclare                  shift and go to state 19
    basicDeclare                   shift and go to state 20
    declare                        shift and go to state 62
    empty                          shift and go to state 63

state 49

    (65) structType -> DICT dict .

    [               reduce using rule 65 (structType -> DICT dict .)


state 50

    (41) cyTypeParam -> , ID .

    ;               reduce using rule 41 (cyTypeParam -> , ID .)
    )               reduce using rule 41 (cyTypeParam -> , ID .)


state 51

    (38) basicDeclare -> type ID cyTypeParam ; . cyDeclare
    (43) cyDeclare -> . declare
    (44) cyDeclare -> . empty
    (19) declare -> . basicDeclare
    (20) declare -> . structDeclare
    (21) declare -> . dictDeclare
    (110) empty -> .
    (38) basicDeclare -> . type ID cyTypeParam ; cyDeclare
    (39) structDeclare -> . STRUCT ID struct ; cyDeclare
    (40) dictDeclare -> . DICT ID dict ; cyDeclare
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . STRING
    (11) type -> . OBJECT
    (12) type -> . BOOL

    FUNC            reduce using rule 110 (empty -> .)
    MAIN            reduce using rule 110 (empty -> .)
    IF              reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    FOR             reduce using rule 110 (empty -> .)
    WHILE           reduce using rule 110 (empty -> .)
    }               reduce using rule 110 (empty -> .)
    RETURN          reduce using rule 110 (empty -> .)
    STRUCT          shift and go to state 11
    DICT            shift and go to state 17
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 16
    OBJECT          shift and go to state 15
    BOOL            shift and go to state 18

    dictDeclare                    shift and go to state 10
    cyDeclare                      shift and go to state 64
    type                           shift and go to state 13
    structDeclare                  shift and go to state 19
    basicDeclare                   shift and go to state 20
    declare                        shift and go to state 62
    empty                          shift and go to state 63

state 52

    (71) dict -> ( type . : type )

    :               shift and go to state 65


state 53

    (40) dictDeclare -> DICT ID dict ; . cyDeclare
    (43) cyDeclare -> . declare
    (44) cyDeclare -> . empty
    (19) declare -> . basicDeclare
    (20) declare -> . structDeclare
    (21) declare -> . dictDeclare
    (110) empty -> .
    (38) basicDeclare -> . type ID cyTypeParam ; cyDeclare
    (39) structDeclare -> . STRUCT ID struct ; cyDeclare
    (40) dictDeclare -> . DICT ID dict ; cyDeclare
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . STRING
    (11) type -> . OBJECT
    (12) type -> . BOOL

    FUNC            reduce using rule 110 (empty -> .)
    MAIN            reduce using rule 110 (empty -> .)
    IF              reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    FOR             reduce using rule 110 (empty -> .)
    WHILE           reduce using rule 110 (empty -> .)
    }               reduce using rule 110 (empty -> .)
    RETURN          reduce using rule 110 (empty -> .)
    STRUCT          shift and go to state 11
    DICT            shift and go to state 17
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 16
    OBJECT          shift and go to state 15
    BOOL            shift and go to state 18

    dictDeclare                    shift and go to state 10
    cyDeclare                      shift and go to state 66
    type                           shift and go to state 13
    structDeclare                  shift and go to state 19
    basicDeclare                   shift and go to state 20
    declare                        shift and go to state 62
    empty                          shift and go to state 63

state 54

    (34) opParameters -> ( param . )

    )               shift and go to state 67


state 55

    (29) param -> type . ID cyTypeParam cyParam

    ID              shift and go to state 68


state 56

    (36) opReturns -> RETURNS . type { opVars body return
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . STRING
    (11) type -> . OBJECT
    (12) type -> . BOOL

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 16
    OBJECT          shift and go to state 15
    BOOL            shift and go to state 18

    type                           shift and go to state 69

state 57

    (37) opReturns -> { . opVars body
    (3) opVars -> . vars
    (4) opVars -> . empty
    (7) vars -> . VARS declare
    (110) empty -> .

    VARS            shift and go to state 6
    IF              reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    FOR             reduce using rule 110 (empty -> .)
    WHILE           reduce using rule 110 (empty -> .)
    }               reduce using rule 110 (empty -> .)

    opVars                         shift and go to state 70
    empty                          shift and go to state 9
    vars                           shift and go to state 7

state 58

    (32) function -> FUNC ID opParameters opReturns . }

    }               shift and go to state 71


state 59

    (13) main -> MAIN { opVars . body }
    (45) body -> . cyInstruction
    (46) body -> . empty
    (47) cyInstruction -> . instr body
    (110) empty -> .
    (14) instr -> . basicStatements ;
    (15) instr -> . condition
    (16) instr -> . cycle
    (17) basicStatements -> . assign
    (18) basicStatements -> . funcCall
    (68) condition -> . IF ( expresion ) { body } optionalElse
    (48) cycle -> . forCycle
    (49) cycle -> . whileCycle
    (52) assign -> . ID assignOptions
    (58) funcCall -> . ID ( opParamCall )
    (51) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (50) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 110 (empty -> .)
    IF              shift and go to state 84
    ID              shift and go to state 82
    FOR             shift and go to state 80
    WHILE           shift and go to state 74

    body                           shift and go to state 79
    funcCall                       shift and go to state 85
    instr                          shift and go to state 72
    forCycle                       shift and go to state 75
    assign                         shift and go to state 86
    whileCycle                     shift and go to state 73
    basicStatements                shift and go to state 81
    condition                      shift and go to state 83
    cyInstruction                  shift and go to state 76
    empty                          shift and go to state 78
    cycle                          shift and go to state 77

state 60

    (63) struct -> structType [ CTED . ] optionalMatrix

    ]               shift and go to state 87


state 61

    (39) structDeclare -> STRUCT ID struct ; cyDeclare .

    FUNC            reduce using rule 39 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    MAIN            reduce using rule 39 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    IF              reduce using rule 39 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    ID              reduce using rule 39 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    FOR             reduce using rule 39 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    WHILE           reduce using rule 39 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    }               reduce using rule 39 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    RETURN          reduce using rule 39 (structDeclare -> STRUCT ID struct ; cyDeclare .)


state 62

    (43) cyDeclare -> declare .

    FUNC            reduce using rule 43 (cyDeclare -> declare .)
    MAIN            reduce using rule 43 (cyDeclare -> declare .)
    IF              reduce using rule 43 (cyDeclare -> declare .)
    ID              reduce using rule 43 (cyDeclare -> declare .)
    FOR             reduce using rule 43 (cyDeclare -> declare .)
    WHILE           reduce using rule 43 (cyDeclare -> declare .)
    }               reduce using rule 43 (cyDeclare -> declare .)
    RETURN          reduce using rule 43 (cyDeclare -> declare .)


state 63

    (44) cyDeclare -> empty .

    FUNC            reduce using rule 44 (cyDeclare -> empty .)
    MAIN            reduce using rule 44 (cyDeclare -> empty .)
    IF              reduce using rule 44 (cyDeclare -> empty .)
    ID              reduce using rule 44 (cyDeclare -> empty .)
    FOR             reduce using rule 44 (cyDeclare -> empty .)
    WHILE           reduce using rule 44 (cyDeclare -> empty .)
    }               reduce using rule 44 (cyDeclare -> empty .)
    RETURN          reduce using rule 44 (cyDeclare -> empty .)


state 64

    (38) basicDeclare -> type ID cyTypeParam ; cyDeclare .

    FUNC            reduce using rule 38 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    MAIN            reduce using rule 38 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    IF              reduce using rule 38 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    ID              reduce using rule 38 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    FOR             reduce using rule 38 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    WHILE           reduce using rule 38 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    }               reduce using rule 38 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    RETURN          reduce using rule 38 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)


state 65

    (71) dict -> ( type : . type )
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . STRING
    (11) type -> . OBJECT
    (12) type -> . BOOL

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 16
    OBJECT          shift and go to state 15
    BOOL            shift and go to state 18

    type                           shift and go to state 88

state 66

    (40) dictDeclare -> DICT ID dict ; cyDeclare .

    FUNC            reduce using rule 40 (dictDeclare -> DICT ID dict ; cyDeclare .)
    MAIN            reduce using rule 40 (dictDeclare -> DICT ID dict ; cyDeclare .)
    IF              reduce using rule 40 (dictDeclare -> DICT ID dict ; cyDeclare .)
    ID              reduce using rule 40 (dictDeclare -> DICT ID dict ; cyDeclare .)
    FOR             reduce using rule 40 (dictDeclare -> DICT ID dict ; cyDeclare .)
    WHILE           reduce using rule 40 (dictDeclare -> DICT ID dict ; cyDeclare .)
    }               reduce using rule 40 (dictDeclare -> DICT ID dict ; cyDeclare .)
    RETURN          reduce using rule 40 (dictDeclare -> DICT ID dict ; cyDeclare .)


state 67

    (34) opParameters -> ( param ) .

    RETURNS         reduce using rule 34 (opParameters -> ( param ) .)
    {               reduce using rule 34 (opParameters -> ( param ) .)


state 68

    (29) param -> type ID . cyTypeParam cyParam
    (41) cyTypeParam -> . , ID
    (42) cyTypeParam -> . empty
    (110) empty -> .

    ,               shift and go to state 37
    ;               reduce using rule 110 (empty -> .)
    )               reduce using rule 110 (empty -> .)

    cyTypeParam                    shift and go to state 89
    empty                          shift and go to state 39

state 69

    (36) opReturns -> RETURNS type . { opVars body return

    {               shift and go to state 90


state 70

    (37) opReturns -> { opVars . body
    (45) body -> . cyInstruction
    (46) body -> . empty
    (47) cyInstruction -> . instr body
    (110) empty -> .
    (14) instr -> . basicStatements ;
    (15) instr -> . condition
    (16) instr -> . cycle
    (17) basicStatements -> . assign
    (18) basicStatements -> . funcCall
    (68) condition -> . IF ( expresion ) { body } optionalElse
    (48) cycle -> . forCycle
    (49) cycle -> . whileCycle
    (52) assign -> . ID assignOptions
    (58) funcCall -> . ID ( opParamCall )
    (51) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (50) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 110 (empty -> .)
    IF              shift and go to state 84
    ID              shift and go to state 82
    FOR             shift and go to state 80
    WHILE           shift and go to state 74

    body                           shift and go to state 91
    funcCall                       shift and go to state 85
    instr                          shift and go to state 72
    forCycle                       shift and go to state 75
    assign                         shift and go to state 86
    whileCycle                     shift and go to state 73
    basicStatements                shift and go to state 81
    condition                      shift and go to state 83
    cyInstruction                  shift and go to state 76
    empty                          shift and go to state 78
    cycle                          shift and go to state 77

state 71

    (32) function -> FUNC ID opParameters opReturns } .

    FUNC            reduce using rule 32 (function -> FUNC ID opParameters opReturns } .)
    MAIN            reduce using rule 32 (function -> FUNC ID opParameters opReturns } .)


state 72

    (47) cyInstruction -> instr . body
    (45) body -> . cyInstruction
    (46) body -> . empty
    (47) cyInstruction -> . instr body
    (110) empty -> .
    (14) instr -> . basicStatements ;
    (15) instr -> . condition
    (16) instr -> . cycle
    (17) basicStatements -> . assign
    (18) basicStatements -> . funcCall
    (68) condition -> . IF ( expresion ) { body } optionalElse
    (48) cycle -> . forCycle
    (49) cycle -> . whileCycle
    (52) assign -> . ID assignOptions
    (58) funcCall -> . ID ( opParamCall )
    (51) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (50) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 110 (empty -> .)
    RETURN          reduce using rule 110 (empty -> .)
    IF              shift and go to state 84
    ID              shift and go to state 82
    FOR             shift and go to state 80
    WHILE           shift and go to state 74

    body                           shift and go to state 92
    funcCall                       shift and go to state 85
    instr                          shift and go to state 72
    forCycle                       shift and go to state 75
    assign                         shift and go to state 86
    whileCycle                     shift and go to state 73
    basicStatements                shift and go to state 81
    empty                          shift and go to state 78
    cyInstruction                  shift and go to state 76
    condition                      shift and go to state 83
    cycle                          shift and go to state 77

state 73

    (49) cycle -> whileCycle .

    IF              reduce using rule 49 (cycle -> whileCycle .)
    ID              reduce using rule 49 (cycle -> whileCycle .)
    FOR             reduce using rule 49 (cycle -> whileCycle .)
    WHILE           reduce using rule 49 (cycle -> whileCycle .)
    }               reduce using rule 49 (cycle -> whileCycle .)
    RETURN          reduce using rule 49 (cycle -> whileCycle .)


state 74

    (50) whileCycle -> WHILE . ( expresion ) { body }

    (               shift and go to state 93


state 75

    (48) cycle -> forCycle .

    IF              reduce using rule 48 (cycle -> forCycle .)
    ID              reduce using rule 48 (cycle -> forCycle .)
    FOR             reduce using rule 48 (cycle -> forCycle .)
    WHILE           reduce using rule 48 (cycle -> forCycle .)
    }               reduce using rule 48 (cycle -> forCycle .)
    RETURN          reduce using rule 48 (cycle -> forCycle .)


state 76

    (45) body -> cyInstruction .

    }               reduce using rule 45 (body -> cyInstruction .)
    RETURN          reduce using rule 45 (body -> cyInstruction .)


state 77

    (16) instr -> cycle .

    IF              reduce using rule 16 (instr -> cycle .)
    ID              reduce using rule 16 (instr -> cycle .)
    FOR             reduce using rule 16 (instr -> cycle .)
    WHILE           reduce using rule 16 (instr -> cycle .)
    }               reduce using rule 16 (instr -> cycle .)
    RETURN          reduce using rule 16 (instr -> cycle .)


state 78

    (46) body -> empty .

    }               reduce using rule 46 (body -> empty .)
    RETURN          reduce using rule 46 (body -> empty .)


state 79

    (13) main -> MAIN { opVars body . }

    }               shift and go to state 94


state 80

    (51) forCycle -> FOR . ( assign ; expresion ; assign ) { body }

    (               shift and go to state 95


state 81

    (14) instr -> basicStatements . ;

    ;               shift and go to state 96


state 82

    (52) assign -> ID . assignOptions
    (58) funcCall -> ID . ( opParamCall )
    (53) assignOptions -> . init
    (54) assignOptions -> . initDict
    (55) assignOptions -> . [ expresion ] assignMatrix init
    (22) init -> . = initWith
    (25) initDict -> . = ( dictType : dictType )

    (               shift and go to state 97
    [               shift and go to state 102
    =               shift and go to state 99

    initDict                       shift and go to state 98
    assignOptions                  shift and go to state 100
    init                           shift and go to state 101

state 83

    (15) instr -> condition .

    IF              reduce using rule 15 (instr -> condition .)
    ID              reduce using rule 15 (instr -> condition .)
    FOR             reduce using rule 15 (instr -> condition .)
    WHILE           reduce using rule 15 (instr -> condition .)
    }               reduce using rule 15 (instr -> condition .)
    RETURN          reduce using rule 15 (instr -> condition .)


state 84

    (68) condition -> IF . ( expresion ) { body } optionalElse

    (               shift and go to state 103


state 85

    (18) basicStatements -> funcCall .

    ;               reduce using rule 18 (basicStatements -> funcCall .)


state 86

    (17) basicStatements -> assign .

    ;               reduce using rule 17 (basicStatements -> assign .)


state 87

    (63) struct -> structType [ CTED ] . optionalMatrix
    (66) optionalMatrix -> . [ CTED ]
    (67) optionalMatrix -> . empty
    (110) empty -> .

    [               shift and go to state 105
    ;               reduce using rule 110 (empty -> .)

    empty                          shift and go to state 106
    optionalMatrix                 shift and go to state 104

state 88

    (71) dict -> ( type : type . )

    )               shift and go to state 107


state 89

    (29) param -> type ID cyTypeParam . cyParam
    (30) cyParam -> . ; param
    (31) cyParam -> . empty
    (110) empty -> .

    ;               shift and go to state 108
    )               reduce using rule 110 (empty -> .)

    cyParam                        shift and go to state 109
    empty                          shift and go to state 110

state 90

    (36) opReturns -> RETURNS type { . opVars body return
    (3) opVars -> . vars
    (4) opVars -> . empty
    (7) vars -> . VARS declare
    (110) empty -> .

    VARS            shift and go to state 6
    IF              reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    FOR             reduce using rule 110 (empty -> .)
    WHILE           reduce using rule 110 (empty -> .)
    RETURN          reduce using rule 110 (empty -> .)

    vars                           shift and go to state 7
    opVars                         shift and go to state 111
    empty                          shift and go to state 9

state 91

    (37) opReturns -> { opVars body .

    }               reduce using rule 37 (opReturns -> { opVars body .)


state 92

    (47) cyInstruction -> instr body .

    }               reduce using rule 47 (cyInstruction -> instr body .)
    RETURN          reduce using rule 47 (cyInstruction -> instr body .)


state 93

    (50) whileCycle -> WHILE ( . expresion ) { body }
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 117
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 94

    (13) main -> MAIN { opVars body } .

    }               reduce using rule 13 (main -> MAIN { opVars body } .)


state 95

    (51) forCycle -> FOR ( . assign ; expresion ; assign ) { body }
    (52) assign -> . ID assignOptions

    ID              shift and go to state 126

    assign                         shift and go to state 127

state 96

    (14) instr -> basicStatements ; .

    IF              reduce using rule 14 (instr -> basicStatements ; .)
    ID              reduce using rule 14 (instr -> basicStatements ; .)
    FOR             reduce using rule 14 (instr -> basicStatements ; .)
    WHILE           reduce using rule 14 (instr -> basicStatements ; .)
    }               reduce using rule 14 (instr -> basicStatements ; .)
    RETURN          reduce using rule 14 (instr -> basicStatements ; .)


state 97

    (58) funcCall -> ID ( . opParamCall )
    (59) opParamCall -> . expresion cyParamCall
    (60) opParamCall -> . empty
    (72) expresion -> . sExp cyExpresion
    (110) empty -> .
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    )               reduce using rule 110 (empty -> .)
    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 130
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    fact                           shift and go to state 125
    exp                            shift and go to state 115
    opParamCall                    shift and go to state 128
    empty                          shift and go to state 129

state 98

    (54) assignOptions -> initDict .

    ;               reduce using rule 54 (assignOptions -> initDict .)
    )               reduce using rule 54 (assignOptions -> initDict .)


state 99

    (22) init -> = . initWith
    (25) initDict -> = . ( dictType : dictType )
    (23) initWith -> . expresion
    (24) initWith -> . funcCall
    (72) expresion -> . sExp cyExpresion
    (58) funcCall -> . ID ( opParamCall )
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE

    (               shift and go to state 132
    ID              shift and go to state 133
    CTES            shift and go to state 118
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 134
    initWith                       shift and go to state 131
    funcCall                       shift and go to state 135
    term                           shift and go to state 119
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 100

    (52) assign -> ID assignOptions .

    ;               reduce using rule 52 (assign -> ID assignOptions .)
    )               reduce using rule 52 (assign -> ID assignOptions .)


state 101

    (53) assignOptions -> init .

    ;               reduce using rule 53 (assignOptions -> init .)
    )               reduce using rule 53 (assignOptions -> init .)


state 102

    (55) assignOptions -> [ . expresion ] assignMatrix init
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 136
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 103

    (68) condition -> IF ( . expresion ) { body } optionalElse
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 137
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 104

    (63) struct -> structType [ CTED ] optionalMatrix .

    ;               reduce using rule 63 (struct -> structType [ CTED ] optionalMatrix .)


state 105

    (66) optionalMatrix -> [ . CTED ]

    CTED            shift and go to state 138


state 106

    (67) optionalMatrix -> empty .

    ;               reduce using rule 67 (optionalMatrix -> empty .)


state 107

    (71) dict -> ( type : type ) .

    [               reduce using rule 71 (dict -> ( type : type ) .)
    ;               reduce using rule 71 (dict -> ( type : type ) .)


state 108

    (30) cyParam -> ; . param
    (29) param -> . type ID cyTypeParam cyParam
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . STRING
    (11) type -> . OBJECT
    (12) type -> . BOOL

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    STRING          shift and go to state 16
    OBJECT          shift and go to state 15
    BOOL            shift and go to state 18

    type                           shift and go to state 55
    param                          shift and go to state 139

state 109

    (29) param -> type ID cyTypeParam cyParam .

    )               reduce using rule 29 (param -> type ID cyTypeParam cyParam .)


state 110

    (31) cyParam -> empty .

    )               reduce using rule 31 (cyParam -> empty .)


state 111

    (36) opReturns -> RETURNS type { opVars . body return
    (45) body -> . cyInstruction
    (46) body -> . empty
    (47) cyInstruction -> . instr body
    (110) empty -> .
    (14) instr -> . basicStatements ;
    (15) instr -> . condition
    (16) instr -> . cycle
    (17) basicStatements -> . assign
    (18) basicStatements -> . funcCall
    (68) condition -> . IF ( expresion ) { body } optionalElse
    (48) cycle -> . forCycle
    (49) cycle -> . whileCycle
    (52) assign -> . ID assignOptions
    (58) funcCall -> . ID ( opParamCall )
    (51) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (50) whileCycle -> . WHILE ( expresion ) { body }

    RETURN          reduce using rule 110 (empty -> .)
    IF              shift and go to state 84
    ID              shift and go to state 82
    FOR             shift and go to state 80
    WHILE           shift and go to state 74

    body                           shift and go to state 140
    funcCall                       shift and go to state 85
    instr                          shift and go to state 72
    forCycle                       shift and go to state 75
    assign                         shift and go to state 86
    whileCycle                     shift and go to state 73
    basicStatements                shift and go to state 81
    condition                      shift and go to state 83
    cyInstruction                  shift and go to state 76
    empty                          shift and go to state 78
    cycle                          shift and go to state 77

state 112

    (108) cte -> TRUE .

    +               reduce using rule 108 (cte -> TRUE .)
    -               reduce using rule 108 (cte -> TRUE .)
    EQ              reduce using rule 108 (cte -> TRUE .)
    DIF             reduce using rule 108 (cte -> TRUE .)
    LTOEQ           reduce using rule 108 (cte -> TRUE .)
    GTOEQ           reduce using rule 108 (cte -> TRUE .)
    >               reduce using rule 108 (cte -> TRUE .)
    <               reduce using rule 108 (cte -> TRUE .)
    AND             reduce using rule 108 (cte -> TRUE .)
    OR              reduce using rule 108 (cte -> TRUE .)
    )               reduce using rule 108 (cte -> TRUE .)
    ,               reduce using rule 108 (cte -> TRUE .)
    ;               reduce using rule 108 (cte -> TRUE .)
    ]               reduce using rule 108 (cte -> TRUE .)
    *               reduce using rule 108 (cte -> TRUE .)
    /               reduce using rule 108 (cte -> TRUE .)
    :               reduce using rule 108 (cte -> TRUE .)


state 113

    (95) fact -> ( . expresion )
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 141
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 114

    (72) expresion -> sExp . cyExpresion
    (73) cyExpresion -> . AND expresion
    (74) cyExpresion -> . OR expresion
    (75) cyExpresion -> . empty
    (110) empty -> .

    AND             shift and go to state 142
    OR              shift and go to state 144
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    ;               reduce using rule 110 (empty -> .)
    ]               reduce using rule 110 (empty -> .)

    cyExpresion                    shift and go to state 143
    empty                          shift and go to state 145

state 115

    (76) sExp -> exp . opSExp
    (77) opSExp -> . EQ exp
    (78) opSExp -> . DIF exp
    (79) opSExp -> . LTOEQ exp
    (80) opSExp -> . GTOEQ exp
    (81) opSExp -> . > exp
    (82) opSExp -> . < exp
    (83) opSExp -> . empty
    (110) empty -> .

    EQ              shift and go to state 146
    DIF             shift and go to state 147
    LTOEQ           shift and go to state 150
    GTOEQ           shift and go to state 148
    >               shift and go to state 149
    <               shift and go to state 151
    AND             reduce using rule 110 (empty -> .)
    OR              reduce using rule 110 (empty -> .)
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    ;               reduce using rule 110 (empty -> .)
    ]               reduce using rule 110 (empty -> .)

    empty                          shift and go to state 152
    opSExp                         shift and go to state 153

state 116

    (96) fact -> ID . opAccess
    (58) funcCall -> ID . ( opParamCall )
    (97) opAccess -> . opStruct
    (98) opAccess -> . opDictionary
    (99) opAccess -> . empty
    (100) opStruct -> . [ expresion ] opMatrix
    (103) opDictionary -> . . dictIndex
    (110) empty -> .

    (               shift and go to state 97
    [               shift and go to state 157
    .               shift and go to state 158
    *               reduce using rule 110 (empty -> .)
    /               reduce using rule 110 (empty -> .)
    +               reduce using rule 110 (empty -> .)
    -               reduce using rule 110 (empty -> .)
    EQ              reduce using rule 110 (empty -> .)
    DIF             reduce using rule 110 (empty -> .)
    LTOEQ           reduce using rule 110 (empty -> .)
    GTOEQ           reduce using rule 110 (empty -> .)
    >               reduce using rule 110 (empty -> .)
    <               reduce using rule 110 (empty -> .)
    AND             reduce using rule 110 (empty -> .)
    OR              reduce using rule 110 (empty -> .)
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    ]               reduce using rule 110 (empty -> .)
    ;               reduce using rule 110 (empty -> .)

    opDictionary                   shift and go to state 159
    opStruct                       shift and go to state 154
    opAccess                       shift and go to state 155
    empty                          shift and go to state 156

state 117

    (50) whileCycle -> WHILE ( expresion . ) { body }

    )               shift and go to state 160


state 118

    (92) fact -> CTES .

    *               reduce using rule 92 (fact -> CTES .)
    /               reduce using rule 92 (fact -> CTES .)
    +               reduce using rule 92 (fact -> CTES .)
    -               reduce using rule 92 (fact -> CTES .)
    EQ              reduce using rule 92 (fact -> CTES .)
    DIF             reduce using rule 92 (fact -> CTES .)
    LTOEQ           reduce using rule 92 (fact -> CTES .)
    GTOEQ           reduce using rule 92 (fact -> CTES .)
    >               reduce using rule 92 (fact -> CTES .)
    <               reduce using rule 92 (fact -> CTES .)
    AND             reduce using rule 92 (fact -> CTES .)
    OR              reduce using rule 92 (fact -> CTES .)
    )               reduce using rule 92 (fact -> CTES .)
    ,               reduce using rule 92 (fact -> CTES .)
    ;               reduce using rule 92 (fact -> CTES .)
    ]               reduce using rule 92 (fact -> CTES .)


state 119

    (84) exp -> term . cyExp
    (85) cyExp -> . + term
    (86) cyExp -> . - term
    (87) cyExp -> . empty
    (110) empty -> .

    +               shift and go to state 163
    -               shift and go to state 162
    EQ              reduce using rule 110 (empty -> .)
    DIF             reduce using rule 110 (empty -> .)
    LTOEQ           reduce using rule 110 (empty -> .)
    GTOEQ           reduce using rule 110 (empty -> .)
    >               reduce using rule 110 (empty -> .)
    <               reduce using rule 110 (empty -> .)
    AND             reduce using rule 110 (empty -> .)
    OR              reduce using rule 110 (empty -> .)
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    ;               reduce using rule 110 (empty -> .)
    ]               reduce using rule 110 (empty -> .)

    cyExp                          shift and go to state 161
    empty                          shift and go to state 164

state 120

    (109) cte -> FALSE .

    +               reduce using rule 109 (cte -> FALSE .)
    -               reduce using rule 109 (cte -> FALSE .)
    EQ              reduce using rule 109 (cte -> FALSE .)
    DIF             reduce using rule 109 (cte -> FALSE .)
    LTOEQ           reduce using rule 109 (cte -> FALSE .)
    GTOEQ           reduce using rule 109 (cte -> FALSE .)
    >               reduce using rule 109 (cte -> FALSE .)
    <               reduce using rule 109 (cte -> FALSE .)
    AND             reduce using rule 109 (cte -> FALSE .)
    OR              reduce using rule 109 (cte -> FALSE .)
    )               reduce using rule 109 (cte -> FALSE .)
    ,               reduce using rule 109 (cte -> FALSE .)
    ;               reduce using rule 109 (cte -> FALSE .)
    ]               reduce using rule 109 (cte -> FALSE .)
    *               reduce using rule 109 (cte -> FALSE .)
    /               reduce using rule 109 (cte -> FALSE .)
    :               reduce using rule 109 (cte -> FALSE .)


state 121

    (94) fact -> funcCall .

    *               reduce using rule 94 (fact -> funcCall .)
    /               reduce using rule 94 (fact -> funcCall .)
    +               reduce using rule 94 (fact -> funcCall .)
    -               reduce using rule 94 (fact -> funcCall .)
    EQ              reduce using rule 94 (fact -> funcCall .)
    DIF             reduce using rule 94 (fact -> funcCall .)
    LTOEQ           reduce using rule 94 (fact -> funcCall .)
    GTOEQ           reduce using rule 94 (fact -> funcCall .)
    >               reduce using rule 94 (fact -> funcCall .)
    <               reduce using rule 94 (fact -> funcCall .)
    AND             reduce using rule 94 (fact -> funcCall .)
    OR              reduce using rule 94 (fact -> funcCall .)
    )               reduce using rule 94 (fact -> funcCall .)
    ,               reduce using rule 94 (fact -> funcCall .)
    ;               reduce using rule 94 (fact -> funcCall .)
    ]               reduce using rule 94 (fact -> funcCall .)


state 122

    (93) fact -> cte .

    *               reduce using rule 93 (fact -> cte .)
    /               reduce using rule 93 (fact -> cte .)
    +               reduce using rule 93 (fact -> cte .)
    -               reduce using rule 93 (fact -> cte .)
    EQ              reduce using rule 93 (fact -> cte .)
    DIF             reduce using rule 93 (fact -> cte .)
    LTOEQ           reduce using rule 93 (fact -> cte .)
    GTOEQ           reduce using rule 93 (fact -> cte .)
    >               reduce using rule 93 (fact -> cte .)
    <               reduce using rule 93 (fact -> cte .)
    AND             reduce using rule 93 (fact -> cte .)
    OR              reduce using rule 93 (fact -> cte .)
    )               reduce using rule 93 (fact -> cte .)
    ,               reduce using rule 93 (fact -> cte .)
    ;               reduce using rule 93 (fact -> cte .)
    ]               reduce using rule 93 (fact -> cte .)


state 123

    (107) cte -> CTEF .

    +               reduce using rule 107 (cte -> CTEF .)
    -               reduce using rule 107 (cte -> CTEF .)
    EQ              reduce using rule 107 (cte -> CTEF .)
    DIF             reduce using rule 107 (cte -> CTEF .)
    LTOEQ           reduce using rule 107 (cte -> CTEF .)
    GTOEQ           reduce using rule 107 (cte -> CTEF .)
    >               reduce using rule 107 (cte -> CTEF .)
    <               reduce using rule 107 (cte -> CTEF .)
    AND             reduce using rule 107 (cte -> CTEF .)
    OR              reduce using rule 107 (cte -> CTEF .)
    )               reduce using rule 107 (cte -> CTEF .)
    ,               reduce using rule 107 (cte -> CTEF .)
    ;               reduce using rule 107 (cte -> CTEF .)
    ]               reduce using rule 107 (cte -> CTEF .)
    *               reduce using rule 107 (cte -> CTEF .)
    /               reduce using rule 107 (cte -> CTEF .)
    :               reduce using rule 107 (cte -> CTEF .)


state 124

    (106) cte -> CTED .

    +               reduce using rule 106 (cte -> CTED .)
    -               reduce using rule 106 (cte -> CTED .)
    EQ              reduce using rule 106 (cte -> CTED .)
    DIF             reduce using rule 106 (cte -> CTED .)
    LTOEQ           reduce using rule 106 (cte -> CTED .)
    GTOEQ           reduce using rule 106 (cte -> CTED .)
    >               reduce using rule 106 (cte -> CTED .)
    <               reduce using rule 106 (cte -> CTED .)
    AND             reduce using rule 106 (cte -> CTED .)
    OR              reduce using rule 106 (cte -> CTED .)
    )               reduce using rule 106 (cte -> CTED .)
    ,               reduce using rule 106 (cte -> CTED .)
    ;               reduce using rule 106 (cte -> CTED .)
    ]               reduce using rule 106 (cte -> CTED .)
    *               reduce using rule 106 (cte -> CTED .)
    /               reduce using rule 106 (cte -> CTED .)
    :               reduce using rule 106 (cte -> CTED .)


state 125

    (88) term -> fact . cyTerm
    (89) cyTerm -> . * fact
    (90) cyTerm -> . / fact
    (91) cyTerm -> . empty
    (110) empty -> .

    *               shift and go to state 167
    /               shift and go to state 168
    +               reduce using rule 110 (empty -> .)
    -               reduce using rule 110 (empty -> .)
    EQ              reduce using rule 110 (empty -> .)
    DIF             reduce using rule 110 (empty -> .)
    LTOEQ           reduce using rule 110 (empty -> .)
    GTOEQ           reduce using rule 110 (empty -> .)
    >               reduce using rule 110 (empty -> .)
    <               reduce using rule 110 (empty -> .)
    AND             reduce using rule 110 (empty -> .)
    OR              reduce using rule 110 (empty -> .)
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    ;               reduce using rule 110 (empty -> .)
    ]               reduce using rule 110 (empty -> .)

    cyTerm                         shift and go to state 165
    empty                          shift and go to state 166

state 126

    (52) assign -> ID . assignOptions
    (53) assignOptions -> . init
    (54) assignOptions -> . initDict
    (55) assignOptions -> . [ expresion ] assignMatrix init
    (22) init -> . = initWith
    (25) initDict -> . = ( dictType : dictType )

    [               shift and go to state 102
    =               shift and go to state 99

    initDict                       shift and go to state 98
    assignOptions                  shift and go to state 100
    init                           shift and go to state 101

state 127

    (51) forCycle -> FOR ( assign . ; expresion ; assign ) { body }

    ;               shift and go to state 169


state 128

    (58) funcCall -> ID ( opParamCall . )

    )               shift and go to state 170


state 129

    (60) opParamCall -> empty .

    )               reduce using rule 60 (opParamCall -> empty .)


state 130

    (59) opParamCall -> expresion . cyParamCall
    (61) cyParamCall -> . , expresion cyParamCall
    (62) cyParamCall -> . empty
    (110) empty -> .

    ,               shift and go to state 172
    )               reduce using rule 110 (empty -> .)

    cyParamCall                    shift and go to state 171
    empty                          shift and go to state 173

state 131

    (22) init -> = initWith .

    ;               reduce using rule 22 (init -> = initWith .)
    )               reduce using rule 22 (init -> = initWith .)


state 132

    (25) initDict -> = ( . dictType : dictType )
    (95) fact -> ( . expresion )
    (26) dictType -> . CTES
    (27) dictType -> . cte
    (28) dictType -> . ID
    (72) expresion -> . sExp cyExpresion
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 176
    ID              shift and go to state 175
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120
    (               shift and go to state 113

    dictType                       shift and go to state 174
    expresion                      shift and go to state 141
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 177
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 133

    (58) funcCall -> ID . ( opParamCall )
    (96) fact -> ID . opAccess
    (97) opAccess -> . opStruct
    (98) opAccess -> . opDictionary
    (99) opAccess -> . empty
    (100) opStruct -> . [ expresion ] opMatrix
    (103) opDictionary -> . . dictIndex
    (110) empty -> .

    (               shift and go to state 97
    [               shift and go to state 157
    .               shift and go to state 158
    *               reduce using rule 110 (empty -> .)
    /               reduce using rule 110 (empty -> .)
    +               reduce using rule 110 (empty -> .)
    -               reduce using rule 110 (empty -> .)
    EQ              reduce using rule 110 (empty -> .)
    DIF             reduce using rule 110 (empty -> .)
    LTOEQ           reduce using rule 110 (empty -> .)
    GTOEQ           reduce using rule 110 (empty -> .)
    >               reduce using rule 110 (empty -> .)
    <               reduce using rule 110 (empty -> .)
    AND             reduce using rule 110 (empty -> .)
    OR              reduce using rule 110 (empty -> .)
    ;               reduce using rule 110 (empty -> .)
    )               reduce using rule 110 (empty -> .)

    opDictionary                   shift and go to state 159
    opStruct                       shift and go to state 154
    opAccess                       shift and go to state 155
    empty                          shift and go to state 156

state 134

    (23) initWith -> expresion .

    ;               reduce using rule 23 (initWith -> expresion .)
    )               reduce using rule 23 (initWith -> expresion .)


state 135

    (24) initWith -> funcCall .
    (94) fact -> funcCall .

  ! reduce/reduce conflict for ; resolved using rule 24 (initWith -> funcCall .)
  ! reduce/reduce conflict for ) resolved using rule 24 (initWith -> funcCall .)
    ;               reduce using rule 24 (initWith -> funcCall .)
    )               reduce using rule 24 (initWith -> funcCall .)
    *               reduce using rule 94 (fact -> funcCall .)
    /               reduce using rule 94 (fact -> funcCall .)
    +               reduce using rule 94 (fact -> funcCall .)
    -               reduce using rule 94 (fact -> funcCall .)
    EQ              reduce using rule 94 (fact -> funcCall .)
    DIF             reduce using rule 94 (fact -> funcCall .)
    LTOEQ           reduce using rule 94 (fact -> funcCall .)
    GTOEQ           reduce using rule 94 (fact -> funcCall .)
    >               reduce using rule 94 (fact -> funcCall .)
    <               reduce using rule 94 (fact -> funcCall .)
    AND             reduce using rule 94 (fact -> funcCall .)
    OR              reduce using rule 94 (fact -> funcCall .)

  ! ;               [ reduce using rule 94 (fact -> funcCall .) ]
  ! )               [ reduce using rule 94 (fact -> funcCall .) ]


state 136

    (55) assignOptions -> [ expresion . ] assignMatrix init

    ]               shift and go to state 178


state 137

    (68) condition -> IF ( expresion . ) { body } optionalElse

    )               shift and go to state 179


state 138

    (66) optionalMatrix -> [ CTED . ]

    ]               shift and go to state 180


state 139

    (30) cyParam -> ; param .

    )               reduce using rule 30 (cyParam -> ; param .)


state 140

    (36) opReturns -> RETURNS type { opVars body . return
    (33) return -> . RETURN expresion ;

    RETURN          shift and go to state 182

    return                         shift and go to state 181

state 141

    (95) fact -> ( expresion . )

    )               shift and go to state 183


state 142

    (73) cyExpresion -> AND . expresion
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 184
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 143

    (72) expresion -> sExp cyExpresion .

    ,               reduce using rule 72 (expresion -> sExp cyExpresion .)
    )               reduce using rule 72 (expresion -> sExp cyExpresion .)
    ]               reduce using rule 72 (expresion -> sExp cyExpresion .)
    ;               reduce using rule 72 (expresion -> sExp cyExpresion .)


state 144

    (74) cyExpresion -> OR . expresion
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 185
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 145

    (75) cyExpresion -> empty .

    )               reduce using rule 75 (cyExpresion -> empty .)
    ,               reduce using rule 75 (cyExpresion -> empty .)
    ;               reduce using rule 75 (cyExpresion -> empty .)
    ]               reduce using rule 75 (cyExpresion -> empty .)


state 146

    (77) opSExp -> EQ . exp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    cte                            shift and go to state 122
    exp                            shift and go to state 186
    fact                           shift and go to state 125

state 147

    (78) opSExp -> DIF . exp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    cte                            shift and go to state 122
    exp                            shift and go to state 187
    fact                           shift and go to state 125

state 148

    (80) opSExp -> GTOEQ . exp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    cte                            shift and go to state 122
    exp                            shift and go to state 188
    fact                           shift and go to state 125

state 149

    (81) opSExp -> > . exp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    cte                            shift and go to state 122
    exp                            shift and go to state 189
    fact                           shift and go to state 125

state 150

    (79) opSExp -> LTOEQ . exp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    cte                            shift and go to state 122
    exp                            shift and go to state 190
    fact                           shift and go to state 125

state 151

    (82) opSExp -> < . exp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    cte                            shift and go to state 122
    exp                            shift and go to state 191
    fact                           shift and go to state 125

state 152

    (83) opSExp -> empty .

    AND             reduce using rule 83 (opSExp -> empty .)
    OR              reduce using rule 83 (opSExp -> empty .)
    )               reduce using rule 83 (opSExp -> empty .)
    ,               reduce using rule 83 (opSExp -> empty .)
    ;               reduce using rule 83 (opSExp -> empty .)
    ]               reduce using rule 83 (opSExp -> empty .)


state 153

    (76) sExp -> exp opSExp .

    AND             reduce using rule 76 (sExp -> exp opSExp .)
    OR              reduce using rule 76 (sExp -> exp opSExp .)
    )               reduce using rule 76 (sExp -> exp opSExp .)
    ,               reduce using rule 76 (sExp -> exp opSExp .)
    ;               reduce using rule 76 (sExp -> exp opSExp .)
    ]               reduce using rule 76 (sExp -> exp opSExp .)


state 154

    (97) opAccess -> opStruct .

    *               reduce using rule 97 (opAccess -> opStruct .)
    /               reduce using rule 97 (opAccess -> opStruct .)
    +               reduce using rule 97 (opAccess -> opStruct .)
    -               reduce using rule 97 (opAccess -> opStruct .)
    EQ              reduce using rule 97 (opAccess -> opStruct .)
    DIF             reduce using rule 97 (opAccess -> opStruct .)
    LTOEQ           reduce using rule 97 (opAccess -> opStruct .)
    GTOEQ           reduce using rule 97 (opAccess -> opStruct .)
    >               reduce using rule 97 (opAccess -> opStruct .)
    <               reduce using rule 97 (opAccess -> opStruct .)
    AND             reduce using rule 97 (opAccess -> opStruct .)
    OR              reduce using rule 97 (opAccess -> opStruct .)
    )               reduce using rule 97 (opAccess -> opStruct .)
    ,               reduce using rule 97 (opAccess -> opStruct .)
    ]               reduce using rule 97 (opAccess -> opStruct .)
    ;               reduce using rule 97 (opAccess -> opStruct .)


state 155

    (96) fact -> ID opAccess .

    *               reduce using rule 96 (fact -> ID opAccess .)
    /               reduce using rule 96 (fact -> ID opAccess .)
    +               reduce using rule 96 (fact -> ID opAccess .)
    -               reduce using rule 96 (fact -> ID opAccess .)
    EQ              reduce using rule 96 (fact -> ID opAccess .)
    DIF             reduce using rule 96 (fact -> ID opAccess .)
    LTOEQ           reduce using rule 96 (fact -> ID opAccess .)
    GTOEQ           reduce using rule 96 (fact -> ID opAccess .)
    >               reduce using rule 96 (fact -> ID opAccess .)
    <               reduce using rule 96 (fact -> ID opAccess .)
    AND             reduce using rule 96 (fact -> ID opAccess .)
    OR              reduce using rule 96 (fact -> ID opAccess .)
    )               reduce using rule 96 (fact -> ID opAccess .)
    ,               reduce using rule 96 (fact -> ID opAccess .)
    ;               reduce using rule 96 (fact -> ID opAccess .)
    ]               reduce using rule 96 (fact -> ID opAccess .)


state 156

    (99) opAccess -> empty .

    *               reduce using rule 99 (opAccess -> empty .)
    /               reduce using rule 99 (opAccess -> empty .)
    +               reduce using rule 99 (opAccess -> empty .)
    -               reduce using rule 99 (opAccess -> empty .)
    EQ              reduce using rule 99 (opAccess -> empty .)
    DIF             reduce using rule 99 (opAccess -> empty .)
    LTOEQ           reduce using rule 99 (opAccess -> empty .)
    GTOEQ           reduce using rule 99 (opAccess -> empty .)
    >               reduce using rule 99 (opAccess -> empty .)
    <               reduce using rule 99 (opAccess -> empty .)
    AND             reduce using rule 99 (opAccess -> empty .)
    OR              reduce using rule 99 (opAccess -> empty .)
    )               reduce using rule 99 (opAccess -> empty .)
    ,               reduce using rule 99 (opAccess -> empty .)
    ]               reduce using rule 99 (opAccess -> empty .)
    ;               reduce using rule 99 (opAccess -> empty .)


state 157

    (100) opStruct -> [ . expresion ] opMatrix
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 192
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 158

    (103) opDictionary -> . . dictIndex
    (104) dictIndex -> . FIRST
    (105) dictIndex -> . LAST

    FIRST           shift and go to state 193
    LAST            shift and go to state 194

    dictIndex                      shift and go to state 195

state 159

    (98) opAccess -> opDictionary .

    *               reduce using rule 98 (opAccess -> opDictionary .)
    /               reduce using rule 98 (opAccess -> opDictionary .)
    +               reduce using rule 98 (opAccess -> opDictionary .)
    -               reduce using rule 98 (opAccess -> opDictionary .)
    EQ              reduce using rule 98 (opAccess -> opDictionary .)
    DIF             reduce using rule 98 (opAccess -> opDictionary .)
    LTOEQ           reduce using rule 98 (opAccess -> opDictionary .)
    GTOEQ           reduce using rule 98 (opAccess -> opDictionary .)
    >               reduce using rule 98 (opAccess -> opDictionary .)
    <               reduce using rule 98 (opAccess -> opDictionary .)
    AND             reduce using rule 98 (opAccess -> opDictionary .)
    OR              reduce using rule 98 (opAccess -> opDictionary .)
    )               reduce using rule 98 (opAccess -> opDictionary .)
    ,               reduce using rule 98 (opAccess -> opDictionary .)
    ]               reduce using rule 98 (opAccess -> opDictionary .)
    ;               reduce using rule 98 (opAccess -> opDictionary .)


state 160

    (50) whileCycle -> WHILE ( expresion ) . { body }

    {               shift and go to state 196


state 161

    (84) exp -> term cyExp .

    EQ              reduce using rule 84 (exp -> term cyExp .)
    DIF             reduce using rule 84 (exp -> term cyExp .)
    LTOEQ           reduce using rule 84 (exp -> term cyExp .)
    GTOEQ           reduce using rule 84 (exp -> term cyExp .)
    >               reduce using rule 84 (exp -> term cyExp .)
    <               reduce using rule 84 (exp -> term cyExp .)
    AND             reduce using rule 84 (exp -> term cyExp .)
    OR              reduce using rule 84 (exp -> term cyExp .)
    )               reduce using rule 84 (exp -> term cyExp .)
    ;               reduce using rule 84 (exp -> term cyExp .)
    ,               reduce using rule 84 (exp -> term cyExp .)
    ]               reduce using rule 84 (exp -> term cyExp .)


state 162

    (86) cyExp -> - . term
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    term                           shift and go to state 197
    funcCall                       shift and go to state 121
    cte                            shift and go to state 122
    fact                           shift and go to state 125

state 163

    (85) cyExp -> + . term
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    term                           shift and go to state 198
    funcCall                       shift and go to state 121
    cte                            shift and go to state 122
    fact                           shift and go to state 125

state 164

    (87) cyExp -> empty .

    EQ              reduce using rule 87 (cyExp -> empty .)
    DIF             reduce using rule 87 (cyExp -> empty .)
    LTOEQ           reduce using rule 87 (cyExp -> empty .)
    GTOEQ           reduce using rule 87 (cyExp -> empty .)
    >               reduce using rule 87 (cyExp -> empty .)
    <               reduce using rule 87 (cyExp -> empty .)
    AND             reduce using rule 87 (cyExp -> empty .)
    OR              reduce using rule 87 (cyExp -> empty .)
    )               reduce using rule 87 (cyExp -> empty .)
    ,               reduce using rule 87 (cyExp -> empty .)
    ;               reduce using rule 87 (cyExp -> empty .)
    ]               reduce using rule 87 (cyExp -> empty .)


state 165

    (88) term -> fact cyTerm .

    EQ              reduce using rule 88 (term -> fact cyTerm .)
    DIF             reduce using rule 88 (term -> fact cyTerm .)
    LTOEQ           reduce using rule 88 (term -> fact cyTerm .)
    GTOEQ           reduce using rule 88 (term -> fact cyTerm .)
    >               reduce using rule 88 (term -> fact cyTerm .)
    <               reduce using rule 88 (term -> fact cyTerm .)
    AND             reduce using rule 88 (term -> fact cyTerm .)
    OR              reduce using rule 88 (term -> fact cyTerm .)
    )               reduce using rule 88 (term -> fact cyTerm .)
    ,               reduce using rule 88 (term -> fact cyTerm .)
    ;               reduce using rule 88 (term -> fact cyTerm .)
    ]               reduce using rule 88 (term -> fact cyTerm .)
    +               reduce using rule 88 (term -> fact cyTerm .)
    -               reduce using rule 88 (term -> fact cyTerm .)


state 166

    (91) cyTerm -> empty .

    +               reduce using rule 91 (cyTerm -> empty .)
    -               reduce using rule 91 (cyTerm -> empty .)
    EQ              reduce using rule 91 (cyTerm -> empty .)
    DIF             reduce using rule 91 (cyTerm -> empty .)
    LTOEQ           reduce using rule 91 (cyTerm -> empty .)
    GTOEQ           reduce using rule 91 (cyTerm -> empty .)
    >               reduce using rule 91 (cyTerm -> empty .)
    <               reduce using rule 91 (cyTerm -> empty .)
    AND             reduce using rule 91 (cyTerm -> empty .)
    OR              reduce using rule 91 (cyTerm -> empty .)
    )               reduce using rule 91 (cyTerm -> empty .)
    ,               reduce using rule 91 (cyTerm -> empty .)
    ;               reduce using rule 91 (cyTerm -> empty .)
    ]               reduce using rule 91 (cyTerm -> empty .)


state 167

    (89) cyTerm -> * . fact
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    funcCall                       shift and go to state 121
    cte                            shift and go to state 122
    fact                           shift and go to state 199

state 168

    (90) cyTerm -> / . fact
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    funcCall                       shift and go to state 121
    cte                            shift and go to state 122
    fact                           shift and go to state 200

state 169

    (51) forCycle -> FOR ( assign ; . expresion ; assign ) { body }
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 201
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 170

    (58) funcCall -> ID ( opParamCall ) .

    *               reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    /               reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    +               reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    -               reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    EQ              reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    DIF             reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    LTOEQ           reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    GTOEQ           reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    >               reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    <               reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    AND             reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    OR              reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    ]               reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    )               reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    ,               reduce using rule 58 (funcCall -> ID ( opParamCall ) .)
    ;               reduce using rule 58 (funcCall -> ID ( opParamCall ) .)


state 171

    (59) opParamCall -> expresion cyParamCall .

    )               reduce using rule 59 (opParamCall -> expresion cyParamCall .)


state 172

    (61) cyParamCall -> , . expresion cyParamCall
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 202
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 173

    (62) cyParamCall -> empty .

    )               reduce using rule 62 (cyParamCall -> empty .)


state 174

    (25) initDict -> = ( dictType . : dictType )

    :               shift and go to state 203


state 175

    (28) dictType -> ID .
    (96) fact -> ID . opAccess
    (58) funcCall -> ID . ( opParamCall )
    (97) opAccess -> . opStruct
    (98) opAccess -> . opDictionary
    (99) opAccess -> . empty
    (100) opStruct -> . [ expresion ] opMatrix
    (103) opDictionary -> . . dictIndex
    (110) empty -> .

    :               reduce using rule 28 (dictType -> ID .)
    (               shift and go to state 97
    [               shift and go to state 157
    .               shift and go to state 158
    *               reduce using rule 110 (empty -> .)
    /               reduce using rule 110 (empty -> .)
    +               reduce using rule 110 (empty -> .)
    -               reduce using rule 110 (empty -> .)
    EQ              reduce using rule 110 (empty -> .)
    DIF             reduce using rule 110 (empty -> .)
    LTOEQ           reduce using rule 110 (empty -> .)
    GTOEQ           reduce using rule 110 (empty -> .)
    >               reduce using rule 110 (empty -> .)
    <               reduce using rule 110 (empty -> .)
    AND             reduce using rule 110 (empty -> .)
    OR              reduce using rule 110 (empty -> .)
    )               reduce using rule 110 (empty -> .)

    opDictionary                   shift and go to state 159
    opStruct                       shift and go to state 154
    opAccess                       shift and go to state 155
    empty                          shift and go to state 156

state 176

    (26) dictType -> CTES .
    (92) fact -> CTES .

    :               reduce using rule 26 (dictType -> CTES .)
    *               reduce using rule 92 (fact -> CTES .)
    /               reduce using rule 92 (fact -> CTES .)
    +               reduce using rule 92 (fact -> CTES .)
    -               reduce using rule 92 (fact -> CTES .)
    EQ              reduce using rule 92 (fact -> CTES .)
    DIF             reduce using rule 92 (fact -> CTES .)
    LTOEQ           reduce using rule 92 (fact -> CTES .)
    GTOEQ           reduce using rule 92 (fact -> CTES .)
    >               reduce using rule 92 (fact -> CTES .)
    <               reduce using rule 92 (fact -> CTES .)
    AND             reduce using rule 92 (fact -> CTES .)
    OR              reduce using rule 92 (fact -> CTES .)
    )               reduce using rule 92 (fact -> CTES .)


state 177

    (27) dictType -> cte .
    (93) fact -> cte .

    :               reduce using rule 27 (dictType -> cte .)
    *               reduce using rule 93 (fact -> cte .)
    /               reduce using rule 93 (fact -> cte .)
    +               reduce using rule 93 (fact -> cte .)
    -               reduce using rule 93 (fact -> cte .)
    EQ              reduce using rule 93 (fact -> cte .)
    DIF             reduce using rule 93 (fact -> cte .)
    LTOEQ           reduce using rule 93 (fact -> cte .)
    GTOEQ           reduce using rule 93 (fact -> cte .)
    >               reduce using rule 93 (fact -> cte .)
    <               reduce using rule 93 (fact -> cte .)
    AND             reduce using rule 93 (fact -> cte .)
    OR              reduce using rule 93 (fact -> cte .)
    )               reduce using rule 93 (fact -> cte .)


state 178

    (55) assignOptions -> [ expresion ] . assignMatrix init
    (56) assignMatrix -> . [ expresion ]
    (57) assignMatrix -> . empty
    (110) empty -> .

    [               shift and go to state 205
    =               reduce using rule 110 (empty -> .)

    assignMatrix                   shift and go to state 204
    empty                          shift and go to state 206

state 179

    (68) condition -> IF ( expresion ) . { body } optionalElse

    {               shift and go to state 207


state 180

    (66) optionalMatrix -> [ CTED ] .

    ;               reduce using rule 66 (optionalMatrix -> [ CTED ] .)


state 181

    (36) opReturns -> RETURNS type { opVars body return .

    }               reduce using rule 36 (opReturns -> RETURNS type { opVars body return .)


state 182

    (33) return -> RETURN . expresion ;
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 208
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 183

    (95) fact -> ( expresion ) .

    *               reduce using rule 95 (fact -> ( expresion ) .)
    /               reduce using rule 95 (fact -> ( expresion ) .)
    +               reduce using rule 95 (fact -> ( expresion ) .)
    -               reduce using rule 95 (fact -> ( expresion ) .)
    EQ              reduce using rule 95 (fact -> ( expresion ) .)
    DIF             reduce using rule 95 (fact -> ( expresion ) .)
    LTOEQ           reduce using rule 95 (fact -> ( expresion ) .)
    GTOEQ           reduce using rule 95 (fact -> ( expresion ) .)
    >               reduce using rule 95 (fact -> ( expresion ) .)
    <               reduce using rule 95 (fact -> ( expresion ) .)
    AND             reduce using rule 95 (fact -> ( expresion ) .)
    OR              reduce using rule 95 (fact -> ( expresion ) .)
    )               reduce using rule 95 (fact -> ( expresion ) .)
    ,               reduce using rule 95 (fact -> ( expresion ) .)
    ;               reduce using rule 95 (fact -> ( expresion ) .)
    ]               reduce using rule 95 (fact -> ( expresion ) .)


state 184

    (73) cyExpresion -> AND expresion .

    )               reduce using rule 73 (cyExpresion -> AND expresion .)
    ,               reduce using rule 73 (cyExpresion -> AND expresion .)
    ;               reduce using rule 73 (cyExpresion -> AND expresion .)
    ]               reduce using rule 73 (cyExpresion -> AND expresion .)


state 185

    (74) cyExpresion -> OR expresion .

    )               reduce using rule 74 (cyExpresion -> OR expresion .)
    ,               reduce using rule 74 (cyExpresion -> OR expresion .)
    ;               reduce using rule 74 (cyExpresion -> OR expresion .)
    ]               reduce using rule 74 (cyExpresion -> OR expresion .)


state 186

    (77) opSExp -> EQ exp .

    AND             reduce using rule 77 (opSExp -> EQ exp .)
    OR              reduce using rule 77 (opSExp -> EQ exp .)
    )               reduce using rule 77 (opSExp -> EQ exp .)
    ,               reduce using rule 77 (opSExp -> EQ exp .)
    ;               reduce using rule 77 (opSExp -> EQ exp .)
    ]               reduce using rule 77 (opSExp -> EQ exp .)


state 187

    (78) opSExp -> DIF exp .

    AND             reduce using rule 78 (opSExp -> DIF exp .)
    OR              reduce using rule 78 (opSExp -> DIF exp .)
    )               reduce using rule 78 (opSExp -> DIF exp .)
    ,               reduce using rule 78 (opSExp -> DIF exp .)
    ;               reduce using rule 78 (opSExp -> DIF exp .)
    ]               reduce using rule 78 (opSExp -> DIF exp .)


state 188

    (80) opSExp -> GTOEQ exp .

    AND             reduce using rule 80 (opSExp -> GTOEQ exp .)
    OR              reduce using rule 80 (opSExp -> GTOEQ exp .)
    )               reduce using rule 80 (opSExp -> GTOEQ exp .)
    ,               reduce using rule 80 (opSExp -> GTOEQ exp .)
    ;               reduce using rule 80 (opSExp -> GTOEQ exp .)
    ]               reduce using rule 80 (opSExp -> GTOEQ exp .)


state 189

    (81) opSExp -> > exp .

    AND             reduce using rule 81 (opSExp -> > exp .)
    OR              reduce using rule 81 (opSExp -> > exp .)
    )               reduce using rule 81 (opSExp -> > exp .)
    ,               reduce using rule 81 (opSExp -> > exp .)
    ;               reduce using rule 81 (opSExp -> > exp .)
    ]               reduce using rule 81 (opSExp -> > exp .)


state 190

    (79) opSExp -> LTOEQ exp .

    AND             reduce using rule 79 (opSExp -> LTOEQ exp .)
    OR              reduce using rule 79 (opSExp -> LTOEQ exp .)
    )               reduce using rule 79 (opSExp -> LTOEQ exp .)
    ,               reduce using rule 79 (opSExp -> LTOEQ exp .)
    ;               reduce using rule 79 (opSExp -> LTOEQ exp .)
    ]               reduce using rule 79 (opSExp -> LTOEQ exp .)


state 191

    (82) opSExp -> < exp .

    AND             reduce using rule 82 (opSExp -> < exp .)
    OR              reduce using rule 82 (opSExp -> < exp .)
    )               reduce using rule 82 (opSExp -> < exp .)
    ,               reduce using rule 82 (opSExp -> < exp .)
    ;               reduce using rule 82 (opSExp -> < exp .)
    ]               reduce using rule 82 (opSExp -> < exp .)


state 192

    (100) opStruct -> [ expresion . ] opMatrix

    ]               shift and go to state 209


state 193

    (104) dictIndex -> FIRST .

    *               reduce using rule 104 (dictIndex -> FIRST .)
    /               reduce using rule 104 (dictIndex -> FIRST .)
    +               reduce using rule 104 (dictIndex -> FIRST .)
    -               reduce using rule 104 (dictIndex -> FIRST .)
    EQ              reduce using rule 104 (dictIndex -> FIRST .)
    DIF             reduce using rule 104 (dictIndex -> FIRST .)
    LTOEQ           reduce using rule 104 (dictIndex -> FIRST .)
    GTOEQ           reduce using rule 104 (dictIndex -> FIRST .)
    >               reduce using rule 104 (dictIndex -> FIRST .)
    <               reduce using rule 104 (dictIndex -> FIRST .)
    AND             reduce using rule 104 (dictIndex -> FIRST .)
    OR              reduce using rule 104 (dictIndex -> FIRST .)
    )               reduce using rule 104 (dictIndex -> FIRST .)
    ,               reduce using rule 104 (dictIndex -> FIRST .)
    ]               reduce using rule 104 (dictIndex -> FIRST .)
    ;               reduce using rule 104 (dictIndex -> FIRST .)


state 194

    (105) dictIndex -> LAST .

    *               reduce using rule 105 (dictIndex -> LAST .)
    /               reduce using rule 105 (dictIndex -> LAST .)
    +               reduce using rule 105 (dictIndex -> LAST .)
    -               reduce using rule 105 (dictIndex -> LAST .)
    EQ              reduce using rule 105 (dictIndex -> LAST .)
    DIF             reduce using rule 105 (dictIndex -> LAST .)
    LTOEQ           reduce using rule 105 (dictIndex -> LAST .)
    GTOEQ           reduce using rule 105 (dictIndex -> LAST .)
    >               reduce using rule 105 (dictIndex -> LAST .)
    <               reduce using rule 105 (dictIndex -> LAST .)
    AND             reduce using rule 105 (dictIndex -> LAST .)
    OR              reduce using rule 105 (dictIndex -> LAST .)
    )               reduce using rule 105 (dictIndex -> LAST .)
    ,               reduce using rule 105 (dictIndex -> LAST .)
    ]               reduce using rule 105 (dictIndex -> LAST .)
    ;               reduce using rule 105 (dictIndex -> LAST .)


state 195

    (103) opDictionary -> . dictIndex .

    *               reduce using rule 103 (opDictionary -> . dictIndex .)
    /               reduce using rule 103 (opDictionary -> . dictIndex .)
    +               reduce using rule 103 (opDictionary -> . dictIndex .)
    -               reduce using rule 103 (opDictionary -> . dictIndex .)
    EQ              reduce using rule 103 (opDictionary -> . dictIndex .)
    DIF             reduce using rule 103 (opDictionary -> . dictIndex .)
    LTOEQ           reduce using rule 103 (opDictionary -> . dictIndex .)
    GTOEQ           reduce using rule 103 (opDictionary -> . dictIndex .)
    >               reduce using rule 103 (opDictionary -> . dictIndex .)
    <               reduce using rule 103 (opDictionary -> . dictIndex .)
    AND             reduce using rule 103 (opDictionary -> . dictIndex .)
    OR              reduce using rule 103 (opDictionary -> . dictIndex .)
    )               reduce using rule 103 (opDictionary -> . dictIndex .)
    ;               reduce using rule 103 (opDictionary -> . dictIndex .)
    ,               reduce using rule 103 (opDictionary -> . dictIndex .)
    ]               reduce using rule 103 (opDictionary -> . dictIndex .)


state 196

    (50) whileCycle -> WHILE ( expresion ) { . body }
    (45) body -> . cyInstruction
    (46) body -> . empty
    (47) cyInstruction -> . instr body
    (110) empty -> .
    (14) instr -> . basicStatements ;
    (15) instr -> . condition
    (16) instr -> . cycle
    (17) basicStatements -> . assign
    (18) basicStatements -> . funcCall
    (68) condition -> . IF ( expresion ) { body } optionalElse
    (48) cycle -> . forCycle
    (49) cycle -> . whileCycle
    (52) assign -> . ID assignOptions
    (58) funcCall -> . ID ( opParamCall )
    (51) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (50) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 110 (empty -> .)
    IF              shift and go to state 84
    ID              shift and go to state 82
    FOR             shift and go to state 80
    WHILE           shift and go to state 74

    body                           shift and go to state 210
    funcCall                       shift and go to state 85
    instr                          shift and go to state 72
    forCycle                       shift and go to state 75
    assign                         shift and go to state 86
    whileCycle                     shift and go to state 73
    basicStatements                shift and go to state 81
    condition                      shift and go to state 83
    cyInstruction                  shift and go to state 76
    empty                          shift and go to state 78
    cycle                          shift and go to state 77

state 197

    (86) cyExp -> - term .

    EQ              reduce using rule 86 (cyExp -> - term .)
    DIF             reduce using rule 86 (cyExp -> - term .)
    LTOEQ           reduce using rule 86 (cyExp -> - term .)
    GTOEQ           reduce using rule 86 (cyExp -> - term .)
    >               reduce using rule 86 (cyExp -> - term .)
    <               reduce using rule 86 (cyExp -> - term .)
    AND             reduce using rule 86 (cyExp -> - term .)
    OR              reduce using rule 86 (cyExp -> - term .)
    )               reduce using rule 86 (cyExp -> - term .)
    ,               reduce using rule 86 (cyExp -> - term .)
    ;               reduce using rule 86 (cyExp -> - term .)
    ]               reduce using rule 86 (cyExp -> - term .)


state 198

    (85) cyExp -> + term .

    EQ              reduce using rule 85 (cyExp -> + term .)
    DIF             reduce using rule 85 (cyExp -> + term .)
    LTOEQ           reduce using rule 85 (cyExp -> + term .)
    GTOEQ           reduce using rule 85 (cyExp -> + term .)
    >               reduce using rule 85 (cyExp -> + term .)
    <               reduce using rule 85 (cyExp -> + term .)
    AND             reduce using rule 85 (cyExp -> + term .)
    OR              reduce using rule 85 (cyExp -> + term .)
    )               reduce using rule 85 (cyExp -> + term .)
    ,               reduce using rule 85 (cyExp -> + term .)
    ;               reduce using rule 85 (cyExp -> + term .)
    ]               reduce using rule 85 (cyExp -> + term .)


state 199

    (89) cyTerm -> * fact .

    +               reduce using rule 89 (cyTerm -> * fact .)
    -               reduce using rule 89 (cyTerm -> * fact .)
    EQ              reduce using rule 89 (cyTerm -> * fact .)
    DIF             reduce using rule 89 (cyTerm -> * fact .)
    LTOEQ           reduce using rule 89 (cyTerm -> * fact .)
    GTOEQ           reduce using rule 89 (cyTerm -> * fact .)
    >               reduce using rule 89 (cyTerm -> * fact .)
    <               reduce using rule 89 (cyTerm -> * fact .)
    AND             reduce using rule 89 (cyTerm -> * fact .)
    OR              reduce using rule 89 (cyTerm -> * fact .)
    )               reduce using rule 89 (cyTerm -> * fact .)
    ,               reduce using rule 89 (cyTerm -> * fact .)
    ;               reduce using rule 89 (cyTerm -> * fact .)
    ]               reduce using rule 89 (cyTerm -> * fact .)


state 200

    (90) cyTerm -> / fact .

    +               reduce using rule 90 (cyTerm -> / fact .)
    -               reduce using rule 90 (cyTerm -> / fact .)
    EQ              reduce using rule 90 (cyTerm -> / fact .)
    DIF             reduce using rule 90 (cyTerm -> / fact .)
    LTOEQ           reduce using rule 90 (cyTerm -> / fact .)
    GTOEQ           reduce using rule 90 (cyTerm -> / fact .)
    >               reduce using rule 90 (cyTerm -> / fact .)
    <               reduce using rule 90 (cyTerm -> / fact .)
    AND             reduce using rule 90 (cyTerm -> / fact .)
    OR              reduce using rule 90 (cyTerm -> / fact .)
    )               reduce using rule 90 (cyTerm -> / fact .)
    ,               reduce using rule 90 (cyTerm -> / fact .)
    ;               reduce using rule 90 (cyTerm -> / fact .)
    ]               reduce using rule 90 (cyTerm -> / fact .)


state 201

    (51) forCycle -> FOR ( assign ; expresion . ; assign ) { body }

    ;               shift and go to state 211


state 202

    (61) cyParamCall -> , expresion . cyParamCall
    (61) cyParamCall -> . , expresion cyParamCall
    (62) cyParamCall -> . empty
    (110) empty -> .

    ,               shift and go to state 172
    )               reduce using rule 110 (empty -> .)

    cyParamCall                    shift and go to state 212
    empty                          shift and go to state 173

state 203

    (25) initDict -> = ( dictType : . dictType )
    (26) dictType -> . CTES
    (27) dictType -> . cte
    (28) dictType -> . ID
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE

    CTES            shift and go to state 214
    ID              shift and go to state 216
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    dictType                       shift and go to state 213
    cte                            shift and go to state 215

state 204

    (55) assignOptions -> [ expresion ] assignMatrix . init
    (22) init -> . = initWith

    =               shift and go to state 218

    init                           shift and go to state 217

state 205

    (56) assignMatrix -> [ . expresion ]
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 219
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 206

    (57) assignMatrix -> empty .

    =               reduce using rule 57 (assignMatrix -> empty .)


state 207

    (68) condition -> IF ( expresion ) { . body } optionalElse
    (45) body -> . cyInstruction
    (46) body -> . empty
    (47) cyInstruction -> . instr body
    (110) empty -> .
    (14) instr -> . basicStatements ;
    (15) instr -> . condition
    (16) instr -> . cycle
    (17) basicStatements -> . assign
    (18) basicStatements -> . funcCall
    (68) condition -> . IF ( expresion ) { body } optionalElse
    (48) cycle -> . forCycle
    (49) cycle -> . whileCycle
    (52) assign -> . ID assignOptions
    (58) funcCall -> . ID ( opParamCall )
    (51) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (50) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 110 (empty -> .)
    IF              shift and go to state 84
    ID              shift and go to state 82
    FOR             shift and go to state 80
    WHILE           shift and go to state 74

    body                           shift and go to state 220
    funcCall                       shift and go to state 85
    instr                          shift and go to state 72
    forCycle                       shift and go to state 75
    assign                         shift and go to state 86
    whileCycle                     shift and go to state 73
    basicStatements                shift and go to state 81
    condition                      shift and go to state 83
    cyInstruction                  shift and go to state 76
    empty                          shift and go to state 78
    cycle                          shift and go to state 77

state 208

    (33) return -> RETURN expresion . ;

    ;               shift and go to state 221


state 209

    (100) opStruct -> [ expresion ] . opMatrix
    (101) opMatrix -> . [ expresion ]
    (102) opMatrix -> . empty
    (110) empty -> .

    [               shift and go to state 222
    *               reduce using rule 110 (empty -> .)
    /               reduce using rule 110 (empty -> .)
    +               reduce using rule 110 (empty -> .)
    -               reduce using rule 110 (empty -> .)
    EQ              reduce using rule 110 (empty -> .)
    DIF             reduce using rule 110 (empty -> .)
    LTOEQ           reduce using rule 110 (empty -> .)
    GTOEQ           reduce using rule 110 (empty -> .)
    >               reduce using rule 110 (empty -> .)
    <               reduce using rule 110 (empty -> .)
    AND             reduce using rule 110 (empty -> .)
    OR              reduce using rule 110 (empty -> .)
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    ]               reduce using rule 110 (empty -> .)
    ;               reduce using rule 110 (empty -> .)

    empty                          shift and go to state 223
    opMatrix                       shift and go to state 224

state 210

    (50) whileCycle -> WHILE ( expresion ) { body . }

    }               shift and go to state 225


state 211

    (51) forCycle -> FOR ( assign ; expresion ; . assign ) { body }
    (52) assign -> . ID assignOptions

    ID              shift and go to state 126

    assign                         shift and go to state 226

state 212

    (61) cyParamCall -> , expresion cyParamCall .

    )               reduce using rule 61 (cyParamCall -> , expresion cyParamCall .)


state 213

    (25) initDict -> = ( dictType : dictType . )

    )               shift and go to state 227


state 214

    (26) dictType -> CTES .

    )               reduce using rule 26 (dictType -> CTES .)


state 215

    (27) dictType -> cte .

    )               reduce using rule 27 (dictType -> cte .)


state 216

    (28) dictType -> ID .

    )               reduce using rule 28 (dictType -> ID .)


state 217

    (55) assignOptions -> [ expresion ] assignMatrix init .

    ;               reduce using rule 55 (assignOptions -> [ expresion ] assignMatrix init .)
    )               reduce using rule 55 (assignOptions -> [ expresion ] assignMatrix init .)


state 218

    (22) init -> = . initWith
    (23) initWith -> . expresion
    (24) initWith -> . funcCall
    (72) expresion -> . sExp cyExpresion
    (58) funcCall -> . ID ( opParamCall )
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE

    ID              shift and go to state 133
    CTES            shift and go to state 118
    (               shift and go to state 113
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 134
    initWith                       shift and go to state 131
    funcCall                       shift and go to state 135
    term                           shift and go to state 119
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 219

    (56) assignMatrix -> [ expresion . ]

    ]               shift and go to state 228


state 220

    (68) condition -> IF ( expresion ) { body . } optionalElse

    }               shift and go to state 229


state 221

    (33) return -> RETURN expresion ; .

    }               reduce using rule 33 (return -> RETURN expresion ; .)


state 222

    (101) opMatrix -> [ . expresion ]
    (72) expresion -> . sExp cyExpresion
    (76) sExp -> . exp opSExp
    (84) exp -> . term cyExp
    (88) term -> . fact cyTerm
    (92) fact -> . CTES
    (93) fact -> . cte
    (94) fact -> . funcCall
    (95) fact -> . ( expresion )
    (96) fact -> . ID opAccess
    (106) cte -> . CTED
    (107) cte -> . CTEF
    (108) cte -> . TRUE
    (109) cte -> . FALSE
    (58) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 118
    (               shift and go to state 113
    ID              shift and go to state 116
    CTED            shift and go to state 124
    CTEF            shift and go to state 123
    TRUE            shift and go to state 112
    FALSE           shift and go to state 120

    expresion                      shift and go to state 230
    term                           shift and go to state 119
    funcCall                       shift and go to state 121
    sExp                           shift and go to state 114
    cte                            shift and go to state 122
    exp                            shift and go to state 115
    fact                           shift and go to state 125

state 223

    (102) opMatrix -> empty .

    *               reduce using rule 102 (opMatrix -> empty .)
    /               reduce using rule 102 (opMatrix -> empty .)
    +               reduce using rule 102 (opMatrix -> empty .)
    -               reduce using rule 102 (opMatrix -> empty .)
    EQ              reduce using rule 102 (opMatrix -> empty .)
    DIF             reduce using rule 102 (opMatrix -> empty .)
    LTOEQ           reduce using rule 102 (opMatrix -> empty .)
    GTOEQ           reduce using rule 102 (opMatrix -> empty .)
    >               reduce using rule 102 (opMatrix -> empty .)
    <               reduce using rule 102 (opMatrix -> empty .)
    AND             reduce using rule 102 (opMatrix -> empty .)
    OR              reduce using rule 102 (opMatrix -> empty .)
    )               reduce using rule 102 (opMatrix -> empty .)
    ,               reduce using rule 102 (opMatrix -> empty .)
    ]               reduce using rule 102 (opMatrix -> empty .)
    ;               reduce using rule 102 (opMatrix -> empty .)


state 224

    (100) opStruct -> [ expresion ] opMatrix .

    *               reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    /               reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    +               reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    -               reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    EQ              reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    DIF             reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    LTOEQ           reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    GTOEQ           reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    >               reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    <               reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    AND             reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    OR              reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    )               reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    ,               reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    ]               reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)
    ;               reduce using rule 100 (opStruct -> [ expresion ] opMatrix .)


state 225

    (50) whileCycle -> WHILE ( expresion ) { body } .

    IF              reduce using rule 50 (whileCycle -> WHILE ( expresion ) { body } .)
    ID              reduce using rule 50 (whileCycle -> WHILE ( expresion ) { body } .)
    FOR             reduce using rule 50 (whileCycle -> WHILE ( expresion ) { body } .)
    WHILE           reduce using rule 50 (whileCycle -> WHILE ( expresion ) { body } .)
    }               reduce using rule 50 (whileCycle -> WHILE ( expresion ) { body } .)
    RETURN          reduce using rule 50 (whileCycle -> WHILE ( expresion ) { body } .)


state 226

    (51) forCycle -> FOR ( assign ; expresion ; assign . ) { body }

    )               shift and go to state 231


state 227

    (25) initDict -> = ( dictType : dictType ) .

    ;               reduce using rule 25 (initDict -> = ( dictType : dictType ) .)
    )               reduce using rule 25 (initDict -> = ( dictType : dictType ) .)


state 228

    (56) assignMatrix -> [ expresion ] .

    =               reduce using rule 56 (assignMatrix -> [ expresion ] .)


state 229

    (68) condition -> IF ( expresion ) { body } . optionalElse
    (69) optionalElse -> . ELSE { body }
    (70) optionalElse -> . empty
    (110) empty -> .

    ELSE            shift and go to state 232
    IF              reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    FOR             reduce using rule 110 (empty -> .)
    WHILE           reduce using rule 110 (empty -> .)
    }               reduce using rule 110 (empty -> .)
    RETURN          reduce using rule 110 (empty -> .)

    optionalElse                   shift and go to state 233
    empty                          shift and go to state 234

state 230

    (101) opMatrix -> [ expresion . ]

    ]               shift and go to state 235


state 231

    (51) forCycle -> FOR ( assign ; expresion ; assign ) . { body }

    {               shift and go to state 236


state 232

    (69) optionalElse -> ELSE . { body }

    {               shift and go to state 237


state 233

    (68) condition -> IF ( expresion ) { body } optionalElse .

    IF              reduce using rule 68 (condition -> IF ( expresion ) { body } optionalElse .)
    ID              reduce using rule 68 (condition -> IF ( expresion ) { body } optionalElse .)
    FOR             reduce using rule 68 (condition -> IF ( expresion ) { body } optionalElse .)
    WHILE           reduce using rule 68 (condition -> IF ( expresion ) { body } optionalElse .)
    }               reduce using rule 68 (condition -> IF ( expresion ) { body } optionalElse .)
    RETURN          reduce using rule 68 (condition -> IF ( expresion ) { body } optionalElse .)


state 234

    (70) optionalElse -> empty .

    IF              reduce using rule 70 (optionalElse -> empty .)
    ID              reduce using rule 70 (optionalElse -> empty .)
    FOR             reduce using rule 70 (optionalElse -> empty .)
    WHILE           reduce using rule 70 (optionalElse -> empty .)
    }               reduce using rule 70 (optionalElse -> empty .)
    RETURN          reduce using rule 70 (optionalElse -> empty .)


state 235

    (101) opMatrix -> [ expresion ] .

    *               reduce using rule 101 (opMatrix -> [ expresion ] .)
    /               reduce using rule 101 (opMatrix -> [ expresion ] .)
    +               reduce using rule 101 (opMatrix -> [ expresion ] .)
    -               reduce using rule 101 (opMatrix -> [ expresion ] .)
    EQ              reduce using rule 101 (opMatrix -> [ expresion ] .)
    DIF             reduce using rule 101 (opMatrix -> [ expresion ] .)
    LTOEQ           reduce using rule 101 (opMatrix -> [ expresion ] .)
    GTOEQ           reduce using rule 101 (opMatrix -> [ expresion ] .)
    >               reduce using rule 101 (opMatrix -> [ expresion ] .)
    <               reduce using rule 101 (opMatrix -> [ expresion ] .)
    AND             reduce using rule 101 (opMatrix -> [ expresion ] .)
    OR              reduce using rule 101 (opMatrix -> [ expresion ] .)
    )               reduce using rule 101 (opMatrix -> [ expresion ] .)
    ,               reduce using rule 101 (opMatrix -> [ expresion ] .)
    ]               reduce using rule 101 (opMatrix -> [ expresion ] .)
    ;               reduce using rule 101 (opMatrix -> [ expresion ] .)


state 236

    (51) forCycle -> FOR ( assign ; expresion ; assign ) { . body }
    (45) body -> . cyInstruction
    (46) body -> . empty
    (47) cyInstruction -> . instr body
    (110) empty -> .
    (14) instr -> . basicStatements ;
    (15) instr -> . condition
    (16) instr -> . cycle
    (17) basicStatements -> . assign
    (18) basicStatements -> . funcCall
    (68) condition -> . IF ( expresion ) { body } optionalElse
    (48) cycle -> . forCycle
    (49) cycle -> . whileCycle
    (52) assign -> . ID assignOptions
    (58) funcCall -> . ID ( opParamCall )
    (51) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (50) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 110 (empty -> .)
    IF              shift and go to state 84
    ID              shift and go to state 82
    FOR             shift and go to state 80
    WHILE           shift and go to state 74

    body                           shift and go to state 238
    funcCall                       shift and go to state 85
    instr                          shift and go to state 72
    forCycle                       shift and go to state 75
    cyInstruction                  shift and go to state 76
    whileCycle                     shift and go to state 73
    basicStatements                shift and go to state 81
    condition                      shift and go to state 83
    assign                         shift and go to state 86
    empty                          shift and go to state 78
    cycle                          shift and go to state 77

state 237

    (69) optionalElse -> ELSE { . body }
    (45) body -> . cyInstruction
    (46) body -> . empty
    (47) cyInstruction -> . instr body
    (110) empty -> .
    (14) instr -> . basicStatements ;
    (15) instr -> . condition
    (16) instr -> . cycle
    (17) basicStatements -> . assign
    (18) basicStatements -> . funcCall
    (68) condition -> . IF ( expresion ) { body } optionalElse
    (48) cycle -> . forCycle
    (49) cycle -> . whileCycle
    (52) assign -> . ID assignOptions
    (58) funcCall -> . ID ( opParamCall )
    (51) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (50) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 110 (empty -> .)
    IF              shift and go to state 84
    ID              shift and go to state 82
    FOR             shift and go to state 80
    WHILE           shift and go to state 74

    body                           shift and go to state 239
    funcCall                       shift and go to state 85
    instr                          shift and go to state 72
    forCycle                       shift and go to state 75
    assign                         shift and go to state 86
    whileCycle                     shift and go to state 73
    basicStatements                shift and go to state 81
    empty                          shift and go to state 78
    cyInstruction                  shift and go to state 76
    condition                      shift and go to state 83
    cycle                          shift and go to state 77

state 238

    (51) forCycle -> FOR ( assign ; expresion ; assign ) { body . }

    }               shift and go to state 240


state 239

    (69) optionalElse -> ELSE { body . }

    }               shift and go to state 241


state 240

    (51) forCycle -> FOR ( assign ; expresion ; assign ) { body } .

    IF              reduce using rule 51 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    ID              reduce using rule 51 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    FOR             reduce using rule 51 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    WHILE           reduce using rule 51 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    }               reduce using rule 51 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    RETURN          reduce using rule 51 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)


state 241

    (69) optionalElse -> ELSE { body } .

    IF              reduce using rule 69 (optionalElse -> ELSE { body } .)
    ID              reduce using rule 69 (optionalElse -> ELSE { body } .)
    FOR             reduce using rule 69 (optionalElse -> ELSE { body } .)
    WHILE           reduce using rule 69 (optionalElse -> ELSE { body } .)
    }               reduce using rule 69 (optionalElse -> ELSE { body } .)
    RETURN          reduce using rule 69 (optionalElse -> ELSE { body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 135 resolved using rule (initWith -> funcCall)
WARNING: rejected rule (fact -> funcCall) in state 135
