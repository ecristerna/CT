Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID { opVars opFunctions main }
Rule 2     opVars -> vars
Rule 3     opVars -> empty
Rule 4     opFunctions -> function opFunctions
Rule 5     opFunctions -> empty
Rule 6     vars -> VARS declare
Rule 7     type -> INT
Rule 8     type -> FLOAT
Rule 9     type -> STRING
Rule 10    type -> OBJECT
Rule 11    type -> BOOL
Rule 12    main -> MAIN { opVars body }
Rule 13    instr -> basicStatements ;
Rule 14    instr -> condition
Rule 15    instr -> cycle
Rule 16    basicStatements -> assign
Rule 17    basicStatements -> funcCall
Rule 18    declare -> basicDeclare
Rule 19    declare -> structDeclare
Rule 20    declare -> dictDeclare
Rule 21    init -> = initWith
Rule 22    initWith -> expresion
Rule 23    initWith -> funcCall
Rule 24    initDict -> = ( dictType : dictType )
Rule 25    dictType -> CTES
Rule 26    dictType -> cte
Rule 27    dictType -> ID
Rule 28    param -> type ID cyTypeParam cyParam
Rule 29    cyParam -> ; param
Rule 30    cyParam -> empty
Rule 31    function -> FUNC ID opParameters opReturns }
Rule 32    return -> RETURN expresion ;
Rule 33    opParameters -> ( param )
Rule 34    opParameters -> empty
Rule 35    opReturns -> RETURNS type { opVars body return
Rule 36    opReturns -> { opVars body
Rule 37    basicDeclare -> type ID cyTypeParam ; cyDeclare
Rule 38    structDeclare -> STRUCT ID struct ; cyDeclare
Rule 39    dictDeclare -> DICT ID dict ; cyDeclare
Rule 40    cyTypeParam -> , ID
Rule 41    cyTypeParam -> empty
Rule 42    cyDeclare -> declare
Rule 43    cyDeclare -> empty
Rule 44    body -> cyInstruction
Rule 45    body -> empty
Rule 46    cyInstruction -> instr body
Rule 47    cycle -> forCycle
Rule 48    cycle -> whileCycle
Rule 49    whileCycle -> WHILE ( expresion ) { body }
Rule 50    forCycle -> FOR ( assign ; expresion ; assign ) { body }
Rule 51    assign -> ID assignOptions
Rule 52    assignOptions -> init
Rule 53    assignOptions -> initDict
Rule 54    assignOptions -> [ expresion ] assignMatrix init
Rule 55    assignMatrix -> [ expresion ]
Rule 56    assignMatrix -> empty
Rule 57    funcCall -> ID ( opParamCall )
Rule 58    opParamCall -> expresion cyParamCall
Rule 59    opParamCall -> empty
Rule 60    cyParamCall -> , expresion cyParamCall
Rule 61    cyParamCall -> empty
Rule 62    struct -> structType [ CTED ] optionalMatrix
Rule 63    structType -> type
Rule 64    structType -> DICT dict
Rule 65    optionalMatrix -> [ CTED ]
Rule 66    optionalMatrix -> empty
Rule 67    condition -> IF ( expresion ) { body } optionalElse
Rule 68    optionalElse -> ELSE { body }
Rule 69    optionalElse -> empty
Rule 70    dict -> ( type : type )
Rule 71    expresion -> sExp cyExpresion
Rule 72    cyExpresion -> AND expresion
Rule 73    cyExpresion -> OR expresion
Rule 74    cyExpresion -> empty
Rule 75    sExp -> exp opSExp
Rule 76    opSExp -> EQ exp
Rule 77    opSExp -> DIF exp
Rule 78    opSExp -> LTOEQ exp
Rule 79    opSExp -> GTOEQ exp
Rule 80    opSExp -> > exp
Rule 81    opSExp -> < exp
Rule 82    opSExp -> empty
Rule 83    exp -> term cyExp
Rule 84    cyExp -> + term
Rule 85    cyExp -> - term
Rule 86    cyExp -> empty
Rule 87    term -> fact cyTerm
Rule 88    cyTerm -> * fact
Rule 89    cyTerm -> / fact
Rule 90    cyTerm -> empty
Rule 91    fact -> CTES
Rule 92    fact -> cte
Rule 93    fact -> funcCall
Rule 94    fact -> ( expresion )
Rule 95    fact -> ID opAccess
Rule 96    opAccess -> opStruct
Rule 97    opAccess -> opDictionary
Rule 98    opAccess -> empty
Rule 99    opStruct -> [ expresion ] opMatrix
Rule 100   opMatrix -> [ expresion ]
Rule 101   opMatrix -> empty
Rule 102   opDictionary -> . dictIndex
Rule 103   dictIndex -> FIRST
Rule 104   dictIndex -> LAST
Rule 105   cte -> CTED
Rule 106   cte -> CTEF
Rule 107   cte -> TRUE
Rule 108   cte -> FALSE
Rule 109   empty -> <empty>

Terminals, with rules where they appear

(                    : 24 33 49 50 57 67 70 94
)                    : 24 33 49 50 57 67 70 94
*                    : 88
+                    : 84
,                    : 40 60
-                    : 85
.                    : 102
/                    : 89
:                    : 24 70
;                    : 13 29 32 37 38 39 50 50
<                    : 81
=                    : 21 24
>                    : 80
AND                  : 72
BOOL                 : 11
CTED                 : 62 65 105
CTEF                 : 106
CTES                 : 25 91
DICT                 : 39 64
DIF                  : 77
ELSE                 : 68
EQ                   : 76
FALSE                : 108
FIRST                : 103
FLOAT                : 8
FOR                  : 50
FUNC                 : 31
GTOEQ                : 79
ID                   : 1 27 28 31 37 38 39 40 51 57 95
IF                   : 67
INT                  : 7
LAST                 : 104
LTOEQ                : 78
MAIN                 : 12
OBJECT               : 10
OR                   : 73
PROGRAM              : 1
RETURN               : 32
RETURNS              : 35
STRING               : 9
STRUCT               : 38
TRUE                 : 107
VARS                 : 6
WHILE                : 49
[                    : 54 55 62 65 99 100
]                    : 54 55 62 65 99 100
error                : 
{                    : 1 12 35 36 49 50 67 68
}                    : 1 12 31 49 50 67 68

Nonterminals, with rules where they appear

assign               : 16 50 50
assignMatrix         : 54
assignOptions        : 51
basicDeclare         : 18
basicStatements      : 13
body                 : 12 35 36 46 49 50 67 68
condition            : 14
cte                  : 26 92
cyDeclare            : 37 38 39
cyExp                : 83
cyExpresion          : 71
cyInstruction        : 44
cyParam              : 28
cyParamCall          : 58 60
cyTerm               : 87
cyTypeParam          : 28 37
cycle                : 15
declare              : 6 42
dict                 : 39 64
dictDeclare          : 20
dictIndex            : 102
dictType             : 24 24
empty                : 3 5 30 34 41 43 45 56 59 61 66 69 74 82 86 90 98 101
exp                  : 75 76 77 78 79 80 81
expresion            : 22 32 49 50 54 55 58 60 67 72 73 94 99 100
fact                 : 87 88 89
forCycle             : 47
funcCall             : 17 23 93
function             : 4
init                 : 52 54
initDict             : 53
initWith             : 21
instr                : 46
main                 : 1
opAccess             : 95
opDictionary         : 97
opFunctions          : 1 4
opMatrix             : 99
opParamCall          : 57
opParameters         : 31
opReturns            : 31
opSExp               : 75
opStruct             : 96
opVars               : 1 12 35 36
optionalElse         : 67
optionalMatrix       : 62
param                : 29 33
program              : 0
return               : 35
sExp                 : 71
struct               : 38
structDeclare        : 19
structType           : 62
term                 : 83 84 85
type                 : 28 35 37 63 70 70
vars                 : 2
whileCycle           : 48

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID { opVars opFunctions main }

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID { opVars opFunctions main }

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . { opVars opFunctions main }

    {               shift and go to state 4


state 4

    (1) program -> PROGRAM ID { . opVars opFunctions main }
    (2) opVars -> . vars
    (3) opVars -> . empty
    (6) vars -> . VARS declare
    (109) empty -> .

    VARS            shift and go to state 5
    FUNC            reduce using rule 109 (empty -> .)
    MAIN            reduce using rule 109 (empty -> .)

    vars                           shift and go to state 6
    opVars                         shift and go to state 7
    empty                          shift and go to state 8

state 5

    (6) vars -> VARS . declare
    (18) declare -> . basicDeclare
    (19) declare -> . structDeclare
    (20) declare -> . dictDeclare
    (37) basicDeclare -> . type ID cyTypeParam ; cyDeclare
    (38) structDeclare -> . STRUCT ID struct ; cyDeclare
    (39) dictDeclare -> . DICT ID dict ; cyDeclare
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    STRUCT          shift and go to state 10
    DICT            shift and go to state 16
    INT             shift and go to state 11
    FLOAT           shift and go to state 13
    STRING          shift and go to state 15
    OBJECT          shift and go to state 14
    BOOL            shift and go to state 17

    dictDeclare                    shift and go to state 9
    type                           shift and go to state 12
    structDeclare                  shift and go to state 18
    basicDeclare                   shift and go to state 19
    declare                        shift and go to state 20

state 6

    (2) opVars -> vars .

    IF              reduce using rule 2 (opVars -> vars .)
    ID              reduce using rule 2 (opVars -> vars .)
    FOR             reduce using rule 2 (opVars -> vars .)
    WHILE           reduce using rule 2 (opVars -> vars .)
    }               reduce using rule 2 (opVars -> vars .)
    FUNC            reduce using rule 2 (opVars -> vars .)
    MAIN            reduce using rule 2 (opVars -> vars .)
    RETURN          reduce using rule 2 (opVars -> vars .)


state 7

    (1) program -> PROGRAM ID { opVars . opFunctions main }
    (4) opFunctions -> . function opFunctions
    (5) opFunctions -> . empty
    (31) function -> . FUNC ID opParameters opReturns }
    (109) empty -> .

    FUNC            shift and go to state 22
    MAIN            reduce using rule 109 (empty -> .)

    function                       shift and go to state 21
    empty                          shift and go to state 23
    opFunctions                    shift and go to state 24

state 8

    (3) opVars -> empty .

    IF              reduce using rule 3 (opVars -> empty .)
    ID              reduce using rule 3 (opVars -> empty .)
    FOR             reduce using rule 3 (opVars -> empty .)
    WHILE           reduce using rule 3 (opVars -> empty .)
    }               reduce using rule 3 (opVars -> empty .)
    FUNC            reduce using rule 3 (opVars -> empty .)
    MAIN            reduce using rule 3 (opVars -> empty .)
    RETURN          reduce using rule 3 (opVars -> empty .)


state 9

    (20) declare -> dictDeclare .

    FUNC            reduce using rule 20 (declare -> dictDeclare .)
    MAIN            reduce using rule 20 (declare -> dictDeclare .)
    IF              reduce using rule 20 (declare -> dictDeclare .)
    ID              reduce using rule 20 (declare -> dictDeclare .)
    FOR             reduce using rule 20 (declare -> dictDeclare .)
    WHILE           reduce using rule 20 (declare -> dictDeclare .)
    }               reduce using rule 20 (declare -> dictDeclare .)
    RETURN          reduce using rule 20 (declare -> dictDeclare .)


state 10

    (38) structDeclare -> STRUCT . ID struct ; cyDeclare

    ID              shift and go to state 25


state 11

    (7) type -> INT .

    ID              reduce using rule 7 (type -> INT .)
    {               reduce using rule 7 (type -> INT .)
    )               reduce using rule 7 (type -> INT .)
    [               reduce using rule 7 (type -> INT .)
    :               reduce using rule 7 (type -> INT .)


state 12

    (37) basicDeclare -> type . ID cyTypeParam ; cyDeclare

    ID              shift and go to state 26


state 13

    (8) type -> FLOAT .

    ID              reduce using rule 8 (type -> FLOAT .)
    {               reduce using rule 8 (type -> FLOAT .)
    )               reduce using rule 8 (type -> FLOAT .)
    [               reduce using rule 8 (type -> FLOAT .)
    :               reduce using rule 8 (type -> FLOAT .)


state 14

    (10) type -> OBJECT .

    ID              reduce using rule 10 (type -> OBJECT .)
    {               reduce using rule 10 (type -> OBJECT .)
    )               reduce using rule 10 (type -> OBJECT .)
    [               reduce using rule 10 (type -> OBJECT .)
    :               reduce using rule 10 (type -> OBJECT .)


state 15

    (9) type -> STRING .

    ID              reduce using rule 9 (type -> STRING .)
    {               reduce using rule 9 (type -> STRING .)
    )               reduce using rule 9 (type -> STRING .)
    [               reduce using rule 9 (type -> STRING .)
    :               reduce using rule 9 (type -> STRING .)


state 16

    (39) dictDeclare -> DICT . ID dict ; cyDeclare

    ID              shift and go to state 27


state 17

    (11) type -> BOOL .

    ID              reduce using rule 11 (type -> BOOL .)
    {               reduce using rule 11 (type -> BOOL .)
    )               reduce using rule 11 (type -> BOOL .)
    [               reduce using rule 11 (type -> BOOL .)
    :               reduce using rule 11 (type -> BOOL .)


state 18

    (19) declare -> structDeclare .

    FUNC            reduce using rule 19 (declare -> structDeclare .)
    MAIN            reduce using rule 19 (declare -> structDeclare .)
    IF              reduce using rule 19 (declare -> structDeclare .)
    ID              reduce using rule 19 (declare -> structDeclare .)
    FOR             reduce using rule 19 (declare -> structDeclare .)
    WHILE           reduce using rule 19 (declare -> structDeclare .)
    }               reduce using rule 19 (declare -> structDeclare .)
    RETURN          reduce using rule 19 (declare -> structDeclare .)


state 19

    (18) declare -> basicDeclare .

    FUNC            reduce using rule 18 (declare -> basicDeclare .)
    MAIN            reduce using rule 18 (declare -> basicDeclare .)
    IF              reduce using rule 18 (declare -> basicDeclare .)
    ID              reduce using rule 18 (declare -> basicDeclare .)
    FOR             reduce using rule 18 (declare -> basicDeclare .)
    WHILE           reduce using rule 18 (declare -> basicDeclare .)
    }               reduce using rule 18 (declare -> basicDeclare .)
    RETURN          reduce using rule 18 (declare -> basicDeclare .)


state 20

    (6) vars -> VARS declare .

    FUNC            reduce using rule 6 (vars -> VARS declare .)
    MAIN            reduce using rule 6 (vars -> VARS declare .)
    IF              reduce using rule 6 (vars -> VARS declare .)
    ID              reduce using rule 6 (vars -> VARS declare .)
    FOR             reduce using rule 6 (vars -> VARS declare .)
    WHILE           reduce using rule 6 (vars -> VARS declare .)
    RETURN          reduce using rule 6 (vars -> VARS declare .)
    }               reduce using rule 6 (vars -> VARS declare .)


state 21

    (4) opFunctions -> function . opFunctions
    (4) opFunctions -> . function opFunctions
    (5) opFunctions -> . empty
    (31) function -> . FUNC ID opParameters opReturns }
    (109) empty -> .

    FUNC            shift and go to state 22
    MAIN            reduce using rule 109 (empty -> .)

    function                       shift and go to state 21
    empty                          shift and go to state 23
    opFunctions                    shift and go to state 28

state 22

    (31) function -> FUNC . ID opParameters opReturns }

    ID              shift and go to state 29


state 23

    (5) opFunctions -> empty .

    MAIN            reduce using rule 5 (opFunctions -> empty .)


state 24

    (1) program -> PROGRAM ID { opVars opFunctions . main }
    (12) main -> . MAIN { opVars body }

    MAIN            shift and go to state 30

    main                           shift and go to state 31

state 25

    (38) structDeclare -> STRUCT ID . struct ; cyDeclare
    (62) struct -> . structType [ CTED ] optionalMatrix
    (63) structType -> . type
    (64) structType -> . DICT dict
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    DICT            shift and go to state 34
    INT             shift and go to state 11
    FLOAT           shift and go to state 13
    STRING          shift and go to state 15
    OBJECT          shift and go to state 14
    BOOL            shift and go to state 17

    structType                     shift and go to state 32
    struct                         shift and go to state 33
    type                           shift and go to state 35

state 26

    (37) basicDeclare -> type ID . cyTypeParam ; cyDeclare
    (40) cyTypeParam -> . , ID
    (41) cyTypeParam -> . empty
    (109) empty -> .

    ,               shift and go to state 36
    ;               reduce using rule 109 (empty -> .)

    cyTypeParam                    shift and go to state 37
    empty                          shift and go to state 38

state 27

    (39) dictDeclare -> DICT ID . dict ; cyDeclare
    (70) dict -> . ( type : type )

    (               shift and go to state 39

    dict                           shift and go to state 40

state 28

    (4) opFunctions -> function opFunctions .

    MAIN            reduce using rule 4 (opFunctions -> function opFunctions .)


state 29

    (31) function -> FUNC ID . opParameters opReturns }
    (33) opParameters -> . ( param )
    (34) opParameters -> . empty
    (109) empty -> .

    (               shift and go to state 41
    RETURNS         reduce using rule 109 (empty -> .)
    {               reduce using rule 109 (empty -> .)

    opParameters                   shift and go to state 42
    empty                          shift and go to state 43

state 30

    (12) main -> MAIN . { opVars body }

    {               shift and go to state 44


state 31

    (1) program -> PROGRAM ID { opVars opFunctions main . }

    }               shift and go to state 45


state 32

    (62) struct -> structType . [ CTED ] optionalMatrix

    [               shift and go to state 46


state 33

    (38) structDeclare -> STRUCT ID struct . ; cyDeclare

    ;               shift and go to state 47


state 34

    (64) structType -> DICT . dict
    (70) dict -> . ( type : type )

    (               shift and go to state 39

    dict                           shift and go to state 48

state 35

    (63) structType -> type .

    [               reduce using rule 63 (structType -> type .)


state 36

    (40) cyTypeParam -> , . ID

    ID              shift and go to state 49


state 37

    (37) basicDeclare -> type ID cyTypeParam . ; cyDeclare

    ;               shift and go to state 50


state 38

    (41) cyTypeParam -> empty .

    ;               reduce using rule 41 (cyTypeParam -> empty .)
    )               reduce using rule 41 (cyTypeParam -> empty .)


state 39

    (70) dict -> ( . type : type )
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 11
    FLOAT           shift and go to state 13
    STRING          shift and go to state 15
    OBJECT          shift and go to state 14
    BOOL            shift and go to state 17

    type                           shift and go to state 51

state 40

    (39) dictDeclare -> DICT ID dict . ; cyDeclare

    ;               shift and go to state 52


state 41

    (33) opParameters -> ( . param )
    (28) param -> . type ID cyTypeParam cyParam
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 11
    FLOAT           shift and go to state 13
    STRING          shift and go to state 15
    OBJECT          shift and go to state 14
    BOOL            shift and go to state 17

    type                           shift and go to state 54
    param                          shift and go to state 53

state 42

    (31) function -> FUNC ID opParameters . opReturns }
    (35) opReturns -> . RETURNS type { opVars body return
    (36) opReturns -> . { opVars body

    RETURNS         shift and go to state 55
    {               shift and go to state 56

    opReturns                      shift and go to state 57

state 43

    (34) opParameters -> empty .

    RETURNS         reduce using rule 34 (opParameters -> empty .)
    {               reduce using rule 34 (opParameters -> empty .)


state 44

    (12) main -> MAIN { . opVars body }
    (2) opVars -> . vars
    (3) opVars -> . empty
    (6) vars -> . VARS declare
    (109) empty -> .

    VARS            shift and go to state 5
    IF              reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FOR             reduce using rule 109 (empty -> .)
    WHILE           reduce using rule 109 (empty -> .)
    }               reduce using rule 109 (empty -> .)

    opVars                         shift and go to state 58
    empty                          shift and go to state 8
    vars                           shift and go to state 6

state 45

    (1) program -> PROGRAM ID { opVars opFunctions main } .

    $end            reduce using rule 1 (program -> PROGRAM ID { opVars opFunctions main } .)


state 46

    (62) struct -> structType [ . CTED ] optionalMatrix

    CTED            shift and go to state 59


state 47

    (38) structDeclare -> STRUCT ID struct ; . cyDeclare
    (42) cyDeclare -> . declare
    (43) cyDeclare -> . empty
    (18) declare -> . basicDeclare
    (19) declare -> . structDeclare
    (20) declare -> . dictDeclare
    (109) empty -> .
    (37) basicDeclare -> . type ID cyTypeParam ; cyDeclare
    (38) structDeclare -> . STRUCT ID struct ; cyDeclare
    (39) dictDeclare -> . DICT ID dict ; cyDeclare
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 109 (empty -> .)
    MAIN            reduce using rule 109 (empty -> .)
    IF              reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FOR             reduce using rule 109 (empty -> .)
    WHILE           reduce using rule 109 (empty -> .)
    }               reduce using rule 109 (empty -> .)
    RETURN          reduce using rule 109 (empty -> .)
    STRUCT          shift and go to state 10
    DICT            shift and go to state 16
    INT             shift and go to state 11
    FLOAT           shift and go to state 13
    STRING          shift and go to state 15
    OBJECT          shift and go to state 14
    BOOL            shift and go to state 17

    dictDeclare                    shift and go to state 9
    cyDeclare                      shift and go to state 60
    type                           shift and go to state 12
    structDeclare                  shift and go to state 18
    basicDeclare                   shift and go to state 19
    declare                        shift and go to state 61
    empty                          shift and go to state 62

state 48

    (64) structType -> DICT dict .

    [               reduce using rule 64 (structType -> DICT dict .)


state 49

    (40) cyTypeParam -> , ID .

    ;               reduce using rule 40 (cyTypeParam -> , ID .)
    )               reduce using rule 40 (cyTypeParam -> , ID .)


state 50

    (37) basicDeclare -> type ID cyTypeParam ; . cyDeclare
    (42) cyDeclare -> . declare
    (43) cyDeclare -> . empty
    (18) declare -> . basicDeclare
    (19) declare -> . structDeclare
    (20) declare -> . dictDeclare
    (109) empty -> .
    (37) basicDeclare -> . type ID cyTypeParam ; cyDeclare
    (38) structDeclare -> . STRUCT ID struct ; cyDeclare
    (39) dictDeclare -> . DICT ID dict ; cyDeclare
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 109 (empty -> .)
    MAIN            reduce using rule 109 (empty -> .)
    IF              reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FOR             reduce using rule 109 (empty -> .)
    WHILE           reduce using rule 109 (empty -> .)
    }               reduce using rule 109 (empty -> .)
    RETURN          reduce using rule 109 (empty -> .)
    STRUCT          shift and go to state 10
    DICT            shift and go to state 16
    INT             shift and go to state 11
    FLOAT           shift and go to state 13
    STRING          shift and go to state 15
    OBJECT          shift and go to state 14
    BOOL            shift and go to state 17

    dictDeclare                    shift and go to state 9
    cyDeclare                      shift and go to state 63
    type                           shift and go to state 12
    structDeclare                  shift and go to state 18
    basicDeclare                   shift and go to state 19
    declare                        shift and go to state 61
    empty                          shift and go to state 62

state 51

    (70) dict -> ( type . : type )

    :               shift and go to state 64


state 52

    (39) dictDeclare -> DICT ID dict ; . cyDeclare
    (42) cyDeclare -> . declare
    (43) cyDeclare -> . empty
    (18) declare -> . basicDeclare
    (19) declare -> . structDeclare
    (20) declare -> . dictDeclare
    (109) empty -> .
    (37) basicDeclare -> . type ID cyTypeParam ; cyDeclare
    (38) structDeclare -> . STRUCT ID struct ; cyDeclare
    (39) dictDeclare -> . DICT ID dict ; cyDeclare
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 109 (empty -> .)
    MAIN            reduce using rule 109 (empty -> .)
    IF              reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FOR             reduce using rule 109 (empty -> .)
    WHILE           reduce using rule 109 (empty -> .)
    }               reduce using rule 109 (empty -> .)
    RETURN          reduce using rule 109 (empty -> .)
    STRUCT          shift and go to state 10
    DICT            shift and go to state 16
    INT             shift and go to state 11
    FLOAT           shift and go to state 13
    STRING          shift and go to state 15
    OBJECT          shift and go to state 14
    BOOL            shift and go to state 17

    dictDeclare                    shift and go to state 9
    cyDeclare                      shift and go to state 65
    type                           shift and go to state 12
    structDeclare                  shift and go to state 18
    basicDeclare                   shift and go to state 19
    declare                        shift and go to state 61
    empty                          shift and go to state 62

state 53

    (33) opParameters -> ( param . )

    )               shift and go to state 66


state 54

    (28) param -> type . ID cyTypeParam cyParam

    ID              shift and go to state 67


state 55

    (35) opReturns -> RETURNS . type { opVars body return
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 11
    FLOAT           shift and go to state 13
    STRING          shift and go to state 15
    OBJECT          shift and go to state 14
    BOOL            shift and go to state 17

    type                           shift and go to state 68

state 56

    (36) opReturns -> { . opVars body
    (2) opVars -> . vars
    (3) opVars -> . empty
    (6) vars -> . VARS declare
    (109) empty -> .

    VARS            shift and go to state 5
    IF              reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FOR             reduce using rule 109 (empty -> .)
    WHILE           reduce using rule 109 (empty -> .)
    }               reduce using rule 109 (empty -> .)

    opVars                         shift and go to state 69
    empty                          shift and go to state 8
    vars                           shift and go to state 6

state 57

    (31) function -> FUNC ID opParameters opReturns . }

    }               shift and go to state 70


state 58

    (12) main -> MAIN { opVars . body }
    (44) body -> . cyInstruction
    (45) body -> . empty
    (46) cyInstruction -> . instr body
    (109) empty -> .
    (13) instr -> . basicStatements ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) basicStatements -> . assign
    (17) basicStatements -> . funcCall
    (67) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 109 (empty -> .)
    IF              shift and go to state 83
    ID              shift and go to state 81
    FOR             shift and go to state 79
    WHILE           shift and go to state 73

    body                           shift and go to state 78
    funcCall                       shift and go to state 84
    instr                          shift and go to state 71
    forCycle                       shift and go to state 74
    assign                         shift and go to state 85
    whileCycle                     shift and go to state 72
    basicStatements                shift and go to state 80
    condition                      shift and go to state 82
    cyInstruction                  shift and go to state 75
    empty                          shift and go to state 77
    cycle                          shift and go to state 76

state 59

    (62) struct -> structType [ CTED . ] optionalMatrix

    ]               shift and go to state 86


state 60

    (38) structDeclare -> STRUCT ID struct ; cyDeclare .

    FUNC            reduce using rule 38 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    MAIN            reduce using rule 38 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    IF              reduce using rule 38 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    ID              reduce using rule 38 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    FOR             reduce using rule 38 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    WHILE           reduce using rule 38 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    }               reduce using rule 38 (structDeclare -> STRUCT ID struct ; cyDeclare .)
    RETURN          reduce using rule 38 (structDeclare -> STRUCT ID struct ; cyDeclare .)


state 61

    (42) cyDeclare -> declare .

    FUNC            reduce using rule 42 (cyDeclare -> declare .)
    MAIN            reduce using rule 42 (cyDeclare -> declare .)
    IF              reduce using rule 42 (cyDeclare -> declare .)
    ID              reduce using rule 42 (cyDeclare -> declare .)
    FOR             reduce using rule 42 (cyDeclare -> declare .)
    WHILE           reduce using rule 42 (cyDeclare -> declare .)
    }               reduce using rule 42 (cyDeclare -> declare .)
    RETURN          reduce using rule 42 (cyDeclare -> declare .)


state 62

    (43) cyDeclare -> empty .

    FUNC            reduce using rule 43 (cyDeclare -> empty .)
    MAIN            reduce using rule 43 (cyDeclare -> empty .)
    IF              reduce using rule 43 (cyDeclare -> empty .)
    ID              reduce using rule 43 (cyDeclare -> empty .)
    FOR             reduce using rule 43 (cyDeclare -> empty .)
    WHILE           reduce using rule 43 (cyDeclare -> empty .)
    }               reduce using rule 43 (cyDeclare -> empty .)
    RETURN          reduce using rule 43 (cyDeclare -> empty .)


state 63

    (37) basicDeclare -> type ID cyTypeParam ; cyDeclare .

    FUNC            reduce using rule 37 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    MAIN            reduce using rule 37 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    IF              reduce using rule 37 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    ID              reduce using rule 37 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    FOR             reduce using rule 37 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    WHILE           reduce using rule 37 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    }               reduce using rule 37 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)
    RETURN          reduce using rule 37 (basicDeclare -> type ID cyTypeParam ; cyDeclare .)


state 64

    (70) dict -> ( type : . type )
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 11
    FLOAT           shift and go to state 13
    STRING          shift and go to state 15
    OBJECT          shift and go to state 14
    BOOL            shift and go to state 17

    type                           shift and go to state 87

state 65

    (39) dictDeclare -> DICT ID dict ; cyDeclare .

    FUNC            reduce using rule 39 (dictDeclare -> DICT ID dict ; cyDeclare .)
    MAIN            reduce using rule 39 (dictDeclare -> DICT ID dict ; cyDeclare .)
    IF              reduce using rule 39 (dictDeclare -> DICT ID dict ; cyDeclare .)
    ID              reduce using rule 39 (dictDeclare -> DICT ID dict ; cyDeclare .)
    FOR             reduce using rule 39 (dictDeclare -> DICT ID dict ; cyDeclare .)
    WHILE           reduce using rule 39 (dictDeclare -> DICT ID dict ; cyDeclare .)
    }               reduce using rule 39 (dictDeclare -> DICT ID dict ; cyDeclare .)
    RETURN          reduce using rule 39 (dictDeclare -> DICT ID dict ; cyDeclare .)


state 66

    (33) opParameters -> ( param ) .

    RETURNS         reduce using rule 33 (opParameters -> ( param ) .)
    {               reduce using rule 33 (opParameters -> ( param ) .)


state 67

    (28) param -> type ID . cyTypeParam cyParam
    (40) cyTypeParam -> . , ID
    (41) cyTypeParam -> . empty
    (109) empty -> .

    ,               shift and go to state 36
    ;               reduce using rule 109 (empty -> .)
    )               reduce using rule 109 (empty -> .)

    cyTypeParam                    shift and go to state 88
    empty                          shift and go to state 38

state 68

    (35) opReturns -> RETURNS type . { opVars body return

    {               shift and go to state 89


state 69

    (36) opReturns -> { opVars . body
    (44) body -> . cyInstruction
    (45) body -> . empty
    (46) cyInstruction -> . instr body
    (109) empty -> .
    (13) instr -> . basicStatements ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) basicStatements -> . assign
    (17) basicStatements -> . funcCall
    (67) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 109 (empty -> .)
    IF              shift and go to state 83
    ID              shift and go to state 81
    FOR             shift and go to state 79
    WHILE           shift and go to state 73

    body                           shift and go to state 90
    funcCall                       shift and go to state 84
    instr                          shift and go to state 71
    forCycle                       shift and go to state 74
    assign                         shift and go to state 85
    whileCycle                     shift and go to state 72
    basicStatements                shift and go to state 80
    condition                      shift and go to state 82
    cyInstruction                  shift and go to state 75
    empty                          shift and go to state 77
    cycle                          shift and go to state 76

state 70

    (31) function -> FUNC ID opParameters opReturns } .

    FUNC            reduce using rule 31 (function -> FUNC ID opParameters opReturns } .)
    MAIN            reduce using rule 31 (function -> FUNC ID opParameters opReturns } .)


state 71

    (46) cyInstruction -> instr . body
    (44) body -> . cyInstruction
    (45) body -> . empty
    (46) cyInstruction -> . instr body
    (109) empty -> .
    (13) instr -> . basicStatements ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) basicStatements -> . assign
    (17) basicStatements -> . funcCall
    (67) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 109 (empty -> .)
    RETURN          reduce using rule 109 (empty -> .)
    IF              shift and go to state 83
    ID              shift and go to state 81
    FOR             shift and go to state 79
    WHILE           shift and go to state 73

    body                           shift and go to state 91
    funcCall                       shift and go to state 84
    instr                          shift and go to state 71
    forCycle                       shift and go to state 74
    assign                         shift and go to state 85
    whileCycle                     shift and go to state 72
    basicStatements                shift and go to state 80
    empty                          shift and go to state 77
    cyInstruction                  shift and go to state 75
    condition                      shift and go to state 82
    cycle                          shift and go to state 76

state 72

    (48) cycle -> whileCycle .

    IF              reduce using rule 48 (cycle -> whileCycle .)
    ID              reduce using rule 48 (cycle -> whileCycle .)
    FOR             reduce using rule 48 (cycle -> whileCycle .)
    WHILE           reduce using rule 48 (cycle -> whileCycle .)
    RETURN          reduce using rule 48 (cycle -> whileCycle .)
    }               reduce using rule 48 (cycle -> whileCycle .)


state 73

    (49) whileCycle -> WHILE . ( expresion ) { body }

    (               shift and go to state 92


state 74

    (47) cycle -> forCycle .

    IF              reduce using rule 47 (cycle -> forCycle .)
    ID              reduce using rule 47 (cycle -> forCycle .)
    FOR             reduce using rule 47 (cycle -> forCycle .)
    WHILE           reduce using rule 47 (cycle -> forCycle .)
    RETURN          reduce using rule 47 (cycle -> forCycle .)
    }               reduce using rule 47 (cycle -> forCycle .)


state 75

    (44) body -> cyInstruction .

    }               reduce using rule 44 (body -> cyInstruction .)
    RETURN          reduce using rule 44 (body -> cyInstruction .)


state 76

    (15) instr -> cycle .

    IF              reduce using rule 15 (instr -> cycle .)
    ID              reduce using rule 15 (instr -> cycle .)
    FOR             reduce using rule 15 (instr -> cycle .)
    WHILE           reduce using rule 15 (instr -> cycle .)
    }               reduce using rule 15 (instr -> cycle .)
    RETURN          reduce using rule 15 (instr -> cycle .)


state 77

    (45) body -> empty .

    }               reduce using rule 45 (body -> empty .)
    RETURN          reduce using rule 45 (body -> empty .)


state 78

    (12) main -> MAIN { opVars body . }

    }               shift and go to state 93


state 79

    (50) forCycle -> FOR . ( assign ; expresion ; assign ) { body }

    (               shift and go to state 94


state 80

    (13) instr -> basicStatements . ;

    ;               shift and go to state 95


state 81

    (51) assign -> ID . assignOptions
    (57) funcCall -> ID . ( opParamCall )
    (52) assignOptions -> . init
    (53) assignOptions -> . initDict
    (54) assignOptions -> . [ expresion ] assignMatrix init
    (21) init -> . = initWith
    (24) initDict -> . = ( dictType : dictType )

    (               shift and go to state 96
    [               shift and go to state 101
    =               shift and go to state 98

    initDict                       shift and go to state 97
    assignOptions                  shift and go to state 99
    init                           shift and go to state 100

state 82

    (14) instr -> condition .

    IF              reduce using rule 14 (instr -> condition .)
    ID              reduce using rule 14 (instr -> condition .)
    FOR             reduce using rule 14 (instr -> condition .)
    WHILE           reduce using rule 14 (instr -> condition .)
    }               reduce using rule 14 (instr -> condition .)
    RETURN          reduce using rule 14 (instr -> condition .)


state 83

    (67) condition -> IF . ( expresion ) { body } optionalElse

    (               shift and go to state 102


state 84

    (17) basicStatements -> funcCall .

    ;               reduce using rule 17 (basicStatements -> funcCall .)


state 85

    (16) basicStatements -> assign .

    ;               reduce using rule 16 (basicStatements -> assign .)


state 86

    (62) struct -> structType [ CTED ] . optionalMatrix
    (65) optionalMatrix -> . [ CTED ]
    (66) optionalMatrix -> . empty
    (109) empty -> .

    [               shift and go to state 104
    ;               reduce using rule 109 (empty -> .)

    empty                          shift and go to state 105
    optionalMatrix                 shift and go to state 103

state 87

    (70) dict -> ( type : type . )

    )               shift and go to state 106


state 88

    (28) param -> type ID cyTypeParam . cyParam
    (29) cyParam -> . ; param
    (30) cyParam -> . empty
    (109) empty -> .

    ;               shift and go to state 107
    )               reduce using rule 109 (empty -> .)

    cyParam                        shift and go to state 108
    empty                          shift and go to state 109

state 89

    (35) opReturns -> RETURNS type { . opVars body return
    (2) opVars -> . vars
    (3) opVars -> . empty
    (6) vars -> . VARS declare
    (109) empty -> .

    VARS            shift and go to state 5
    IF              reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FOR             reduce using rule 109 (empty -> .)
    WHILE           reduce using rule 109 (empty -> .)
    RETURN          reduce using rule 109 (empty -> .)

    vars                           shift and go to state 6
    opVars                         shift and go to state 110
    empty                          shift and go to state 8

state 90

    (36) opReturns -> { opVars body .

    }               reduce using rule 36 (opReturns -> { opVars body .)


state 91

    (46) cyInstruction -> instr body .

    }               reduce using rule 46 (cyInstruction -> instr body .)
    RETURN          reduce using rule 46 (cyInstruction -> instr body .)


state 92

    (49) whileCycle -> WHILE ( . expresion ) { body }
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 116
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 93

    (12) main -> MAIN { opVars body } .

    }               reduce using rule 12 (main -> MAIN { opVars body } .)


state 94

    (50) forCycle -> FOR ( . assign ; expresion ; assign ) { body }
    (51) assign -> . ID assignOptions

    ID              shift and go to state 125

    assign                         shift and go to state 126

state 95

    (13) instr -> basicStatements ; .

    IF              reduce using rule 13 (instr -> basicStatements ; .)
    ID              reduce using rule 13 (instr -> basicStatements ; .)
    FOR             reduce using rule 13 (instr -> basicStatements ; .)
    WHILE           reduce using rule 13 (instr -> basicStatements ; .)
    }               reduce using rule 13 (instr -> basicStatements ; .)
    RETURN          reduce using rule 13 (instr -> basicStatements ; .)


state 96

    (57) funcCall -> ID ( . opParamCall )
    (58) opParamCall -> . expresion cyParamCall
    (59) opParamCall -> . empty
    (71) expresion -> . sExp cyExpresion
    (109) empty -> .
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    )               reduce using rule 109 (empty -> .)
    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 129
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    fact                           shift and go to state 124
    exp                            shift and go to state 114
    opParamCall                    shift and go to state 127
    empty                          shift and go to state 128

state 97

    (53) assignOptions -> initDict .

    ;               reduce using rule 53 (assignOptions -> initDict .)
    )               reduce using rule 53 (assignOptions -> initDict .)


state 98

    (21) init -> = . initWith
    (24) initDict -> = . ( dictType : dictType )
    (22) initWith -> . expresion
    (23) initWith -> . funcCall
    (71) expresion -> . sExp cyExpresion
    (57) funcCall -> . ID ( opParamCall )
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE

    (               shift and go to state 131
    ID              shift and go to state 132
    CTES            shift and go to state 117
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 133
    initWith                       shift and go to state 130
    funcCall                       shift and go to state 134
    term                           shift and go to state 118
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 99

    (51) assign -> ID assignOptions .

    ;               reduce using rule 51 (assign -> ID assignOptions .)
    )               reduce using rule 51 (assign -> ID assignOptions .)


state 100

    (52) assignOptions -> init .

    ;               reduce using rule 52 (assignOptions -> init .)
    )               reduce using rule 52 (assignOptions -> init .)


state 101

    (54) assignOptions -> [ . expresion ] assignMatrix init
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 135
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 102

    (67) condition -> IF ( . expresion ) { body } optionalElse
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 136
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 103

    (62) struct -> structType [ CTED ] optionalMatrix .

    ;               reduce using rule 62 (struct -> structType [ CTED ] optionalMatrix .)


state 104

    (65) optionalMatrix -> [ . CTED ]

    CTED            shift and go to state 137


state 105

    (66) optionalMatrix -> empty .

    ;               reduce using rule 66 (optionalMatrix -> empty .)


state 106

    (70) dict -> ( type : type ) .

    ;               reduce using rule 70 (dict -> ( type : type ) .)
    [               reduce using rule 70 (dict -> ( type : type ) .)


state 107

    (29) cyParam -> ; . param
    (28) param -> . type ID cyTypeParam cyParam
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 11
    FLOAT           shift and go to state 13
    STRING          shift and go to state 15
    OBJECT          shift and go to state 14
    BOOL            shift and go to state 17

    type                           shift and go to state 54
    param                          shift and go to state 138

state 108

    (28) param -> type ID cyTypeParam cyParam .

    )               reduce using rule 28 (param -> type ID cyTypeParam cyParam .)


state 109

    (30) cyParam -> empty .

    )               reduce using rule 30 (cyParam -> empty .)


state 110

    (35) opReturns -> RETURNS type { opVars . body return
    (44) body -> . cyInstruction
    (45) body -> . empty
    (46) cyInstruction -> . instr body
    (109) empty -> .
    (13) instr -> . basicStatements ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) basicStatements -> . assign
    (17) basicStatements -> . funcCall
    (67) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    RETURN          reduce using rule 109 (empty -> .)
    IF              shift and go to state 83
    ID              shift and go to state 81
    FOR             shift and go to state 79
    WHILE           shift and go to state 73

    body                           shift and go to state 139
    funcCall                       shift and go to state 84
    instr                          shift and go to state 71
    forCycle                       shift and go to state 74
    assign                         shift and go to state 85
    whileCycle                     shift and go to state 72
    basicStatements                shift and go to state 80
    condition                      shift and go to state 82
    cyInstruction                  shift and go to state 75
    empty                          shift and go to state 77
    cycle                          shift and go to state 76

state 111

    (107) cte -> TRUE .

    *               reduce using rule 107 (cte -> TRUE .)
    /               reduce using rule 107 (cte -> TRUE .)
    +               reduce using rule 107 (cte -> TRUE .)
    -               reduce using rule 107 (cte -> TRUE .)
    EQ              reduce using rule 107 (cte -> TRUE .)
    DIF             reduce using rule 107 (cte -> TRUE .)
    LTOEQ           reduce using rule 107 (cte -> TRUE .)
    GTOEQ           reduce using rule 107 (cte -> TRUE .)
    >               reduce using rule 107 (cte -> TRUE .)
    <               reduce using rule 107 (cte -> TRUE .)
    AND             reduce using rule 107 (cte -> TRUE .)
    OR              reduce using rule 107 (cte -> TRUE .)
    ;               reduce using rule 107 (cte -> TRUE .)
    ]               reduce using rule 107 (cte -> TRUE .)
    )               reduce using rule 107 (cte -> TRUE .)
    ,               reduce using rule 107 (cte -> TRUE .)
    :               reduce using rule 107 (cte -> TRUE .)


state 112

    (94) fact -> ( . expresion )
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 140
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 113

    (71) expresion -> sExp . cyExpresion
    (72) cyExpresion -> . AND expresion
    (73) cyExpresion -> . OR expresion
    (74) cyExpresion -> . empty
    (109) empty -> .

    AND             shift and go to state 141
    OR              shift and go to state 143
    )               reduce using rule 109 (empty -> .)
    ,               reduce using rule 109 (empty -> .)
    ;               reduce using rule 109 (empty -> .)
    ]               reduce using rule 109 (empty -> .)

    cyExpresion                    shift and go to state 142
    empty                          shift and go to state 144

state 114

    (75) sExp -> exp . opSExp
    (76) opSExp -> . EQ exp
    (77) opSExp -> . DIF exp
    (78) opSExp -> . LTOEQ exp
    (79) opSExp -> . GTOEQ exp
    (80) opSExp -> . > exp
    (81) opSExp -> . < exp
    (82) opSExp -> . empty
    (109) empty -> .

    EQ              shift and go to state 145
    DIF             shift and go to state 146
    LTOEQ           shift and go to state 149
    GTOEQ           shift and go to state 147
    >               shift and go to state 148
    <               shift and go to state 150
    AND             reduce using rule 109 (empty -> .)
    OR              reduce using rule 109 (empty -> .)
    )               reduce using rule 109 (empty -> .)
    ,               reduce using rule 109 (empty -> .)
    ;               reduce using rule 109 (empty -> .)
    ]               reduce using rule 109 (empty -> .)

    empty                          shift and go to state 151
    opSExp                         shift and go to state 152

state 115

    (95) fact -> ID . opAccess
    (57) funcCall -> ID . ( opParamCall )
    (96) opAccess -> . opStruct
    (97) opAccess -> . opDictionary
    (98) opAccess -> . empty
    (99) opStruct -> . [ expresion ] opMatrix
    (102) opDictionary -> . . dictIndex
    (109) empty -> .

    (               shift and go to state 96
    [               shift and go to state 156
    .               shift and go to state 157
    *               reduce using rule 109 (empty -> .)
    /               reduce using rule 109 (empty -> .)
    +               reduce using rule 109 (empty -> .)
    -               reduce using rule 109 (empty -> .)
    EQ              reduce using rule 109 (empty -> .)
    DIF             reduce using rule 109 (empty -> .)
    LTOEQ           reduce using rule 109 (empty -> .)
    GTOEQ           reduce using rule 109 (empty -> .)
    >               reduce using rule 109 (empty -> .)
    <               reduce using rule 109 (empty -> .)
    AND             reduce using rule 109 (empty -> .)
    OR              reduce using rule 109 (empty -> .)
    )               reduce using rule 109 (empty -> .)
    ,               reduce using rule 109 (empty -> .)
    ]               reduce using rule 109 (empty -> .)
    ;               reduce using rule 109 (empty -> .)

    opDictionary                   shift and go to state 158
    opStruct                       shift and go to state 153
    opAccess                       shift and go to state 154
    empty                          shift and go to state 155

state 116

    (49) whileCycle -> WHILE ( expresion . ) { body }

    )               shift and go to state 159


state 117

    (91) fact -> CTES .

    *               reduce using rule 91 (fact -> CTES .)
    /               reduce using rule 91 (fact -> CTES .)
    +               reduce using rule 91 (fact -> CTES .)
    -               reduce using rule 91 (fact -> CTES .)
    EQ              reduce using rule 91 (fact -> CTES .)
    DIF             reduce using rule 91 (fact -> CTES .)
    LTOEQ           reduce using rule 91 (fact -> CTES .)
    GTOEQ           reduce using rule 91 (fact -> CTES .)
    >               reduce using rule 91 (fact -> CTES .)
    <               reduce using rule 91 (fact -> CTES .)
    AND             reduce using rule 91 (fact -> CTES .)
    OR              reduce using rule 91 (fact -> CTES .)
    )               reduce using rule 91 (fact -> CTES .)
    ;               reduce using rule 91 (fact -> CTES .)
    ]               reduce using rule 91 (fact -> CTES .)
    ,               reduce using rule 91 (fact -> CTES .)


state 118

    (83) exp -> term . cyExp
    (84) cyExp -> . + term
    (85) cyExp -> . - term
    (86) cyExp -> . empty
    (109) empty -> .

    +               shift and go to state 162
    -               shift and go to state 161
    EQ              reduce using rule 109 (empty -> .)
    DIF             reduce using rule 109 (empty -> .)
    LTOEQ           reduce using rule 109 (empty -> .)
    GTOEQ           reduce using rule 109 (empty -> .)
    >               reduce using rule 109 (empty -> .)
    <               reduce using rule 109 (empty -> .)
    AND             reduce using rule 109 (empty -> .)
    OR              reduce using rule 109 (empty -> .)
    )               reduce using rule 109 (empty -> .)
    ,               reduce using rule 109 (empty -> .)
    ;               reduce using rule 109 (empty -> .)
    ]               reduce using rule 109 (empty -> .)

    cyExp                          shift and go to state 160
    empty                          shift and go to state 163

state 119

    (108) cte -> FALSE .

    *               reduce using rule 108 (cte -> FALSE .)
    /               reduce using rule 108 (cte -> FALSE .)
    +               reduce using rule 108 (cte -> FALSE .)
    -               reduce using rule 108 (cte -> FALSE .)
    EQ              reduce using rule 108 (cte -> FALSE .)
    DIF             reduce using rule 108 (cte -> FALSE .)
    LTOEQ           reduce using rule 108 (cte -> FALSE .)
    GTOEQ           reduce using rule 108 (cte -> FALSE .)
    >               reduce using rule 108 (cte -> FALSE .)
    <               reduce using rule 108 (cte -> FALSE .)
    AND             reduce using rule 108 (cte -> FALSE .)
    OR              reduce using rule 108 (cte -> FALSE .)
    ;               reduce using rule 108 (cte -> FALSE .)
    ]               reduce using rule 108 (cte -> FALSE .)
    )               reduce using rule 108 (cte -> FALSE .)
    ,               reduce using rule 108 (cte -> FALSE .)
    :               reduce using rule 108 (cte -> FALSE .)


state 120

    (93) fact -> funcCall .

    *               reduce using rule 93 (fact -> funcCall .)
    /               reduce using rule 93 (fact -> funcCall .)
    +               reduce using rule 93 (fact -> funcCall .)
    -               reduce using rule 93 (fact -> funcCall .)
    EQ              reduce using rule 93 (fact -> funcCall .)
    DIF             reduce using rule 93 (fact -> funcCall .)
    LTOEQ           reduce using rule 93 (fact -> funcCall .)
    GTOEQ           reduce using rule 93 (fact -> funcCall .)
    >               reduce using rule 93 (fact -> funcCall .)
    <               reduce using rule 93 (fact -> funcCall .)
    AND             reduce using rule 93 (fact -> funcCall .)
    OR              reduce using rule 93 (fact -> funcCall .)
    )               reduce using rule 93 (fact -> funcCall .)
    ]               reduce using rule 93 (fact -> funcCall .)
    ;               reduce using rule 93 (fact -> funcCall .)
    ,               reduce using rule 93 (fact -> funcCall .)


state 121

    (92) fact -> cte .

    *               reduce using rule 92 (fact -> cte .)
    /               reduce using rule 92 (fact -> cte .)
    +               reduce using rule 92 (fact -> cte .)
    -               reduce using rule 92 (fact -> cte .)
    EQ              reduce using rule 92 (fact -> cte .)
    DIF             reduce using rule 92 (fact -> cte .)
    LTOEQ           reduce using rule 92 (fact -> cte .)
    GTOEQ           reduce using rule 92 (fact -> cte .)
    >               reduce using rule 92 (fact -> cte .)
    <               reduce using rule 92 (fact -> cte .)
    AND             reduce using rule 92 (fact -> cte .)
    OR              reduce using rule 92 (fact -> cte .)
    )               reduce using rule 92 (fact -> cte .)
    ;               reduce using rule 92 (fact -> cte .)
    ]               reduce using rule 92 (fact -> cte .)
    ,               reduce using rule 92 (fact -> cte .)


state 122

    (106) cte -> CTEF .

    *               reduce using rule 106 (cte -> CTEF .)
    /               reduce using rule 106 (cte -> CTEF .)
    +               reduce using rule 106 (cte -> CTEF .)
    -               reduce using rule 106 (cte -> CTEF .)
    EQ              reduce using rule 106 (cte -> CTEF .)
    DIF             reduce using rule 106 (cte -> CTEF .)
    LTOEQ           reduce using rule 106 (cte -> CTEF .)
    GTOEQ           reduce using rule 106 (cte -> CTEF .)
    >               reduce using rule 106 (cte -> CTEF .)
    <               reduce using rule 106 (cte -> CTEF .)
    AND             reduce using rule 106 (cte -> CTEF .)
    OR              reduce using rule 106 (cte -> CTEF .)
    ;               reduce using rule 106 (cte -> CTEF .)
    ]               reduce using rule 106 (cte -> CTEF .)
    )               reduce using rule 106 (cte -> CTEF .)
    ,               reduce using rule 106 (cte -> CTEF .)
    :               reduce using rule 106 (cte -> CTEF .)


state 123

    (105) cte -> CTED .

    *               reduce using rule 105 (cte -> CTED .)
    /               reduce using rule 105 (cte -> CTED .)
    +               reduce using rule 105 (cte -> CTED .)
    -               reduce using rule 105 (cte -> CTED .)
    EQ              reduce using rule 105 (cte -> CTED .)
    DIF             reduce using rule 105 (cte -> CTED .)
    LTOEQ           reduce using rule 105 (cte -> CTED .)
    GTOEQ           reduce using rule 105 (cte -> CTED .)
    >               reduce using rule 105 (cte -> CTED .)
    <               reduce using rule 105 (cte -> CTED .)
    AND             reduce using rule 105 (cte -> CTED .)
    OR              reduce using rule 105 (cte -> CTED .)
    ;               reduce using rule 105 (cte -> CTED .)
    ]               reduce using rule 105 (cte -> CTED .)
    )               reduce using rule 105 (cte -> CTED .)
    ,               reduce using rule 105 (cte -> CTED .)
    :               reduce using rule 105 (cte -> CTED .)


state 124

    (87) term -> fact . cyTerm
    (88) cyTerm -> . * fact
    (89) cyTerm -> . / fact
    (90) cyTerm -> . empty
    (109) empty -> .

    *               shift and go to state 166
    /               shift and go to state 167
    +               reduce using rule 109 (empty -> .)
    -               reduce using rule 109 (empty -> .)
    EQ              reduce using rule 109 (empty -> .)
    DIF             reduce using rule 109 (empty -> .)
    LTOEQ           reduce using rule 109 (empty -> .)
    GTOEQ           reduce using rule 109 (empty -> .)
    >               reduce using rule 109 (empty -> .)
    <               reduce using rule 109 (empty -> .)
    AND             reduce using rule 109 (empty -> .)
    OR              reduce using rule 109 (empty -> .)
    )               reduce using rule 109 (empty -> .)
    ,               reduce using rule 109 (empty -> .)
    ;               reduce using rule 109 (empty -> .)
    ]               reduce using rule 109 (empty -> .)

    cyTerm                         shift and go to state 164
    empty                          shift and go to state 165

state 125

    (51) assign -> ID . assignOptions
    (52) assignOptions -> . init
    (53) assignOptions -> . initDict
    (54) assignOptions -> . [ expresion ] assignMatrix init
    (21) init -> . = initWith
    (24) initDict -> . = ( dictType : dictType )

    [               shift and go to state 101
    =               shift and go to state 98

    initDict                       shift and go to state 97
    assignOptions                  shift and go to state 99
    init                           shift and go to state 100

state 126

    (50) forCycle -> FOR ( assign . ; expresion ; assign ) { body }

    ;               shift and go to state 168


state 127

    (57) funcCall -> ID ( opParamCall . )

    )               shift and go to state 169


state 128

    (59) opParamCall -> empty .

    )               reduce using rule 59 (opParamCall -> empty .)


state 129

    (58) opParamCall -> expresion . cyParamCall
    (60) cyParamCall -> . , expresion cyParamCall
    (61) cyParamCall -> . empty
    (109) empty -> .

    ,               shift and go to state 171
    )               reduce using rule 109 (empty -> .)

    cyParamCall                    shift and go to state 170
    empty                          shift and go to state 172

state 130

    (21) init -> = initWith .

    ;               reduce using rule 21 (init -> = initWith .)
    )               reduce using rule 21 (init -> = initWith .)


state 131

    (24) initDict -> = ( . dictType : dictType )
    (94) fact -> ( . expresion )
    (25) dictType -> . CTES
    (26) dictType -> . cte
    (27) dictType -> . ID
    (71) expresion -> . sExp cyExpresion
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 175
    ID              shift and go to state 174
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119
    (               shift and go to state 112

    dictType                       shift and go to state 173
    expresion                      shift and go to state 140
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 176
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 132

    (57) funcCall -> ID . ( opParamCall )
    (95) fact -> ID . opAccess
    (96) opAccess -> . opStruct
    (97) opAccess -> . opDictionary
    (98) opAccess -> . empty
    (99) opStruct -> . [ expresion ] opMatrix
    (102) opDictionary -> . . dictIndex
    (109) empty -> .

    (               shift and go to state 96
    [               shift and go to state 156
    .               shift and go to state 157
    *               reduce using rule 109 (empty -> .)
    /               reduce using rule 109 (empty -> .)
    +               reduce using rule 109 (empty -> .)
    -               reduce using rule 109 (empty -> .)
    EQ              reduce using rule 109 (empty -> .)
    DIF             reduce using rule 109 (empty -> .)
    LTOEQ           reduce using rule 109 (empty -> .)
    GTOEQ           reduce using rule 109 (empty -> .)
    >               reduce using rule 109 (empty -> .)
    <               reduce using rule 109 (empty -> .)
    AND             reduce using rule 109 (empty -> .)
    OR              reduce using rule 109 (empty -> .)
    ;               reduce using rule 109 (empty -> .)
    )               reduce using rule 109 (empty -> .)

    opDictionary                   shift and go to state 158
    opStruct                       shift and go to state 153
    opAccess                       shift and go to state 154
    empty                          shift and go to state 155

state 133

    (22) initWith -> expresion .

    ;               reduce using rule 22 (initWith -> expresion .)
    )               reduce using rule 22 (initWith -> expresion .)


state 134

    (23) initWith -> funcCall .
    (93) fact -> funcCall .

  ! reduce/reduce conflict for ; resolved using rule 23 (initWith -> funcCall .)
  ! reduce/reduce conflict for ) resolved using rule 23 (initWith -> funcCall .)
    ;               reduce using rule 23 (initWith -> funcCall .)
    )               reduce using rule 23 (initWith -> funcCall .)
    *               reduce using rule 93 (fact -> funcCall .)
    /               reduce using rule 93 (fact -> funcCall .)
    +               reduce using rule 93 (fact -> funcCall .)
    -               reduce using rule 93 (fact -> funcCall .)
    EQ              reduce using rule 93 (fact -> funcCall .)
    DIF             reduce using rule 93 (fact -> funcCall .)
    LTOEQ           reduce using rule 93 (fact -> funcCall .)
    GTOEQ           reduce using rule 93 (fact -> funcCall .)
    >               reduce using rule 93 (fact -> funcCall .)
    <               reduce using rule 93 (fact -> funcCall .)
    AND             reduce using rule 93 (fact -> funcCall .)
    OR              reduce using rule 93 (fact -> funcCall .)

  ! ;               [ reduce using rule 93 (fact -> funcCall .) ]
  ! )               [ reduce using rule 93 (fact -> funcCall .) ]


state 135

    (54) assignOptions -> [ expresion . ] assignMatrix init

    ]               shift and go to state 177


state 136

    (67) condition -> IF ( expresion . ) { body } optionalElse

    )               shift and go to state 178


state 137

    (65) optionalMatrix -> [ CTED . ]

    ]               shift and go to state 179


state 138

    (29) cyParam -> ; param .

    )               reduce using rule 29 (cyParam -> ; param .)


state 139

    (35) opReturns -> RETURNS type { opVars body . return
    (32) return -> . RETURN expresion ;

    RETURN          shift and go to state 181

    return                         shift and go to state 180

state 140

    (94) fact -> ( expresion . )

    )               shift and go to state 182


state 141

    (72) cyExpresion -> AND . expresion
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 183
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 142

    (71) expresion -> sExp cyExpresion .

    ]               reduce using rule 71 (expresion -> sExp cyExpresion .)
    )               reduce using rule 71 (expresion -> sExp cyExpresion .)
    ,               reduce using rule 71 (expresion -> sExp cyExpresion .)
    ;               reduce using rule 71 (expresion -> sExp cyExpresion .)


state 143

    (73) cyExpresion -> OR . expresion
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 184
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 144

    (74) cyExpresion -> empty .

    )               reduce using rule 74 (cyExpresion -> empty .)
    ,               reduce using rule 74 (cyExpresion -> empty .)
    ;               reduce using rule 74 (cyExpresion -> empty .)
    ]               reduce using rule 74 (cyExpresion -> empty .)


state 145

    (76) opSExp -> EQ . exp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    cte                            shift and go to state 121
    exp                            shift and go to state 185
    fact                           shift and go to state 124

state 146

    (77) opSExp -> DIF . exp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    cte                            shift and go to state 121
    exp                            shift and go to state 186
    fact                           shift and go to state 124

state 147

    (79) opSExp -> GTOEQ . exp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    cte                            shift and go to state 121
    exp                            shift and go to state 187
    fact                           shift and go to state 124

state 148

    (80) opSExp -> > . exp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    cte                            shift and go to state 121
    exp                            shift and go to state 188
    fact                           shift and go to state 124

state 149

    (78) opSExp -> LTOEQ . exp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    cte                            shift and go to state 121
    exp                            shift and go to state 189
    fact                           shift and go to state 124

state 150

    (81) opSExp -> < . exp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    cte                            shift and go to state 121
    exp                            shift and go to state 190
    fact                           shift and go to state 124

state 151

    (82) opSExp -> empty .

    AND             reduce using rule 82 (opSExp -> empty .)
    OR              reduce using rule 82 (opSExp -> empty .)
    )               reduce using rule 82 (opSExp -> empty .)
    ,               reduce using rule 82 (opSExp -> empty .)
    ;               reduce using rule 82 (opSExp -> empty .)
    ]               reduce using rule 82 (opSExp -> empty .)


state 152

    (75) sExp -> exp opSExp .

    AND             reduce using rule 75 (sExp -> exp opSExp .)
    OR              reduce using rule 75 (sExp -> exp opSExp .)
    ]               reduce using rule 75 (sExp -> exp opSExp .)
    )               reduce using rule 75 (sExp -> exp opSExp .)
    ,               reduce using rule 75 (sExp -> exp opSExp .)
    ;               reduce using rule 75 (sExp -> exp opSExp .)


state 153

    (96) opAccess -> opStruct .

    *               reduce using rule 96 (opAccess -> opStruct .)
    /               reduce using rule 96 (opAccess -> opStruct .)
    +               reduce using rule 96 (opAccess -> opStruct .)
    -               reduce using rule 96 (opAccess -> opStruct .)
    EQ              reduce using rule 96 (opAccess -> opStruct .)
    DIF             reduce using rule 96 (opAccess -> opStruct .)
    LTOEQ           reduce using rule 96 (opAccess -> opStruct .)
    GTOEQ           reduce using rule 96 (opAccess -> opStruct .)
    >               reduce using rule 96 (opAccess -> opStruct .)
    <               reduce using rule 96 (opAccess -> opStruct .)
    AND             reduce using rule 96 (opAccess -> opStruct .)
    OR              reduce using rule 96 (opAccess -> opStruct .)
    )               reduce using rule 96 (opAccess -> opStruct .)
    ;               reduce using rule 96 (opAccess -> opStruct .)
    ,               reduce using rule 96 (opAccess -> opStruct .)
    ]               reduce using rule 96 (opAccess -> opStruct .)


state 154

    (95) fact -> ID opAccess .

    *               reduce using rule 95 (fact -> ID opAccess .)
    /               reduce using rule 95 (fact -> ID opAccess .)
    +               reduce using rule 95 (fact -> ID opAccess .)
    -               reduce using rule 95 (fact -> ID opAccess .)
    EQ              reduce using rule 95 (fact -> ID opAccess .)
    DIF             reduce using rule 95 (fact -> ID opAccess .)
    LTOEQ           reduce using rule 95 (fact -> ID opAccess .)
    GTOEQ           reduce using rule 95 (fact -> ID opAccess .)
    >               reduce using rule 95 (fact -> ID opAccess .)
    <               reduce using rule 95 (fact -> ID opAccess .)
    AND             reduce using rule 95 (fact -> ID opAccess .)
    OR              reduce using rule 95 (fact -> ID opAccess .)
    )               reduce using rule 95 (fact -> ID opAccess .)
    ;               reduce using rule 95 (fact -> ID opAccess .)
    ]               reduce using rule 95 (fact -> ID opAccess .)
    ,               reduce using rule 95 (fact -> ID opAccess .)


state 155

    (98) opAccess -> empty .

    *               reduce using rule 98 (opAccess -> empty .)
    /               reduce using rule 98 (opAccess -> empty .)
    +               reduce using rule 98 (opAccess -> empty .)
    -               reduce using rule 98 (opAccess -> empty .)
    EQ              reduce using rule 98 (opAccess -> empty .)
    DIF             reduce using rule 98 (opAccess -> empty .)
    LTOEQ           reduce using rule 98 (opAccess -> empty .)
    GTOEQ           reduce using rule 98 (opAccess -> empty .)
    >               reduce using rule 98 (opAccess -> empty .)
    <               reduce using rule 98 (opAccess -> empty .)
    AND             reduce using rule 98 (opAccess -> empty .)
    OR              reduce using rule 98 (opAccess -> empty .)
    )               reduce using rule 98 (opAccess -> empty .)
    ;               reduce using rule 98 (opAccess -> empty .)
    ,               reduce using rule 98 (opAccess -> empty .)
    ]               reduce using rule 98 (opAccess -> empty .)


state 156

    (99) opStruct -> [ . expresion ] opMatrix
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 191
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 157

    (102) opDictionary -> . . dictIndex
    (103) dictIndex -> . FIRST
    (104) dictIndex -> . LAST

    FIRST           shift and go to state 192
    LAST            shift and go to state 193

    dictIndex                      shift and go to state 194

state 158

    (97) opAccess -> opDictionary .

    *               reduce using rule 97 (opAccess -> opDictionary .)
    /               reduce using rule 97 (opAccess -> opDictionary .)
    +               reduce using rule 97 (opAccess -> opDictionary .)
    -               reduce using rule 97 (opAccess -> opDictionary .)
    EQ              reduce using rule 97 (opAccess -> opDictionary .)
    DIF             reduce using rule 97 (opAccess -> opDictionary .)
    LTOEQ           reduce using rule 97 (opAccess -> opDictionary .)
    GTOEQ           reduce using rule 97 (opAccess -> opDictionary .)
    >               reduce using rule 97 (opAccess -> opDictionary .)
    <               reduce using rule 97 (opAccess -> opDictionary .)
    AND             reduce using rule 97 (opAccess -> opDictionary .)
    OR              reduce using rule 97 (opAccess -> opDictionary .)
    )               reduce using rule 97 (opAccess -> opDictionary .)
    ;               reduce using rule 97 (opAccess -> opDictionary .)
    ,               reduce using rule 97 (opAccess -> opDictionary .)
    ]               reduce using rule 97 (opAccess -> opDictionary .)


state 159

    (49) whileCycle -> WHILE ( expresion ) . { body }

    {               shift and go to state 195


state 160

    (83) exp -> term cyExp .

    EQ              reduce using rule 83 (exp -> term cyExp .)
    DIF             reduce using rule 83 (exp -> term cyExp .)
    LTOEQ           reduce using rule 83 (exp -> term cyExp .)
    GTOEQ           reduce using rule 83 (exp -> term cyExp .)
    >               reduce using rule 83 (exp -> term cyExp .)
    <               reduce using rule 83 (exp -> term cyExp .)
    AND             reduce using rule 83 (exp -> term cyExp .)
    OR              reduce using rule 83 (exp -> term cyExp .)
    ,               reduce using rule 83 (exp -> term cyExp .)
    )               reduce using rule 83 (exp -> term cyExp .)
    ;               reduce using rule 83 (exp -> term cyExp .)
    ]               reduce using rule 83 (exp -> term cyExp .)


state 161

    (85) cyExp -> - . term
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    term                           shift and go to state 196
    funcCall                       shift and go to state 120
    cte                            shift and go to state 121
    fact                           shift and go to state 124

state 162

    (84) cyExp -> + . term
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    term                           shift and go to state 197
    funcCall                       shift and go to state 120
    cte                            shift and go to state 121
    fact                           shift and go to state 124

state 163

    (86) cyExp -> empty .

    EQ              reduce using rule 86 (cyExp -> empty .)
    DIF             reduce using rule 86 (cyExp -> empty .)
    LTOEQ           reduce using rule 86 (cyExp -> empty .)
    GTOEQ           reduce using rule 86 (cyExp -> empty .)
    >               reduce using rule 86 (cyExp -> empty .)
    <               reduce using rule 86 (cyExp -> empty .)
    AND             reduce using rule 86 (cyExp -> empty .)
    OR              reduce using rule 86 (cyExp -> empty .)
    )               reduce using rule 86 (cyExp -> empty .)
    ,               reduce using rule 86 (cyExp -> empty .)
    ;               reduce using rule 86 (cyExp -> empty .)
    ]               reduce using rule 86 (cyExp -> empty .)


state 164

    (87) term -> fact cyTerm .

    EQ              reduce using rule 87 (term -> fact cyTerm .)
    DIF             reduce using rule 87 (term -> fact cyTerm .)
    LTOEQ           reduce using rule 87 (term -> fact cyTerm .)
    GTOEQ           reduce using rule 87 (term -> fact cyTerm .)
    >               reduce using rule 87 (term -> fact cyTerm .)
    <               reduce using rule 87 (term -> fact cyTerm .)
    AND             reduce using rule 87 (term -> fact cyTerm .)
    OR              reduce using rule 87 (term -> fact cyTerm .)
    )               reduce using rule 87 (term -> fact cyTerm .)
    ,               reduce using rule 87 (term -> fact cyTerm .)
    ;               reduce using rule 87 (term -> fact cyTerm .)
    ]               reduce using rule 87 (term -> fact cyTerm .)
    +               reduce using rule 87 (term -> fact cyTerm .)
    -               reduce using rule 87 (term -> fact cyTerm .)


state 165

    (90) cyTerm -> empty .

    +               reduce using rule 90 (cyTerm -> empty .)
    -               reduce using rule 90 (cyTerm -> empty .)
    EQ              reduce using rule 90 (cyTerm -> empty .)
    DIF             reduce using rule 90 (cyTerm -> empty .)
    LTOEQ           reduce using rule 90 (cyTerm -> empty .)
    GTOEQ           reduce using rule 90 (cyTerm -> empty .)
    >               reduce using rule 90 (cyTerm -> empty .)
    <               reduce using rule 90 (cyTerm -> empty .)
    AND             reduce using rule 90 (cyTerm -> empty .)
    OR              reduce using rule 90 (cyTerm -> empty .)
    )               reduce using rule 90 (cyTerm -> empty .)
    ,               reduce using rule 90 (cyTerm -> empty .)
    ;               reduce using rule 90 (cyTerm -> empty .)
    ]               reduce using rule 90 (cyTerm -> empty .)


state 166

    (88) cyTerm -> * . fact
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    funcCall                       shift and go to state 120
    cte                            shift and go to state 121
    fact                           shift and go to state 198

state 167

    (89) cyTerm -> / . fact
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    funcCall                       shift and go to state 120
    cte                            shift and go to state 121
    fact                           shift and go to state 199

state 168

    (50) forCycle -> FOR ( assign ; . expresion ; assign ) { body }
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 200
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 169

    (57) funcCall -> ID ( opParamCall ) .

    *               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    /               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    +               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    -               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    EQ              reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    DIF             reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    LTOEQ           reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    GTOEQ           reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    >               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    <               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    AND             reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    OR              reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    )               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    ;               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    ,               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    ]               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)


state 170

    (58) opParamCall -> expresion cyParamCall .

    )               reduce using rule 58 (opParamCall -> expresion cyParamCall .)


state 171

    (60) cyParamCall -> , . expresion cyParamCall
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 201
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 172

    (61) cyParamCall -> empty .

    )               reduce using rule 61 (cyParamCall -> empty .)


state 173

    (24) initDict -> = ( dictType . : dictType )

    :               shift and go to state 202


state 174

    (27) dictType -> ID .
    (95) fact -> ID . opAccess
    (57) funcCall -> ID . ( opParamCall )
    (96) opAccess -> . opStruct
    (97) opAccess -> . opDictionary
    (98) opAccess -> . empty
    (99) opStruct -> . [ expresion ] opMatrix
    (102) opDictionary -> . . dictIndex
    (109) empty -> .

    :               reduce using rule 27 (dictType -> ID .)
    (               shift and go to state 96
    [               shift and go to state 156
    .               shift and go to state 157
    *               reduce using rule 109 (empty -> .)
    /               reduce using rule 109 (empty -> .)
    +               reduce using rule 109 (empty -> .)
    -               reduce using rule 109 (empty -> .)
    EQ              reduce using rule 109 (empty -> .)
    DIF             reduce using rule 109 (empty -> .)
    LTOEQ           reduce using rule 109 (empty -> .)
    GTOEQ           reduce using rule 109 (empty -> .)
    >               reduce using rule 109 (empty -> .)
    <               reduce using rule 109 (empty -> .)
    AND             reduce using rule 109 (empty -> .)
    OR              reduce using rule 109 (empty -> .)
    )               reduce using rule 109 (empty -> .)

    opDictionary                   shift and go to state 158
    opStruct                       shift and go to state 153
    opAccess                       shift and go to state 154
    empty                          shift and go to state 155

state 175

    (25) dictType -> CTES .
    (91) fact -> CTES .

    :               reduce using rule 25 (dictType -> CTES .)
    *               reduce using rule 91 (fact -> CTES .)
    /               reduce using rule 91 (fact -> CTES .)
    +               reduce using rule 91 (fact -> CTES .)
    -               reduce using rule 91 (fact -> CTES .)
    EQ              reduce using rule 91 (fact -> CTES .)
    DIF             reduce using rule 91 (fact -> CTES .)
    LTOEQ           reduce using rule 91 (fact -> CTES .)
    GTOEQ           reduce using rule 91 (fact -> CTES .)
    >               reduce using rule 91 (fact -> CTES .)
    <               reduce using rule 91 (fact -> CTES .)
    AND             reduce using rule 91 (fact -> CTES .)
    OR              reduce using rule 91 (fact -> CTES .)
    )               reduce using rule 91 (fact -> CTES .)


state 176

    (26) dictType -> cte .
    (92) fact -> cte .

    :               reduce using rule 26 (dictType -> cte .)
    *               reduce using rule 92 (fact -> cte .)
    /               reduce using rule 92 (fact -> cte .)
    +               reduce using rule 92 (fact -> cte .)
    -               reduce using rule 92 (fact -> cte .)
    EQ              reduce using rule 92 (fact -> cte .)
    DIF             reduce using rule 92 (fact -> cte .)
    LTOEQ           reduce using rule 92 (fact -> cte .)
    GTOEQ           reduce using rule 92 (fact -> cte .)
    >               reduce using rule 92 (fact -> cte .)
    <               reduce using rule 92 (fact -> cte .)
    AND             reduce using rule 92 (fact -> cte .)
    OR              reduce using rule 92 (fact -> cte .)
    )               reduce using rule 92 (fact -> cte .)


state 177

    (54) assignOptions -> [ expresion ] . assignMatrix init
    (55) assignMatrix -> . [ expresion ]
    (56) assignMatrix -> . empty
    (109) empty -> .

    [               shift and go to state 204
    =               reduce using rule 109 (empty -> .)

    assignMatrix                   shift and go to state 203
    empty                          shift and go to state 205

state 178

    (67) condition -> IF ( expresion ) . { body } optionalElse

    {               shift and go to state 206


state 179

    (65) optionalMatrix -> [ CTED ] .

    ;               reduce using rule 65 (optionalMatrix -> [ CTED ] .)


state 180

    (35) opReturns -> RETURNS type { opVars body return .

    }               reduce using rule 35 (opReturns -> RETURNS type { opVars body return .)


state 181

    (32) return -> RETURN . expresion ;
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 207
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 182

    (94) fact -> ( expresion ) .

    *               reduce using rule 94 (fact -> ( expresion ) .)
    /               reduce using rule 94 (fact -> ( expresion ) .)
    +               reduce using rule 94 (fact -> ( expresion ) .)
    -               reduce using rule 94 (fact -> ( expresion ) .)
    EQ              reduce using rule 94 (fact -> ( expresion ) .)
    DIF             reduce using rule 94 (fact -> ( expresion ) .)
    LTOEQ           reduce using rule 94 (fact -> ( expresion ) .)
    GTOEQ           reduce using rule 94 (fact -> ( expresion ) .)
    >               reduce using rule 94 (fact -> ( expresion ) .)
    <               reduce using rule 94 (fact -> ( expresion ) .)
    AND             reduce using rule 94 (fact -> ( expresion ) .)
    OR              reduce using rule 94 (fact -> ( expresion ) .)
    )               reduce using rule 94 (fact -> ( expresion ) .)
    ;               reduce using rule 94 (fact -> ( expresion ) .)
    ]               reduce using rule 94 (fact -> ( expresion ) .)
    ,               reduce using rule 94 (fact -> ( expresion ) .)


state 183

    (72) cyExpresion -> AND expresion .

    )               reduce using rule 72 (cyExpresion -> AND expresion .)
    ,               reduce using rule 72 (cyExpresion -> AND expresion .)
    ;               reduce using rule 72 (cyExpresion -> AND expresion .)
    ]               reduce using rule 72 (cyExpresion -> AND expresion .)


state 184

    (73) cyExpresion -> OR expresion .

    )               reduce using rule 73 (cyExpresion -> OR expresion .)
    ,               reduce using rule 73 (cyExpresion -> OR expresion .)
    ;               reduce using rule 73 (cyExpresion -> OR expresion .)
    ]               reduce using rule 73 (cyExpresion -> OR expresion .)


state 185

    (76) opSExp -> EQ exp .

    AND             reduce using rule 76 (opSExp -> EQ exp .)
    OR              reduce using rule 76 (opSExp -> EQ exp .)
    )               reduce using rule 76 (opSExp -> EQ exp .)
    ,               reduce using rule 76 (opSExp -> EQ exp .)
    ;               reduce using rule 76 (opSExp -> EQ exp .)
    ]               reduce using rule 76 (opSExp -> EQ exp .)


state 186

    (77) opSExp -> DIF exp .

    AND             reduce using rule 77 (opSExp -> DIF exp .)
    OR              reduce using rule 77 (opSExp -> DIF exp .)
    )               reduce using rule 77 (opSExp -> DIF exp .)
    ,               reduce using rule 77 (opSExp -> DIF exp .)
    ;               reduce using rule 77 (opSExp -> DIF exp .)
    ]               reduce using rule 77 (opSExp -> DIF exp .)


state 187

    (79) opSExp -> GTOEQ exp .

    AND             reduce using rule 79 (opSExp -> GTOEQ exp .)
    OR              reduce using rule 79 (opSExp -> GTOEQ exp .)
    )               reduce using rule 79 (opSExp -> GTOEQ exp .)
    ,               reduce using rule 79 (opSExp -> GTOEQ exp .)
    ;               reduce using rule 79 (opSExp -> GTOEQ exp .)
    ]               reduce using rule 79 (opSExp -> GTOEQ exp .)


state 188

    (80) opSExp -> > exp .

    AND             reduce using rule 80 (opSExp -> > exp .)
    OR              reduce using rule 80 (opSExp -> > exp .)
    )               reduce using rule 80 (opSExp -> > exp .)
    ,               reduce using rule 80 (opSExp -> > exp .)
    ;               reduce using rule 80 (opSExp -> > exp .)
    ]               reduce using rule 80 (opSExp -> > exp .)


state 189

    (78) opSExp -> LTOEQ exp .

    AND             reduce using rule 78 (opSExp -> LTOEQ exp .)
    OR              reduce using rule 78 (opSExp -> LTOEQ exp .)
    )               reduce using rule 78 (opSExp -> LTOEQ exp .)
    ,               reduce using rule 78 (opSExp -> LTOEQ exp .)
    ;               reduce using rule 78 (opSExp -> LTOEQ exp .)
    ]               reduce using rule 78 (opSExp -> LTOEQ exp .)


state 190

    (81) opSExp -> < exp .

    AND             reduce using rule 81 (opSExp -> < exp .)
    OR              reduce using rule 81 (opSExp -> < exp .)
    )               reduce using rule 81 (opSExp -> < exp .)
    ,               reduce using rule 81 (opSExp -> < exp .)
    ;               reduce using rule 81 (opSExp -> < exp .)
    ]               reduce using rule 81 (opSExp -> < exp .)


state 191

    (99) opStruct -> [ expresion . ] opMatrix

    ]               shift and go to state 208


state 192

    (103) dictIndex -> FIRST .

    *               reduce using rule 103 (dictIndex -> FIRST .)
    /               reduce using rule 103 (dictIndex -> FIRST .)
    +               reduce using rule 103 (dictIndex -> FIRST .)
    -               reduce using rule 103 (dictIndex -> FIRST .)
    EQ              reduce using rule 103 (dictIndex -> FIRST .)
    DIF             reduce using rule 103 (dictIndex -> FIRST .)
    LTOEQ           reduce using rule 103 (dictIndex -> FIRST .)
    GTOEQ           reduce using rule 103 (dictIndex -> FIRST .)
    >               reduce using rule 103 (dictIndex -> FIRST .)
    <               reduce using rule 103 (dictIndex -> FIRST .)
    AND             reduce using rule 103 (dictIndex -> FIRST .)
    OR              reduce using rule 103 (dictIndex -> FIRST .)
    )               reduce using rule 103 (dictIndex -> FIRST .)
    ,               reduce using rule 103 (dictIndex -> FIRST .)
    ]               reduce using rule 103 (dictIndex -> FIRST .)
    ;               reduce using rule 103 (dictIndex -> FIRST .)


state 193

    (104) dictIndex -> LAST .

    *               reduce using rule 104 (dictIndex -> LAST .)
    /               reduce using rule 104 (dictIndex -> LAST .)
    +               reduce using rule 104 (dictIndex -> LAST .)
    -               reduce using rule 104 (dictIndex -> LAST .)
    EQ              reduce using rule 104 (dictIndex -> LAST .)
    DIF             reduce using rule 104 (dictIndex -> LAST .)
    LTOEQ           reduce using rule 104 (dictIndex -> LAST .)
    GTOEQ           reduce using rule 104 (dictIndex -> LAST .)
    >               reduce using rule 104 (dictIndex -> LAST .)
    <               reduce using rule 104 (dictIndex -> LAST .)
    AND             reduce using rule 104 (dictIndex -> LAST .)
    OR              reduce using rule 104 (dictIndex -> LAST .)
    )               reduce using rule 104 (dictIndex -> LAST .)
    ,               reduce using rule 104 (dictIndex -> LAST .)
    ]               reduce using rule 104 (dictIndex -> LAST .)
    ;               reduce using rule 104 (dictIndex -> LAST .)


state 194

    (102) opDictionary -> . dictIndex .

    *               reduce using rule 102 (opDictionary -> . dictIndex .)
    /               reduce using rule 102 (opDictionary -> . dictIndex .)
    +               reduce using rule 102 (opDictionary -> . dictIndex .)
    -               reduce using rule 102 (opDictionary -> . dictIndex .)
    EQ              reduce using rule 102 (opDictionary -> . dictIndex .)
    DIF             reduce using rule 102 (opDictionary -> . dictIndex .)
    LTOEQ           reduce using rule 102 (opDictionary -> . dictIndex .)
    GTOEQ           reduce using rule 102 (opDictionary -> . dictIndex .)
    >               reduce using rule 102 (opDictionary -> . dictIndex .)
    <               reduce using rule 102 (opDictionary -> . dictIndex .)
    AND             reduce using rule 102 (opDictionary -> . dictIndex .)
    OR              reduce using rule 102 (opDictionary -> . dictIndex .)
    )               reduce using rule 102 (opDictionary -> . dictIndex .)
    ,               reduce using rule 102 (opDictionary -> . dictIndex .)
    ]               reduce using rule 102 (opDictionary -> . dictIndex .)
    ;               reduce using rule 102 (opDictionary -> . dictIndex .)


state 195

    (49) whileCycle -> WHILE ( expresion ) { . body }
    (44) body -> . cyInstruction
    (45) body -> . empty
    (46) cyInstruction -> . instr body
    (109) empty -> .
    (13) instr -> . basicStatements ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) basicStatements -> . assign
    (17) basicStatements -> . funcCall
    (67) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 109 (empty -> .)
    IF              shift and go to state 83
    ID              shift and go to state 81
    FOR             shift and go to state 79
    WHILE           shift and go to state 73

    body                           shift and go to state 209
    funcCall                       shift and go to state 84
    instr                          shift and go to state 71
    forCycle                       shift and go to state 74
    assign                         shift and go to state 85
    whileCycle                     shift and go to state 72
    basicStatements                shift and go to state 80
    condition                      shift and go to state 82
    cyInstruction                  shift and go to state 75
    empty                          shift and go to state 77
    cycle                          shift and go to state 76

state 196

    (85) cyExp -> - term .

    EQ              reduce using rule 85 (cyExp -> - term .)
    DIF             reduce using rule 85 (cyExp -> - term .)
    LTOEQ           reduce using rule 85 (cyExp -> - term .)
    GTOEQ           reduce using rule 85 (cyExp -> - term .)
    >               reduce using rule 85 (cyExp -> - term .)
    <               reduce using rule 85 (cyExp -> - term .)
    AND             reduce using rule 85 (cyExp -> - term .)
    OR              reduce using rule 85 (cyExp -> - term .)
    )               reduce using rule 85 (cyExp -> - term .)
    ,               reduce using rule 85 (cyExp -> - term .)
    ;               reduce using rule 85 (cyExp -> - term .)
    ]               reduce using rule 85 (cyExp -> - term .)


state 197

    (84) cyExp -> + term .

    EQ              reduce using rule 84 (cyExp -> + term .)
    DIF             reduce using rule 84 (cyExp -> + term .)
    LTOEQ           reduce using rule 84 (cyExp -> + term .)
    GTOEQ           reduce using rule 84 (cyExp -> + term .)
    >               reduce using rule 84 (cyExp -> + term .)
    <               reduce using rule 84 (cyExp -> + term .)
    AND             reduce using rule 84 (cyExp -> + term .)
    OR              reduce using rule 84 (cyExp -> + term .)
    )               reduce using rule 84 (cyExp -> + term .)
    ,               reduce using rule 84 (cyExp -> + term .)
    ;               reduce using rule 84 (cyExp -> + term .)
    ]               reduce using rule 84 (cyExp -> + term .)


state 198

    (88) cyTerm -> * fact .

    +               reduce using rule 88 (cyTerm -> * fact .)
    -               reduce using rule 88 (cyTerm -> * fact .)
    EQ              reduce using rule 88 (cyTerm -> * fact .)
    DIF             reduce using rule 88 (cyTerm -> * fact .)
    LTOEQ           reduce using rule 88 (cyTerm -> * fact .)
    GTOEQ           reduce using rule 88 (cyTerm -> * fact .)
    >               reduce using rule 88 (cyTerm -> * fact .)
    <               reduce using rule 88 (cyTerm -> * fact .)
    AND             reduce using rule 88 (cyTerm -> * fact .)
    OR              reduce using rule 88 (cyTerm -> * fact .)
    )               reduce using rule 88 (cyTerm -> * fact .)
    ,               reduce using rule 88 (cyTerm -> * fact .)
    ;               reduce using rule 88 (cyTerm -> * fact .)
    ]               reduce using rule 88 (cyTerm -> * fact .)


state 199

    (89) cyTerm -> / fact .

    +               reduce using rule 89 (cyTerm -> / fact .)
    -               reduce using rule 89 (cyTerm -> / fact .)
    EQ              reduce using rule 89 (cyTerm -> / fact .)
    DIF             reduce using rule 89 (cyTerm -> / fact .)
    LTOEQ           reduce using rule 89 (cyTerm -> / fact .)
    GTOEQ           reduce using rule 89 (cyTerm -> / fact .)
    >               reduce using rule 89 (cyTerm -> / fact .)
    <               reduce using rule 89 (cyTerm -> / fact .)
    AND             reduce using rule 89 (cyTerm -> / fact .)
    OR              reduce using rule 89 (cyTerm -> / fact .)
    )               reduce using rule 89 (cyTerm -> / fact .)
    ,               reduce using rule 89 (cyTerm -> / fact .)
    ;               reduce using rule 89 (cyTerm -> / fact .)
    ]               reduce using rule 89 (cyTerm -> / fact .)


state 200

    (50) forCycle -> FOR ( assign ; expresion . ; assign ) { body }

    ;               shift and go to state 210


state 201

    (60) cyParamCall -> , expresion . cyParamCall
    (60) cyParamCall -> . , expresion cyParamCall
    (61) cyParamCall -> . empty
    (109) empty -> .

    ,               shift and go to state 171
    )               reduce using rule 109 (empty -> .)

    cyParamCall                    shift and go to state 211
    empty                          shift and go to state 172

state 202

    (24) initDict -> = ( dictType : . dictType )
    (25) dictType -> . CTES
    (26) dictType -> . cte
    (27) dictType -> . ID
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE

    CTES            shift and go to state 213
    ID              shift and go to state 215
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    dictType                       shift and go to state 212
    cte                            shift and go to state 214

state 203

    (54) assignOptions -> [ expresion ] assignMatrix . init
    (21) init -> . = initWith

    =               shift and go to state 217

    init                           shift and go to state 216

state 204

    (55) assignMatrix -> [ . expresion ]
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 218
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 205

    (56) assignMatrix -> empty .

    =               reduce using rule 56 (assignMatrix -> empty .)


state 206

    (67) condition -> IF ( expresion ) { . body } optionalElse
    (44) body -> . cyInstruction
    (45) body -> . empty
    (46) cyInstruction -> . instr body
    (109) empty -> .
    (13) instr -> . basicStatements ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) basicStatements -> . assign
    (17) basicStatements -> . funcCall
    (67) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 109 (empty -> .)
    IF              shift and go to state 83
    ID              shift and go to state 81
    FOR             shift and go to state 79
    WHILE           shift and go to state 73

    body                           shift and go to state 219
    funcCall                       shift and go to state 84
    instr                          shift and go to state 71
    forCycle                       shift and go to state 74
    assign                         shift and go to state 85
    whileCycle                     shift and go to state 72
    basicStatements                shift and go to state 80
    condition                      shift and go to state 82
    cyInstruction                  shift and go to state 75
    empty                          shift and go to state 77
    cycle                          shift and go to state 76

state 207

    (32) return -> RETURN expresion . ;

    ;               shift and go to state 220


state 208

    (99) opStruct -> [ expresion ] . opMatrix
    (100) opMatrix -> . [ expresion ]
    (101) opMatrix -> . empty
    (109) empty -> .

    [               shift and go to state 221
    *               reduce using rule 109 (empty -> .)
    /               reduce using rule 109 (empty -> .)
    +               reduce using rule 109 (empty -> .)
    -               reduce using rule 109 (empty -> .)
    EQ              reduce using rule 109 (empty -> .)
    DIF             reduce using rule 109 (empty -> .)
    LTOEQ           reduce using rule 109 (empty -> .)
    GTOEQ           reduce using rule 109 (empty -> .)
    >               reduce using rule 109 (empty -> .)
    <               reduce using rule 109 (empty -> .)
    AND             reduce using rule 109 (empty -> .)
    OR              reduce using rule 109 (empty -> .)
    )               reduce using rule 109 (empty -> .)
    ,               reduce using rule 109 (empty -> .)
    ]               reduce using rule 109 (empty -> .)
    ;               reduce using rule 109 (empty -> .)

    empty                          shift and go to state 222
    opMatrix                       shift and go to state 223

state 209

    (49) whileCycle -> WHILE ( expresion ) { body . }

    }               shift and go to state 224


state 210

    (50) forCycle -> FOR ( assign ; expresion ; . assign ) { body }
    (51) assign -> . ID assignOptions

    ID              shift and go to state 125

    assign                         shift and go to state 225

state 211

    (60) cyParamCall -> , expresion cyParamCall .

    )               reduce using rule 60 (cyParamCall -> , expresion cyParamCall .)


state 212

    (24) initDict -> = ( dictType : dictType . )

    )               shift and go to state 226


state 213

    (25) dictType -> CTES .

    )               reduce using rule 25 (dictType -> CTES .)


state 214

    (26) dictType -> cte .

    )               reduce using rule 26 (dictType -> cte .)


state 215

    (27) dictType -> ID .

    )               reduce using rule 27 (dictType -> ID .)


state 216

    (54) assignOptions -> [ expresion ] assignMatrix init .

    ;               reduce using rule 54 (assignOptions -> [ expresion ] assignMatrix init .)
    )               reduce using rule 54 (assignOptions -> [ expresion ] assignMatrix init .)


state 217

    (21) init -> = . initWith
    (22) initWith -> . expresion
    (23) initWith -> . funcCall
    (71) expresion -> . sExp cyExpresion
    (57) funcCall -> . ID ( opParamCall )
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE

    ID              shift and go to state 132
    CTES            shift and go to state 117
    (               shift and go to state 112
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 133
    initWith                       shift and go to state 130
    funcCall                       shift and go to state 134
    term                           shift and go to state 118
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 218

    (55) assignMatrix -> [ expresion . ]

    ]               shift and go to state 227


state 219

    (67) condition -> IF ( expresion ) { body . } optionalElse

    }               shift and go to state 228


state 220

    (32) return -> RETURN expresion ; .

    }               reduce using rule 32 (return -> RETURN expresion ; .)


state 221

    (100) opMatrix -> [ . expresion ]
    (71) expresion -> . sExp cyExpresion
    (75) sExp -> . exp opSExp
    (83) exp -> . term cyExp
    (87) term -> . fact cyTerm
    (91) fact -> . CTES
    (92) fact -> . cte
    (93) fact -> . funcCall
    (94) fact -> . ( expresion )
    (95) fact -> . ID opAccess
    (105) cte -> . CTED
    (106) cte -> . CTEF
    (107) cte -> . TRUE
    (108) cte -> . FALSE
    (57) funcCall -> . ID ( opParamCall )

    CTES            shift and go to state 117
    (               shift and go to state 112
    ID              shift and go to state 115
    CTED            shift and go to state 123
    CTEF            shift and go to state 122
    TRUE            shift and go to state 111
    FALSE           shift and go to state 119

    expresion                      shift and go to state 229
    term                           shift and go to state 118
    funcCall                       shift and go to state 120
    sExp                           shift and go to state 113
    cte                            shift and go to state 121
    exp                            shift and go to state 114
    fact                           shift and go to state 124

state 222

    (101) opMatrix -> empty .

    *               reduce using rule 101 (opMatrix -> empty .)
    /               reduce using rule 101 (opMatrix -> empty .)
    +               reduce using rule 101 (opMatrix -> empty .)
    -               reduce using rule 101 (opMatrix -> empty .)
    EQ              reduce using rule 101 (opMatrix -> empty .)
    DIF             reduce using rule 101 (opMatrix -> empty .)
    LTOEQ           reduce using rule 101 (opMatrix -> empty .)
    GTOEQ           reduce using rule 101 (opMatrix -> empty .)
    >               reduce using rule 101 (opMatrix -> empty .)
    <               reduce using rule 101 (opMatrix -> empty .)
    AND             reduce using rule 101 (opMatrix -> empty .)
    OR              reduce using rule 101 (opMatrix -> empty .)
    )               reduce using rule 101 (opMatrix -> empty .)
    ,               reduce using rule 101 (opMatrix -> empty .)
    ]               reduce using rule 101 (opMatrix -> empty .)
    ;               reduce using rule 101 (opMatrix -> empty .)


state 223

    (99) opStruct -> [ expresion ] opMatrix .

    *               reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    /               reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    +               reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    -               reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    EQ              reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    DIF             reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    LTOEQ           reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    GTOEQ           reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    >               reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    <               reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    AND             reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    OR              reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    )               reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    ,               reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    ]               reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)
    ;               reduce using rule 99 (opStruct -> [ expresion ] opMatrix .)


state 224

    (49) whileCycle -> WHILE ( expresion ) { body } .

    IF              reduce using rule 49 (whileCycle -> WHILE ( expresion ) { body } .)
    ID              reduce using rule 49 (whileCycle -> WHILE ( expresion ) { body } .)
    FOR             reduce using rule 49 (whileCycle -> WHILE ( expresion ) { body } .)
    WHILE           reduce using rule 49 (whileCycle -> WHILE ( expresion ) { body } .)
    }               reduce using rule 49 (whileCycle -> WHILE ( expresion ) { body } .)
    RETURN          reduce using rule 49 (whileCycle -> WHILE ( expresion ) { body } .)


state 225

    (50) forCycle -> FOR ( assign ; expresion ; assign . ) { body }

    )               shift and go to state 230


state 226

    (24) initDict -> = ( dictType : dictType ) .

    ;               reduce using rule 24 (initDict -> = ( dictType : dictType ) .)
    )               reduce using rule 24 (initDict -> = ( dictType : dictType ) .)


state 227

    (55) assignMatrix -> [ expresion ] .

    =               reduce using rule 55 (assignMatrix -> [ expresion ] .)


state 228

    (67) condition -> IF ( expresion ) { body } . optionalElse
    (68) optionalElse -> . ELSE { body }
    (69) optionalElse -> . empty
    (109) empty -> .

    ELSE            shift and go to state 231
    IF              reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FOR             reduce using rule 109 (empty -> .)
    WHILE           reduce using rule 109 (empty -> .)
    }               reduce using rule 109 (empty -> .)
    RETURN          reduce using rule 109 (empty -> .)

    optionalElse                   shift and go to state 232
    empty                          shift and go to state 233

state 229

    (100) opMatrix -> [ expresion . ]

    ]               shift and go to state 234


state 230

    (50) forCycle -> FOR ( assign ; expresion ; assign ) . { body }

    {               shift and go to state 235


state 231

    (68) optionalElse -> ELSE . { body }

    {               shift and go to state 236


state 232

    (67) condition -> IF ( expresion ) { body } optionalElse .

    IF              reduce using rule 67 (condition -> IF ( expresion ) { body } optionalElse .)
    ID              reduce using rule 67 (condition -> IF ( expresion ) { body } optionalElse .)
    FOR             reduce using rule 67 (condition -> IF ( expresion ) { body } optionalElse .)
    WHILE           reduce using rule 67 (condition -> IF ( expresion ) { body } optionalElse .)
    }               reduce using rule 67 (condition -> IF ( expresion ) { body } optionalElse .)
    RETURN          reduce using rule 67 (condition -> IF ( expresion ) { body } optionalElse .)


state 233

    (69) optionalElse -> empty .

    IF              reduce using rule 69 (optionalElse -> empty .)
    ID              reduce using rule 69 (optionalElse -> empty .)
    FOR             reduce using rule 69 (optionalElse -> empty .)
    WHILE           reduce using rule 69 (optionalElse -> empty .)
    }               reduce using rule 69 (optionalElse -> empty .)
    RETURN          reduce using rule 69 (optionalElse -> empty .)


state 234

    (100) opMatrix -> [ expresion ] .

    *               reduce using rule 100 (opMatrix -> [ expresion ] .)
    /               reduce using rule 100 (opMatrix -> [ expresion ] .)
    +               reduce using rule 100 (opMatrix -> [ expresion ] .)
    -               reduce using rule 100 (opMatrix -> [ expresion ] .)
    EQ              reduce using rule 100 (opMatrix -> [ expresion ] .)
    DIF             reduce using rule 100 (opMatrix -> [ expresion ] .)
    LTOEQ           reduce using rule 100 (opMatrix -> [ expresion ] .)
    GTOEQ           reduce using rule 100 (opMatrix -> [ expresion ] .)
    >               reduce using rule 100 (opMatrix -> [ expresion ] .)
    <               reduce using rule 100 (opMatrix -> [ expresion ] .)
    AND             reduce using rule 100 (opMatrix -> [ expresion ] .)
    OR              reduce using rule 100 (opMatrix -> [ expresion ] .)
    )               reduce using rule 100 (opMatrix -> [ expresion ] .)
    ,               reduce using rule 100 (opMatrix -> [ expresion ] .)
    ]               reduce using rule 100 (opMatrix -> [ expresion ] .)
    ;               reduce using rule 100 (opMatrix -> [ expresion ] .)


state 235

    (50) forCycle -> FOR ( assign ; expresion ; assign ) { . body }
    (44) body -> . cyInstruction
    (45) body -> . empty
    (46) cyInstruction -> . instr body
    (109) empty -> .
    (13) instr -> . basicStatements ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) basicStatements -> . assign
    (17) basicStatements -> . funcCall
    (67) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 109 (empty -> .)
    IF              shift and go to state 83
    ID              shift and go to state 81
    FOR             shift and go to state 79
    WHILE           shift and go to state 73

    body                           shift and go to state 237
    funcCall                       shift and go to state 84
    instr                          shift and go to state 71
    forCycle                       shift and go to state 74
    cyInstruction                  shift and go to state 75
    whileCycle                     shift and go to state 72
    basicStatements                shift and go to state 80
    condition                      shift and go to state 82
    assign                         shift and go to state 85
    empty                          shift and go to state 77
    cycle                          shift and go to state 76

state 236

    (68) optionalElse -> ELSE { . body }
    (44) body -> . cyInstruction
    (45) body -> . empty
    (46) cyInstruction -> . instr body
    (109) empty -> .
    (13) instr -> . basicStatements ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) basicStatements -> . assign
    (17) basicStatements -> . funcCall
    (67) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 109 (empty -> .)
    IF              shift and go to state 83
    ID              shift and go to state 81
    FOR             shift and go to state 79
    WHILE           shift and go to state 73

    body                           shift and go to state 238
    funcCall                       shift and go to state 84
    instr                          shift and go to state 71
    forCycle                       shift and go to state 74
    assign                         shift and go to state 85
    whileCycle                     shift and go to state 72
    basicStatements                shift and go to state 80
    empty                          shift and go to state 77
    cyInstruction                  shift and go to state 75
    condition                      shift and go to state 82
    cycle                          shift and go to state 76

state 237

    (50) forCycle -> FOR ( assign ; expresion ; assign ) { body . }

    }               shift and go to state 239


state 238

    (68) optionalElse -> ELSE { body . }

    }               shift and go to state 240


state 239

    (50) forCycle -> FOR ( assign ; expresion ; assign ) { body } .

    IF              reduce using rule 50 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    ID              reduce using rule 50 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    FOR             reduce using rule 50 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    WHILE           reduce using rule 50 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    }               reduce using rule 50 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    RETURN          reduce using rule 50 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)


state 240

    (68) optionalElse -> ELSE { body } .

    IF              reduce using rule 68 (optionalElse -> ELSE { body } .)
    ID              reduce using rule 68 (optionalElse -> ELSE { body } .)
    FOR             reduce using rule 68 (optionalElse -> ELSE { body } .)
    WHILE           reduce using rule 68 (optionalElse -> ELSE { body } .)
    }               reduce using rule 68 (optionalElse -> ELSE { body } .)
    RETURN          reduce using rule 68 (optionalElse -> ELSE { body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 134 resolved using rule (initWith -> funcCall)
WARNING: rejected rule (fact -> funcCall) in state 134
