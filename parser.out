Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    RETURN
    DIF
    LTOEQ
    EQ
    AND
    GTOEQ
    OR

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID { a b main }
Rule 2     a -> vars
Rule 3     a -> empty
Rule 4     b -> function b
Rule 5     b -> empty
Rule 6     vars -> VARS declare
Rule 7     type -> INT
Rule 8     type -> FLOAT
Rule 9     type -> STRING
Rule 10    type -> OBJECT
Rule 11    type -> BOOL
Rule 12    main -> MAIN { a body }
Rule 13    instr -> c ;
Rule 14    instr -> condition
Rule 15    instr -> cycle
Rule 16    c -> assign
Rule 17    c -> funcCall
Rule 18    declare -> d
Rule 19    declare -> e
Rule 20    declare -> f
Rule 21    init -> = i
Rule 22    i -> expresion
Rule 23    i -> funcCall
Rule 24    initDict -> = ( j : j )
Rule 25    j -> CTES
Rule 26    j -> cte
Rule 27    j -> ID
Rule 28    param -> type ID g k
Rule 29    k -> ; param
Rule 30    k -> empty
Rule 31    function -> FUNC ID l m { a body }
Rule 32    l -> ( param n )
Rule 33    n -> param
Rule 34    n -> empty
Rule 35    m -> RETURNS type
Rule 36    m -> empty
Rule 37    d -> type ID g ; h
Rule 38    e -> STRUCT ID struct ; h
Rule 39    f -> DICT ID dict ; h
Rule 40    g -> , ID
Rule 41    g -> empty
Rule 42    h -> declare
Rule 43    h -> empty
Rule 44    body -> cycleInstruction
Rule 45    body -> empty
Rule 46    cycleInstruction -> instr body
Rule 47    cycle -> forCycle
Rule 48    cycle -> whileCycle
Rule 49    whileCycle -> WHILE ( expresion ) { body }
Rule 50    forCycle -> FOR ( assign ; expresion ; assign ) { body }
Rule 51    assign -> ID assignOptions
Rule 52    assignOptions -> init
Rule 53    assignOptions -> initDict
Rule 54    assignOptions -> [ expresion ] assignMatrix init
Rule 55    assignMatrix -> [ expresion ]
Rule 56    assignMatrix -> empty
Rule 57    funcCall -> ID ( opParamCall )
Rule 58    opParamCall -> expresion cyParamCall
Rule 59    cyParamCall -> , opParamCall
Rule 60    cyParamCall -> empty
Rule 61    struct -> type [ CTED ] optionalMatrix
Rule 62    optionalMatrix -> [ CTED ]
Rule 63    optionalMatrix -> empty
Rule 64    condition -> IF ( expresion ) { body } optionalElse
Rule 65    optionalElse -> ELSE { body }
Rule 66    optionalElse -> empty
Rule 67    dict -> ( type : type )
Rule 68    expresion -> empty
Rule 69    cte -> CTED
Rule 70    cte -> CTEF
Rule 71    cte -> TRUE
Rule 72    cte -> FALSE c
Rule 73    empty -> <empty>

Terminals, with rules where they appear

(                    : 24 32 49 50 57 64 67
)                    : 24 32 49 50 57 64 67
,                    : 40 59
:                    : 24 67
;                    : 13 29 37 38 39 50 50
=                    : 21 24
AND                  : 
BOOL                 : 11
CTED                 : 61 62 69
CTEF                 : 70
CTES                 : 25
DICT                 : 39
DIF                  : 
ELSE                 : 65
EQ                   : 
FALSE                : 72
FLOAT                : 8
FOR                  : 50
FUNC                 : 31
GTOEQ                : 
ID                   : 1 27 28 31 37 38 39 40 51 57
IF                   : 64
INT                  : 7
LTOEQ                : 
MAIN                 : 12
OBJECT               : 10
OR                   : 
PROGRAM              : 1
RETURN               : 
RETURNS              : 35
STRING               : 9
STRUCT               : 38
TRUE                 : 71
VARS                 : 6
WHILE                : 49
[                    : 54 55 61 62
]                    : 54 55 61 62
error                : 
{                    : 1 12 31 49 50 64 65
}                    : 1 12 31 49 50 64 65

Nonterminals, with rules where they appear

a                    : 1 12 31
assign               : 16 50 50
assignMatrix         : 54
assignOptions        : 51
b                    : 1 4
body                 : 12 31 46 49 50 64 65
c                    : 13 72
condition            : 14
cte                  : 26
cyParamCall          : 58
cycle                : 15
cycleInstruction     : 44
d                    : 18
declare              : 6 42
dict                 : 39
e                    : 19
empty                : 3 5 30 34 36 41 43 45 56 60 63 66 68
expresion            : 22 49 50 54 55 58 64
f                    : 20
forCycle             : 47
funcCall             : 17 23
function             : 4
g                    : 28 37
h                    : 37 38 39
i                    : 21
init                 : 52 54
initDict             : 53
instr                : 46
j                    : 24 24
k                    : 28
l                    : 31
m                    : 31
main                 : 1
n                    : 32
opParamCall          : 57 59
optionalElse         : 64
optionalMatrix       : 61
param                : 29 32 33
program              : 0
struct               : 38
type                 : 28 35 37 61 67 67
vars                 : 2
whileCycle           : 48

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID { a b main }

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID { a b main }

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . { a b main }

    {               shift and go to state 4


state 4

    (1) program -> PROGRAM ID { . a b main }
    (2) a -> . vars
    (3) a -> . empty
    (6) vars -> . VARS declare
    (73) empty -> .

    VARS            shift and go to state 6
    FUNC            reduce using rule 73 (empty -> .)
    MAIN            reduce using rule 73 (empty -> .)

    a                              shift and go to state 5
    vars                           shift and go to state 7
    empty                          shift and go to state 8

state 5

    (1) program -> PROGRAM ID { a . b main }
    (4) b -> . function b
    (5) b -> . empty
    (31) function -> . FUNC ID l m { a body }
    (73) empty -> .

    FUNC            shift and go to state 11
    MAIN            reduce using rule 73 (empty -> .)

    function                       shift and go to state 9
    b                              shift and go to state 10
    empty                          shift and go to state 12

state 6

    (6) vars -> VARS . declare
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (37) d -> . type ID g ; h
    (38) e -> . STRUCT ID struct ; h
    (39) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    STRUCT          shift and go to state 24
    DICT            shift and go to state 20
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    e                              shift and go to state 14
    d                              shift and go to state 15
    f                              shift and go to state 16
    type                           shift and go to state 22
    declare                        shift and go to state 23

state 7

    (2) a -> vars .

    FUNC            reduce using rule 2 (a -> vars .)
    MAIN            reduce using rule 2 (a -> vars .)
    IF              reduce using rule 2 (a -> vars .)
    ID              reduce using rule 2 (a -> vars .)
    FOR             reduce using rule 2 (a -> vars .)
    WHILE           reduce using rule 2 (a -> vars .)
    }               reduce using rule 2 (a -> vars .)


state 8

    (3) a -> empty .

    FUNC            reduce using rule 3 (a -> empty .)
    MAIN            reduce using rule 3 (a -> empty .)
    IF              reduce using rule 3 (a -> empty .)
    ID              reduce using rule 3 (a -> empty .)
    FOR             reduce using rule 3 (a -> empty .)
    WHILE           reduce using rule 3 (a -> empty .)
    }               reduce using rule 3 (a -> empty .)


state 9

    (4) b -> function . b
    (4) b -> . function b
    (5) b -> . empty
    (31) function -> . FUNC ID l m { a body }
    (73) empty -> .

    FUNC            shift and go to state 11
    MAIN            reduce using rule 73 (empty -> .)

    function                       shift and go to state 9
    b                              shift and go to state 25
    empty                          shift and go to state 12

state 10

    (1) program -> PROGRAM ID { a b . main }
    (12) main -> . MAIN { a body }

    MAIN            shift and go to state 26

    main                           shift and go to state 27

state 11

    (31) function -> FUNC . ID l m { a body }

    ID              shift and go to state 28


state 12

    (5) b -> empty .

    MAIN            reduce using rule 5 (b -> empty .)


state 13

    (10) type -> OBJECT .

    ID              reduce using rule 10 (type -> OBJECT .)
    :               reduce using rule 10 (type -> OBJECT .)
    {               reduce using rule 10 (type -> OBJECT .)
    )               reduce using rule 10 (type -> OBJECT .)
    [               reduce using rule 10 (type -> OBJECT .)


state 14

    (19) declare -> e .

    FUNC            reduce using rule 19 (declare -> e .)
    MAIN            reduce using rule 19 (declare -> e .)
    IF              reduce using rule 19 (declare -> e .)
    ID              reduce using rule 19 (declare -> e .)
    FOR             reduce using rule 19 (declare -> e .)
    WHILE           reduce using rule 19 (declare -> e .)
    }               reduce using rule 19 (declare -> e .)


state 15

    (18) declare -> d .

    FUNC            reduce using rule 18 (declare -> d .)
    MAIN            reduce using rule 18 (declare -> d .)
    IF              reduce using rule 18 (declare -> d .)
    ID              reduce using rule 18 (declare -> d .)
    FOR             reduce using rule 18 (declare -> d .)
    WHILE           reduce using rule 18 (declare -> d .)
    }               reduce using rule 18 (declare -> d .)


state 16

    (20) declare -> f .

    FUNC            reduce using rule 20 (declare -> f .)
    MAIN            reduce using rule 20 (declare -> f .)
    IF              reduce using rule 20 (declare -> f .)
    ID              reduce using rule 20 (declare -> f .)
    FOR             reduce using rule 20 (declare -> f .)
    WHILE           reduce using rule 20 (declare -> f .)
    }               reduce using rule 20 (declare -> f .)


state 17

    (7) type -> INT .

    ID              reduce using rule 7 (type -> INT .)
    :               reduce using rule 7 (type -> INT .)
    {               reduce using rule 7 (type -> INT .)
    )               reduce using rule 7 (type -> INT .)
    [               reduce using rule 7 (type -> INT .)


state 18

    (8) type -> FLOAT .

    ID              reduce using rule 8 (type -> FLOAT .)
    :               reduce using rule 8 (type -> FLOAT .)
    {               reduce using rule 8 (type -> FLOAT .)
    )               reduce using rule 8 (type -> FLOAT .)
    [               reduce using rule 8 (type -> FLOAT .)


state 19

    (9) type -> STRING .

    ID              reduce using rule 9 (type -> STRING .)
    :               reduce using rule 9 (type -> STRING .)
    {               reduce using rule 9 (type -> STRING .)
    )               reduce using rule 9 (type -> STRING .)
    [               reduce using rule 9 (type -> STRING .)


state 20

    (39) f -> DICT . ID dict ; h

    ID              shift and go to state 29


state 21

    (11) type -> BOOL .

    ID              reduce using rule 11 (type -> BOOL .)
    :               reduce using rule 11 (type -> BOOL .)
    {               reduce using rule 11 (type -> BOOL .)
    )               reduce using rule 11 (type -> BOOL .)
    [               reduce using rule 11 (type -> BOOL .)


state 22

    (37) d -> type . ID g ; h

    ID              shift and go to state 30


state 23

    (6) vars -> VARS declare .

    IF              reduce using rule 6 (vars -> VARS declare .)
    ID              reduce using rule 6 (vars -> VARS declare .)
    FOR             reduce using rule 6 (vars -> VARS declare .)
    WHILE           reduce using rule 6 (vars -> VARS declare .)
    }               reduce using rule 6 (vars -> VARS declare .)
    FUNC            reduce using rule 6 (vars -> VARS declare .)
    MAIN            reduce using rule 6 (vars -> VARS declare .)


state 24

    (38) e -> STRUCT . ID struct ; h

    ID              shift and go to state 31


state 25

    (4) b -> function b .

    MAIN            reduce using rule 4 (b -> function b .)


state 26

    (12) main -> MAIN . { a body }

    {               shift and go to state 32


state 27

    (1) program -> PROGRAM ID { a b main . }

    }               shift and go to state 33


state 28

    (31) function -> FUNC ID . l m { a body }
    (32) l -> . ( param n )

    (               shift and go to state 34

    l                              shift and go to state 35

state 29

    (39) f -> DICT ID . dict ; h
    (67) dict -> . ( type : type )

    (               shift and go to state 36

    dict                           shift and go to state 37

state 30

    (37) d -> type ID . g ; h
    (40) g -> . , ID
    (41) g -> . empty
    (73) empty -> .

    ,               shift and go to state 39
    ;               reduce using rule 73 (empty -> .)

    empty                          shift and go to state 40
    g                              shift and go to state 38

state 31

    (38) e -> STRUCT ID . struct ; h
    (61) struct -> . type [ CTED ] optionalMatrix
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 42
    struct                         shift and go to state 41

state 32

    (12) main -> MAIN { . a body }
    (2) a -> . vars
    (3) a -> . empty
    (6) vars -> . VARS declare
    (73) empty -> .

    VARS            shift and go to state 6
    IF              reduce using rule 73 (empty -> .)
    ID              reduce using rule 73 (empty -> .)
    FOR             reduce using rule 73 (empty -> .)
    WHILE           reduce using rule 73 (empty -> .)
    }               reduce using rule 73 (empty -> .)

    a                              shift and go to state 43
    empty                          shift and go to state 8
    vars                           shift and go to state 7

state 33

    (1) program -> PROGRAM ID { a b main } .

    $end            reduce using rule 1 (program -> PROGRAM ID { a b main } .)


state 34

    (32) l -> ( . param n )
    (28) param -> . type ID g k
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 45
    param                          shift and go to state 44

state 35

    (31) function -> FUNC ID l . m { a body }
    (35) m -> . RETURNS type
    (36) m -> . empty
    (73) empty -> .

    RETURNS         shift and go to state 47
    {               reduce using rule 73 (empty -> .)

    m                              shift and go to state 46
    empty                          shift and go to state 48

state 36

    (67) dict -> ( . type : type )
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 49

state 37

    (39) f -> DICT ID dict . ; h

    ;               shift and go to state 50


state 38

    (37) d -> type ID g . ; h

    ;               shift and go to state 51


state 39

    (40) g -> , . ID

    ID              shift and go to state 52


state 40

    (41) g -> empty .

    ;               reduce using rule 41 (g -> empty .)
    INT             reduce using rule 41 (g -> empty .)
    FLOAT           reduce using rule 41 (g -> empty .)
    STRING          reduce using rule 41 (g -> empty .)
    OBJECT          reduce using rule 41 (g -> empty .)
    BOOL            reduce using rule 41 (g -> empty .)
    )               reduce using rule 41 (g -> empty .)


state 41

    (38) e -> STRUCT ID struct . ; h

    ;               shift and go to state 53


state 42

    (61) struct -> type . [ CTED ] optionalMatrix

    [               shift and go to state 54


state 43

    (12) main -> MAIN { a . body }
    (44) body -> . cycleInstruction
    (45) body -> . empty
    (46) cycleInstruction -> . instr body
    (73) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 73 (empty -> .)
    IF              shift and go to state 66
    ID              shift and go to state 64
    FOR             shift and go to state 63
    WHILE           shift and go to state 57

    body                           shift and go to state 62
    c                              shift and go to state 67
    funcCall                       shift and go to state 68
    cycleInstruction               shift and go to state 59
    instr                          shift and go to state 55
    forCycle                       shift and go to state 58
    whileCycle                     shift and go to state 56
    condition                      shift and go to state 65
    assign                         shift and go to state 69
    empty                          shift and go to state 61
    cycle                          shift and go to state 60

state 44

    (32) l -> ( param . n )
    (33) n -> . param
    (34) n -> . empty
    (28) param -> . type ID g k
    (73) empty -> .
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    )               reduce using rule 73 (empty -> .)
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    param                          shift and go to state 70
    n                              shift and go to state 71
    type                           shift and go to state 45
    empty                          shift and go to state 72

state 45

    (28) param -> type . ID g k

    ID              shift and go to state 73


state 46

    (31) function -> FUNC ID l m . { a body }

    {               shift and go to state 74


state 47

    (35) m -> RETURNS . type
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 75

state 48

    (36) m -> empty .

    {               reduce using rule 36 (m -> empty .)


state 49

    (67) dict -> ( type . : type )

    :               shift and go to state 76


state 50

    (39) f -> DICT ID dict ; . h
    (42) h -> . declare
    (43) h -> . empty
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (73) empty -> .
    (37) d -> . type ID g ; h
    (38) e -> . STRUCT ID struct ; h
    (39) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 73 (empty -> .)
    MAIN            reduce using rule 73 (empty -> .)
    IF              reduce using rule 73 (empty -> .)
    ID              reduce using rule 73 (empty -> .)
    FOR             reduce using rule 73 (empty -> .)
    WHILE           reduce using rule 73 (empty -> .)
    }               reduce using rule 73 (empty -> .)
    STRUCT          shift and go to state 24
    DICT            shift and go to state 20
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    e                              shift and go to state 14
    d                              shift and go to state 15
    f                              shift and go to state 16
    h                              shift and go to state 77
    type                           shift and go to state 22
    declare                        shift and go to state 78
    empty                          shift and go to state 79

state 51

    (37) d -> type ID g ; . h
    (42) h -> . declare
    (43) h -> . empty
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (73) empty -> .
    (37) d -> . type ID g ; h
    (38) e -> . STRUCT ID struct ; h
    (39) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 73 (empty -> .)
    MAIN            reduce using rule 73 (empty -> .)
    IF              reduce using rule 73 (empty -> .)
    ID              reduce using rule 73 (empty -> .)
    FOR             reduce using rule 73 (empty -> .)
    WHILE           reduce using rule 73 (empty -> .)
    }               reduce using rule 73 (empty -> .)
    STRUCT          shift and go to state 24
    DICT            shift and go to state 20
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    e                              shift and go to state 14
    d                              shift and go to state 15
    f                              shift and go to state 16
    h                              shift and go to state 80
    type                           shift and go to state 22
    declare                        shift and go to state 78
    empty                          shift and go to state 79

state 52

    (40) g -> , ID .

    ;               reduce using rule 40 (g -> , ID .)
    INT             reduce using rule 40 (g -> , ID .)
    FLOAT           reduce using rule 40 (g -> , ID .)
    STRING          reduce using rule 40 (g -> , ID .)
    OBJECT          reduce using rule 40 (g -> , ID .)
    BOOL            reduce using rule 40 (g -> , ID .)
    )               reduce using rule 40 (g -> , ID .)


state 53

    (38) e -> STRUCT ID struct ; . h
    (42) h -> . declare
    (43) h -> . empty
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (73) empty -> .
    (37) d -> . type ID g ; h
    (38) e -> . STRUCT ID struct ; h
    (39) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 73 (empty -> .)
    MAIN            reduce using rule 73 (empty -> .)
    IF              reduce using rule 73 (empty -> .)
    ID              reduce using rule 73 (empty -> .)
    FOR             reduce using rule 73 (empty -> .)
    WHILE           reduce using rule 73 (empty -> .)
    }               reduce using rule 73 (empty -> .)
    STRUCT          shift and go to state 24
    DICT            shift and go to state 20
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    e                              shift and go to state 14
    d                              shift and go to state 15
    f                              shift and go to state 16
    h                              shift and go to state 81
    type                           shift and go to state 22
    declare                        shift and go to state 78
    empty                          shift and go to state 79

state 54

    (61) struct -> type [ . CTED ] optionalMatrix

    CTED            shift and go to state 82


state 55

    (46) cycleInstruction -> instr . body
    (44) body -> . cycleInstruction
    (45) body -> . empty
    (46) cycleInstruction -> . instr body
    (73) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 73 (empty -> .)
    IF              shift and go to state 66
    ID              shift and go to state 64
    FOR             shift and go to state 63
    WHILE           shift and go to state 57

    body                           shift and go to state 83
    c                              shift and go to state 67
    funcCall                       shift and go to state 68
    cycleInstruction               shift and go to state 59
    instr                          shift and go to state 55
    forCycle                       shift and go to state 58
    whileCycle                     shift and go to state 56
    empty                          shift and go to state 61
    assign                         shift and go to state 69
    condition                      shift and go to state 65
    cycle                          shift and go to state 60

state 56

    (48) cycle -> whileCycle .

    IF              reduce using rule 48 (cycle -> whileCycle .)
    ID              reduce using rule 48 (cycle -> whileCycle .)
    FOR             reduce using rule 48 (cycle -> whileCycle .)
    WHILE           reduce using rule 48 (cycle -> whileCycle .)
    }               reduce using rule 48 (cycle -> whileCycle .)


state 57

    (49) whileCycle -> WHILE . ( expresion ) { body }

    (               shift and go to state 84


state 58

    (47) cycle -> forCycle .

    IF              reduce using rule 47 (cycle -> forCycle .)
    ID              reduce using rule 47 (cycle -> forCycle .)
    FOR             reduce using rule 47 (cycle -> forCycle .)
    WHILE           reduce using rule 47 (cycle -> forCycle .)
    }               reduce using rule 47 (cycle -> forCycle .)


state 59

    (44) body -> cycleInstruction .

    }               reduce using rule 44 (body -> cycleInstruction .)


state 60

    (15) instr -> cycle .

    IF              reduce using rule 15 (instr -> cycle .)
    ID              reduce using rule 15 (instr -> cycle .)
    FOR             reduce using rule 15 (instr -> cycle .)
    WHILE           reduce using rule 15 (instr -> cycle .)
    }               reduce using rule 15 (instr -> cycle .)


state 61

    (45) body -> empty .

    }               reduce using rule 45 (body -> empty .)


state 62

    (12) main -> MAIN { a body . }

    }               shift and go to state 85


state 63

    (50) forCycle -> FOR . ( assign ; expresion ; assign ) { body }

    (               shift and go to state 86


state 64

    (51) assign -> ID . assignOptions
    (57) funcCall -> ID . ( opParamCall )
    (52) assignOptions -> . init
    (53) assignOptions -> . initDict
    (54) assignOptions -> . [ expresion ] assignMatrix init
    (21) init -> . = i
    (24) initDict -> . = ( j : j )

    (               shift and go to state 87
    [               shift and go to state 92
    =               shift and go to state 89

    initDict                       shift and go to state 88
    assignOptions                  shift and go to state 90
    init                           shift and go to state 91

state 65

    (14) instr -> condition .

    IF              reduce using rule 14 (instr -> condition .)
    ID              reduce using rule 14 (instr -> condition .)
    FOR             reduce using rule 14 (instr -> condition .)
    WHILE           reduce using rule 14 (instr -> condition .)
    }               reduce using rule 14 (instr -> condition .)


state 66

    (64) condition -> IF . ( expresion ) { body } optionalElse

    (               shift and go to state 93


state 67

    (13) instr -> c . ;

    ;               shift and go to state 94


state 68

    (17) c -> funcCall .

    ;               reduce using rule 17 (c -> funcCall .)
    :               reduce using rule 17 (c -> funcCall .)
    )               reduce using rule 17 (c -> funcCall .)


state 69

    (16) c -> assign .

    ;               reduce using rule 16 (c -> assign .)
    :               reduce using rule 16 (c -> assign .)
    )               reduce using rule 16 (c -> assign .)


state 70

    (33) n -> param .

    )               reduce using rule 33 (n -> param .)


state 71

    (32) l -> ( param n . )

    )               shift and go to state 95


state 72

    (34) n -> empty .

    )               reduce using rule 34 (n -> empty .)


state 73

    (28) param -> type ID . g k
    (40) g -> . , ID
    (41) g -> . empty
    (73) empty -> .

    ,               shift and go to state 39
    ;               reduce using rule 73 (empty -> .)
    INT             reduce using rule 73 (empty -> .)
    FLOAT           reduce using rule 73 (empty -> .)
    STRING          reduce using rule 73 (empty -> .)
    OBJECT          reduce using rule 73 (empty -> .)
    BOOL            reduce using rule 73 (empty -> .)
    )               reduce using rule 73 (empty -> .)

    empty                          shift and go to state 40
    g                              shift and go to state 96

state 74

    (31) function -> FUNC ID l m { . a body }
    (2) a -> . vars
    (3) a -> . empty
    (6) vars -> . VARS declare
    (73) empty -> .

    VARS            shift and go to state 6
    IF              reduce using rule 73 (empty -> .)
    ID              reduce using rule 73 (empty -> .)
    FOR             reduce using rule 73 (empty -> .)
    WHILE           reduce using rule 73 (empty -> .)
    }               reduce using rule 73 (empty -> .)

    a                              shift and go to state 97
    vars                           shift and go to state 7
    empty                          shift and go to state 8

state 75

    (35) m -> RETURNS type .

    {               reduce using rule 35 (m -> RETURNS type .)


state 76

    (67) dict -> ( type : . type )
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 98

state 77

    (39) f -> DICT ID dict ; h .

    FUNC            reduce using rule 39 (f -> DICT ID dict ; h .)
    MAIN            reduce using rule 39 (f -> DICT ID dict ; h .)
    IF              reduce using rule 39 (f -> DICT ID dict ; h .)
    ID              reduce using rule 39 (f -> DICT ID dict ; h .)
    FOR             reduce using rule 39 (f -> DICT ID dict ; h .)
    WHILE           reduce using rule 39 (f -> DICT ID dict ; h .)
    }               reduce using rule 39 (f -> DICT ID dict ; h .)


state 78

    (42) h -> declare .

    FUNC            reduce using rule 42 (h -> declare .)
    MAIN            reduce using rule 42 (h -> declare .)
    IF              reduce using rule 42 (h -> declare .)
    ID              reduce using rule 42 (h -> declare .)
    FOR             reduce using rule 42 (h -> declare .)
    WHILE           reduce using rule 42 (h -> declare .)
    }               reduce using rule 42 (h -> declare .)


state 79

    (43) h -> empty .

    FUNC            reduce using rule 43 (h -> empty .)
    MAIN            reduce using rule 43 (h -> empty .)
    IF              reduce using rule 43 (h -> empty .)
    ID              reduce using rule 43 (h -> empty .)
    FOR             reduce using rule 43 (h -> empty .)
    WHILE           reduce using rule 43 (h -> empty .)
    }               reduce using rule 43 (h -> empty .)


state 80

    (37) d -> type ID g ; h .

    FUNC            reduce using rule 37 (d -> type ID g ; h .)
    MAIN            reduce using rule 37 (d -> type ID g ; h .)
    IF              reduce using rule 37 (d -> type ID g ; h .)
    ID              reduce using rule 37 (d -> type ID g ; h .)
    FOR             reduce using rule 37 (d -> type ID g ; h .)
    WHILE           reduce using rule 37 (d -> type ID g ; h .)
    }               reduce using rule 37 (d -> type ID g ; h .)


state 81

    (38) e -> STRUCT ID struct ; h .

    FUNC            reduce using rule 38 (e -> STRUCT ID struct ; h .)
    MAIN            reduce using rule 38 (e -> STRUCT ID struct ; h .)
    IF              reduce using rule 38 (e -> STRUCT ID struct ; h .)
    ID              reduce using rule 38 (e -> STRUCT ID struct ; h .)
    FOR             reduce using rule 38 (e -> STRUCT ID struct ; h .)
    WHILE           reduce using rule 38 (e -> STRUCT ID struct ; h .)
    }               reduce using rule 38 (e -> STRUCT ID struct ; h .)


state 82

    (61) struct -> type [ CTED . ] optionalMatrix

    ]               shift and go to state 99


state 83

    (46) cycleInstruction -> instr body .

    }               reduce using rule 46 (cycleInstruction -> instr body .)


state 84

    (49) whileCycle -> WHILE ( . expresion ) { body }
    (68) expresion -> . empty
    (73) empty -> .

    )               reduce using rule 73 (empty -> .)

    expresion                      shift and go to state 100
    empty                          shift and go to state 101

state 85

    (12) main -> MAIN { a body } .

    }               reduce using rule 12 (main -> MAIN { a body } .)


state 86

    (50) forCycle -> FOR ( . assign ; expresion ; assign ) { body }
    (51) assign -> . ID assignOptions

    ID              shift and go to state 102

    assign                         shift and go to state 103

state 87

    (57) funcCall -> ID ( . opParamCall )
    (58) opParamCall -> . expresion cyParamCall
    (68) expresion -> . empty
    (73) empty -> .

    ,               reduce using rule 73 (empty -> .)
    )               reduce using rule 73 (empty -> .)

    expresion                      shift and go to state 104
    empty                          shift and go to state 101
    opParamCall                    shift and go to state 105

state 88

    (53) assignOptions -> initDict .

    ;               reduce using rule 53 (assignOptions -> initDict .)
    :               reduce using rule 53 (assignOptions -> initDict .)
    )               reduce using rule 53 (assignOptions -> initDict .)


state 89

    (21) init -> = . i
    (24) initDict -> = . ( j : j )
    (22) i -> . expresion
    (23) i -> . funcCall
    (68) expresion -> . empty
    (57) funcCall -> . ID ( opParamCall )
    (73) empty -> .

    (               shift and go to state 109
    ID              shift and go to state 110
    ;               reduce using rule 73 (empty -> .)
    :               reduce using rule 73 (empty -> .)
    )               reduce using rule 73 (empty -> .)

    expresion                      shift and go to state 106
    funcCall                       shift and go to state 107
    i                              shift and go to state 108
    empty                          shift and go to state 101

state 90

    (51) assign -> ID assignOptions .

    ;               reduce using rule 51 (assign -> ID assignOptions .)
    )               reduce using rule 51 (assign -> ID assignOptions .)
    :               reduce using rule 51 (assign -> ID assignOptions .)


state 91

    (52) assignOptions -> init .

    ;               reduce using rule 52 (assignOptions -> init .)
    :               reduce using rule 52 (assignOptions -> init .)
    )               reduce using rule 52 (assignOptions -> init .)


state 92

    (54) assignOptions -> [ . expresion ] assignMatrix init
    (68) expresion -> . empty
    (73) empty -> .

    ]               reduce using rule 73 (empty -> .)

    expresion                      shift and go to state 111
    empty                          shift and go to state 101

state 93

    (64) condition -> IF ( . expresion ) { body } optionalElse
    (68) expresion -> . empty
    (73) empty -> .

    )               reduce using rule 73 (empty -> .)

    expresion                      shift and go to state 112
    empty                          shift and go to state 101

state 94

    (13) instr -> c ; .

    IF              reduce using rule 13 (instr -> c ; .)
    ID              reduce using rule 13 (instr -> c ; .)
    FOR             reduce using rule 13 (instr -> c ; .)
    WHILE           reduce using rule 13 (instr -> c ; .)
    }               reduce using rule 13 (instr -> c ; .)


state 95

    (32) l -> ( param n ) .

    RETURNS         reduce using rule 32 (l -> ( param n ) .)
    {               reduce using rule 32 (l -> ( param n ) .)


state 96

    (28) param -> type ID g . k
    (29) k -> . ; param
    (30) k -> . empty
    (73) empty -> .

    ;               shift and go to state 114
    INT             reduce using rule 73 (empty -> .)
    FLOAT           reduce using rule 73 (empty -> .)
    STRING          reduce using rule 73 (empty -> .)
    OBJECT          reduce using rule 73 (empty -> .)
    BOOL            reduce using rule 73 (empty -> .)
    )               reduce using rule 73 (empty -> .)

    k                              shift and go to state 113
    empty                          shift and go to state 115

state 97

    (31) function -> FUNC ID l m { a . body }
    (44) body -> . cycleInstruction
    (45) body -> . empty
    (46) cycleInstruction -> . instr body
    (73) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 73 (empty -> .)
    IF              shift and go to state 66
    ID              shift and go to state 64
    FOR             shift and go to state 63
    WHILE           shift and go to state 57

    body                           shift and go to state 116
    c                              shift and go to state 67
    funcCall                       shift and go to state 68
    cycleInstruction               shift and go to state 59
    instr                          shift and go to state 55
    forCycle                       shift and go to state 58
    whileCycle                     shift and go to state 56
    condition                      shift and go to state 65
    assign                         shift and go to state 69
    empty                          shift and go to state 61
    cycle                          shift and go to state 60

state 98

    (67) dict -> ( type : type . )

    )               shift and go to state 117


state 99

    (61) struct -> type [ CTED ] . optionalMatrix
    (62) optionalMatrix -> . [ CTED ]
    (63) optionalMatrix -> . empty
    (73) empty -> .

    [               shift and go to state 119
    ;               reduce using rule 73 (empty -> .)

    optionalMatrix                 shift and go to state 118
    empty                          shift and go to state 120

state 100

    (49) whileCycle -> WHILE ( expresion . ) { body }

    )               shift and go to state 121


state 101

    (68) expresion -> empty .

    ;               reduce using rule 68 (expresion -> empty .)
    :               reduce using rule 68 (expresion -> empty .)
    )               reduce using rule 68 (expresion -> empty .)
    ,               reduce using rule 68 (expresion -> empty .)
    ]               reduce using rule 68 (expresion -> empty .)


state 102

    (51) assign -> ID . assignOptions
    (52) assignOptions -> . init
    (53) assignOptions -> . initDict
    (54) assignOptions -> . [ expresion ] assignMatrix init
    (21) init -> . = i
    (24) initDict -> . = ( j : j )

    [               shift and go to state 92
    =               shift and go to state 89

    initDict                       shift and go to state 88
    assignOptions                  shift and go to state 90
    init                           shift and go to state 91

state 103

    (50) forCycle -> FOR ( assign . ; expresion ; assign ) { body }

    ;               shift and go to state 122


state 104

    (58) opParamCall -> expresion . cyParamCall
    (59) cyParamCall -> . , opParamCall
    (60) cyParamCall -> . empty
    (73) empty -> .

    ,               shift and go to state 124
    )               reduce using rule 73 (empty -> .)

    cyParamCall                    shift and go to state 123
    empty                          shift and go to state 125

state 105

    (57) funcCall -> ID ( opParamCall . )

    )               shift and go to state 126


state 106

    (22) i -> expresion .

    ;               reduce using rule 22 (i -> expresion .)
    :               reduce using rule 22 (i -> expresion .)
    )               reduce using rule 22 (i -> expresion .)


state 107

    (23) i -> funcCall .

    ;               reduce using rule 23 (i -> funcCall .)
    :               reduce using rule 23 (i -> funcCall .)
    )               reduce using rule 23 (i -> funcCall .)


state 108

    (21) init -> = i .

    ;               reduce using rule 21 (init -> = i .)
    :               reduce using rule 21 (init -> = i .)
    )               reduce using rule 21 (init -> = i .)


state 109

    (24) initDict -> = ( . j : j )
    (25) j -> . CTES
    (26) j -> . cte
    (27) j -> . ID
    (69) cte -> . CTED
    (70) cte -> . CTEF
    (71) cte -> . TRUE
    (72) cte -> . FALSE c

    CTES            shift and go to state 127
    ID              shift and go to state 133
    CTED            shift and go to state 132
    CTEF            shift and go to state 131
    TRUE            shift and go to state 134
    FALSE           shift and go to state 128

    cte                            shift and go to state 130
    j                              shift and go to state 129

state 110

    (57) funcCall -> ID . ( opParamCall )

    (               shift and go to state 87


state 111

    (54) assignOptions -> [ expresion . ] assignMatrix init

    ]               shift and go to state 135


state 112

    (64) condition -> IF ( expresion . ) { body } optionalElse

    )               shift and go to state 136


state 113

    (28) param -> type ID g k .

    INT             reduce using rule 28 (param -> type ID g k .)
    FLOAT           reduce using rule 28 (param -> type ID g k .)
    STRING          reduce using rule 28 (param -> type ID g k .)
    OBJECT          reduce using rule 28 (param -> type ID g k .)
    BOOL            reduce using rule 28 (param -> type ID g k .)
    )               reduce using rule 28 (param -> type ID g k .)


state 114

    (29) k -> ; . param
    (28) param -> . type ID g k
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 45
    param                          shift and go to state 137

state 115

    (30) k -> empty .

    INT             reduce using rule 30 (k -> empty .)
    FLOAT           reduce using rule 30 (k -> empty .)
    STRING          reduce using rule 30 (k -> empty .)
    OBJECT          reduce using rule 30 (k -> empty .)
    BOOL            reduce using rule 30 (k -> empty .)
    )               reduce using rule 30 (k -> empty .)


state 116

    (31) function -> FUNC ID l m { a body . }

    }               shift and go to state 138


state 117

    (67) dict -> ( type : type ) .

    ;               reduce using rule 67 (dict -> ( type : type ) .)


state 118

    (61) struct -> type [ CTED ] optionalMatrix .

    ;               reduce using rule 61 (struct -> type [ CTED ] optionalMatrix .)


state 119

    (62) optionalMatrix -> [ . CTED ]

    CTED            shift and go to state 139


state 120

    (63) optionalMatrix -> empty .

    ;               reduce using rule 63 (optionalMatrix -> empty .)


state 121

    (49) whileCycle -> WHILE ( expresion ) . { body }

    {               shift and go to state 140


state 122

    (50) forCycle -> FOR ( assign ; . expresion ; assign ) { body }
    (68) expresion -> . empty
    (73) empty -> .

    ;               reduce using rule 73 (empty -> .)

    expresion                      shift and go to state 141
    empty                          shift and go to state 101

state 123

    (58) opParamCall -> expresion cyParamCall .

    )               reduce using rule 58 (opParamCall -> expresion cyParamCall .)


state 124

    (59) cyParamCall -> , . opParamCall
    (58) opParamCall -> . expresion cyParamCall
    (68) expresion -> . empty
    (73) empty -> .

    ,               reduce using rule 73 (empty -> .)
    )               reduce using rule 73 (empty -> .)

    expresion                      shift and go to state 104
    empty                          shift and go to state 101
    opParamCall                    shift and go to state 142

state 125

    (60) cyParamCall -> empty .

    )               reduce using rule 60 (cyParamCall -> empty .)


state 126

    (57) funcCall -> ID ( opParamCall ) .

    ;               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    :               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)
    )               reduce using rule 57 (funcCall -> ID ( opParamCall ) .)


state 127

    (25) j -> CTES .

    :               reduce using rule 25 (j -> CTES .)
    )               reduce using rule 25 (j -> CTES .)


state 128

    (72) cte -> FALSE . c
    (16) c -> . assign
    (17) c -> . funcCall
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )

    ID              shift and go to state 64

    c                              shift and go to state 143
    assign                         shift and go to state 69
    funcCall                       shift and go to state 68

state 129

    (24) initDict -> = ( j . : j )

    :               shift and go to state 144


state 130

    (26) j -> cte .

    :               reduce using rule 26 (j -> cte .)
    )               reduce using rule 26 (j -> cte .)


state 131

    (70) cte -> CTEF .

    :               reduce using rule 70 (cte -> CTEF .)
    )               reduce using rule 70 (cte -> CTEF .)


state 132

    (69) cte -> CTED .

    :               reduce using rule 69 (cte -> CTED .)
    )               reduce using rule 69 (cte -> CTED .)


state 133

    (27) j -> ID .

    :               reduce using rule 27 (j -> ID .)
    )               reduce using rule 27 (j -> ID .)


state 134

    (71) cte -> TRUE .

    :               reduce using rule 71 (cte -> TRUE .)
    )               reduce using rule 71 (cte -> TRUE .)


state 135

    (54) assignOptions -> [ expresion ] . assignMatrix init
    (55) assignMatrix -> . [ expresion ]
    (56) assignMatrix -> . empty
    (73) empty -> .

    [               shift and go to state 146
    =               reduce using rule 73 (empty -> .)

    assignMatrix                   shift and go to state 145
    empty                          shift and go to state 147

state 136

    (64) condition -> IF ( expresion ) . { body } optionalElse

    {               shift and go to state 148


state 137

    (29) k -> ; param .

    INT             reduce using rule 29 (k -> ; param .)
    FLOAT           reduce using rule 29 (k -> ; param .)
    STRING          reduce using rule 29 (k -> ; param .)
    OBJECT          reduce using rule 29 (k -> ; param .)
    BOOL            reduce using rule 29 (k -> ; param .)
    )               reduce using rule 29 (k -> ; param .)


state 138

    (31) function -> FUNC ID l m { a body } .

    FUNC            reduce using rule 31 (function -> FUNC ID l m { a body } .)
    MAIN            reduce using rule 31 (function -> FUNC ID l m { a body } .)


state 139

    (62) optionalMatrix -> [ CTED . ]

    ]               shift and go to state 149


state 140

    (49) whileCycle -> WHILE ( expresion ) { . body }
    (44) body -> . cycleInstruction
    (45) body -> . empty
    (46) cycleInstruction -> . instr body
    (73) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 73 (empty -> .)
    IF              shift and go to state 66
    ID              shift and go to state 64
    FOR             shift and go to state 63
    WHILE           shift and go to state 57

    body                           shift and go to state 150
    c                              shift and go to state 67
    funcCall                       shift and go to state 68
    cycleInstruction               shift and go to state 59
    instr                          shift and go to state 55
    forCycle                       shift and go to state 58
    whileCycle                     shift and go to state 56
    condition                      shift and go to state 65
    assign                         shift and go to state 69
    empty                          shift and go to state 61
    cycle                          shift and go to state 60

state 141

    (50) forCycle -> FOR ( assign ; expresion . ; assign ) { body }

    ;               shift and go to state 151


state 142

    (59) cyParamCall -> , opParamCall .

    )               reduce using rule 59 (cyParamCall -> , opParamCall .)


state 143

    (72) cte -> FALSE c .

    :               reduce using rule 72 (cte -> FALSE c .)
    )               reduce using rule 72 (cte -> FALSE c .)


state 144

    (24) initDict -> = ( j : . j )
    (25) j -> . CTES
    (26) j -> . cte
    (27) j -> . ID
    (69) cte -> . CTED
    (70) cte -> . CTEF
    (71) cte -> . TRUE
    (72) cte -> . FALSE c

    CTES            shift and go to state 127
    ID              shift and go to state 133
    CTED            shift and go to state 132
    CTEF            shift and go to state 131
    TRUE            shift and go to state 134
    FALSE           shift and go to state 128

    cte                            shift and go to state 130
    j                              shift and go to state 152

state 145

    (54) assignOptions -> [ expresion ] assignMatrix . init
    (21) init -> . = i

    =               shift and go to state 154

    init                           shift and go to state 153

state 146

    (55) assignMatrix -> [ . expresion ]
    (68) expresion -> . empty
    (73) empty -> .

    ]               reduce using rule 73 (empty -> .)

    expresion                      shift and go to state 155
    empty                          shift and go to state 101

state 147

    (56) assignMatrix -> empty .

    =               reduce using rule 56 (assignMatrix -> empty .)


state 148

    (64) condition -> IF ( expresion ) { . body } optionalElse
    (44) body -> . cycleInstruction
    (45) body -> . empty
    (46) cycleInstruction -> . instr body
    (73) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 73 (empty -> .)
    IF              shift and go to state 66
    ID              shift and go to state 64
    FOR             shift and go to state 63
    WHILE           shift and go to state 57

    body                           shift and go to state 156
    c                              shift and go to state 67
    funcCall                       shift and go to state 68
    cycleInstruction               shift and go to state 59
    instr                          shift and go to state 55
    forCycle                       shift and go to state 58
    whileCycle                     shift and go to state 56
    condition                      shift and go to state 65
    assign                         shift and go to state 69
    empty                          shift and go to state 61
    cycle                          shift and go to state 60

state 149

    (62) optionalMatrix -> [ CTED ] .

    ;               reduce using rule 62 (optionalMatrix -> [ CTED ] .)


state 150

    (49) whileCycle -> WHILE ( expresion ) { body . }

    }               shift and go to state 157


state 151

    (50) forCycle -> FOR ( assign ; expresion ; . assign ) { body }
    (51) assign -> . ID assignOptions

    ID              shift and go to state 102

    assign                         shift and go to state 158

state 152

    (24) initDict -> = ( j : j . )

    )               shift and go to state 159


state 153

    (54) assignOptions -> [ expresion ] assignMatrix init .

    ;               reduce using rule 54 (assignOptions -> [ expresion ] assignMatrix init .)
    :               reduce using rule 54 (assignOptions -> [ expresion ] assignMatrix init .)
    )               reduce using rule 54 (assignOptions -> [ expresion ] assignMatrix init .)


state 154

    (21) init -> = . i
    (22) i -> . expresion
    (23) i -> . funcCall
    (68) expresion -> . empty
    (57) funcCall -> . ID ( opParamCall )
    (73) empty -> .

    ID              shift and go to state 110
    ;               reduce using rule 73 (empty -> .)
    :               reduce using rule 73 (empty -> .)
    )               reduce using rule 73 (empty -> .)

    i                              shift and go to state 108
    expresion                      shift and go to state 106
    empty                          shift and go to state 101
    funcCall                       shift and go to state 107

state 155

    (55) assignMatrix -> [ expresion . ]

    ]               shift and go to state 160


state 156

    (64) condition -> IF ( expresion ) { body . } optionalElse

    }               shift and go to state 161


state 157

    (49) whileCycle -> WHILE ( expresion ) { body } .

    IF              reduce using rule 49 (whileCycle -> WHILE ( expresion ) { body } .)
    ID              reduce using rule 49 (whileCycle -> WHILE ( expresion ) { body } .)
    FOR             reduce using rule 49 (whileCycle -> WHILE ( expresion ) { body } .)
    WHILE           reduce using rule 49 (whileCycle -> WHILE ( expresion ) { body } .)
    }               reduce using rule 49 (whileCycle -> WHILE ( expresion ) { body } .)


state 158

    (50) forCycle -> FOR ( assign ; expresion ; assign . ) { body }

    )               shift and go to state 162


state 159

    (24) initDict -> = ( j : j ) .

    ;               reduce using rule 24 (initDict -> = ( j : j ) .)
    )               reduce using rule 24 (initDict -> = ( j : j ) .)
    :               reduce using rule 24 (initDict -> = ( j : j ) .)


state 160

    (55) assignMatrix -> [ expresion ] .

    =               reduce using rule 55 (assignMatrix -> [ expresion ] .)


state 161

    (64) condition -> IF ( expresion ) { body } . optionalElse
    (65) optionalElse -> . ELSE { body }
    (66) optionalElse -> . empty
    (73) empty -> .

    ELSE            shift and go to state 163
    IF              reduce using rule 73 (empty -> .)
    ID              reduce using rule 73 (empty -> .)
    FOR             reduce using rule 73 (empty -> .)
    WHILE           reduce using rule 73 (empty -> .)
    }               reduce using rule 73 (empty -> .)

    optionalElse                   shift and go to state 164
    empty                          shift and go to state 165

state 162

    (50) forCycle -> FOR ( assign ; expresion ; assign ) . { body }

    {               shift and go to state 166


state 163

    (65) optionalElse -> ELSE . { body }

    {               shift and go to state 167


state 164

    (64) condition -> IF ( expresion ) { body } optionalElse .

    IF              reduce using rule 64 (condition -> IF ( expresion ) { body } optionalElse .)
    ID              reduce using rule 64 (condition -> IF ( expresion ) { body } optionalElse .)
    FOR             reduce using rule 64 (condition -> IF ( expresion ) { body } optionalElse .)
    WHILE           reduce using rule 64 (condition -> IF ( expresion ) { body } optionalElse .)
    }               reduce using rule 64 (condition -> IF ( expresion ) { body } optionalElse .)


state 165

    (66) optionalElse -> empty .

    IF              reduce using rule 66 (optionalElse -> empty .)
    ID              reduce using rule 66 (optionalElse -> empty .)
    FOR             reduce using rule 66 (optionalElse -> empty .)
    WHILE           reduce using rule 66 (optionalElse -> empty .)
    }               reduce using rule 66 (optionalElse -> empty .)


state 166

    (50) forCycle -> FOR ( assign ; expresion ; assign ) { . body }
    (44) body -> . cycleInstruction
    (45) body -> . empty
    (46) cycleInstruction -> . instr body
    (73) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 73 (empty -> .)
    IF              shift and go to state 66
    ID              shift and go to state 64
    FOR             shift and go to state 63
    WHILE           shift and go to state 57

    body                           shift and go to state 168
    c                              shift and go to state 67
    funcCall                       shift and go to state 68
    cycleInstruction               shift and go to state 59
    instr                          shift and go to state 55
    forCycle                       shift and go to state 58
    whileCycle                     shift and go to state 56
    condition                      shift and go to state 65
    assign                         shift and go to state 69
    empty                          shift and go to state 61
    cycle                          shift and go to state 60

state 167

    (65) optionalElse -> ELSE { . body }
    (44) body -> . cycleInstruction
    (45) body -> . empty
    (46) cycleInstruction -> . instr body
    (73) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (64) condition -> . IF ( expresion ) { body } optionalElse
    (47) cycle -> . forCycle
    (48) cycle -> . whileCycle
    (51) assign -> . ID assignOptions
    (57) funcCall -> . ID ( opParamCall )
    (50) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (49) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 73 (empty -> .)
    IF              shift and go to state 66
    ID              shift and go to state 64
    FOR             shift and go to state 63
    WHILE           shift and go to state 57

    body                           shift and go to state 169
    c                              shift and go to state 67
    funcCall                       shift and go to state 68
    cycleInstruction               shift and go to state 59
    instr                          shift and go to state 55
    forCycle                       shift and go to state 58
    whileCycle                     shift and go to state 56
    empty                          shift and go to state 61
    assign                         shift and go to state 69
    condition                      shift and go to state 65
    cycle                          shift and go to state 60

state 168

    (50) forCycle -> FOR ( assign ; expresion ; assign ) { body . }

    }               shift and go to state 170


state 169

    (65) optionalElse -> ELSE { body . }

    }               shift and go to state 171


state 170

    (50) forCycle -> FOR ( assign ; expresion ; assign ) { body } .

    IF              reduce using rule 50 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    ID              reduce using rule 50 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    FOR             reduce using rule 50 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    WHILE           reduce using rule 50 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    }               reduce using rule 50 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)


state 171

    (65) optionalElse -> ELSE { body } .

    IF              reduce using rule 65 (optionalElse -> ELSE { body } .)
    ID              reduce using rule 65 (optionalElse -> ELSE { body } .)
    FOR             reduce using rule 65 (optionalElse -> ELSE { body } .)
    WHILE           reduce using rule 65 (optionalElse -> ELSE { body } .)
    }               reduce using rule 65 (optionalElse -> ELSE { body } .)

