Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    RETURN

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID { a b main }
Rule 2     a -> vars
Rule 3     a -> empty
Rule 4     b -> function b
Rule 5     b -> empty
Rule 6     vars -> VARS declare
Rule 7     type -> INT
Rule 8     type -> FLOAT
Rule 9     type -> STRING
Rule 10    type -> OBJECT
Rule 11    type -> BOOL
Rule 12    main -> MAIN { a body }
Rule 13    instr -> c ;
Rule 14    instr -> condition
Rule 15    instr -> cycle
Rule 16    c -> assign
Rule 17    c -> funcCall
Rule 18    declare -> d
Rule 19    declare -> e
Rule 20    declare -> f
Rule 21    init -> = i
Rule 22    i -> expresion
Rule 23    i -> funcCall
Rule 24    initDict -> = ( j : j )
Rule 25    j -> CTES
Rule 26    j -> cte
Rule 27    j -> ID
Rule 28    param -> type ID g k
Rule 29    k -> ; param
Rule 30    k -> empty
Rule 31    function -> FUNC ID opParameters opReturns { a body }
Rule 32    opParameters -> ( param )
Rule 33    opParameters -> empty
Rule 34    opReturns -> RETURNS type
Rule 35    opReturns -> empty
Rule 36    d -> type ID g ; h
Rule 37    e -> STRUCT ID struct ; h
Rule 38    f -> DICT ID dict ; h
Rule 39    g -> , ID
Rule 40    g -> empty
Rule 41    h -> declare
Rule 42    h -> empty
Rule 43    body -> cycleInstruction
Rule 44    body -> empty
Rule 45    cycleInstruction -> instr body
Rule 46    cycle -> forCycle
Rule 47    cycle -> whileCycle
Rule 48    whileCycle -> WHILE ( expresion ) { body }
Rule 49    forCycle -> FOR ( assign ; expresion ; assign ) { body }
Rule 50    assign -> ID assignOptions
Rule 51    assignOptions -> init
Rule 52    assignOptions -> initDict
Rule 53    assignOptions -> [ expresion ] assignMatrix init
Rule 54    assignMatrix -> [ expresion ]
Rule 55    assignMatrix -> empty
Rule 56    funcCall -> ID ( opParamCall )
Rule 57    opParamCall -> expresion cyParamCall
Rule 58    cyParamCall -> , opParamCall
Rule 59    cyParamCall -> empty
Rule 60    struct -> type [ CTED ] optionalMatrix
Rule 61    optionalMatrix -> [ CTED ]
Rule 62    optionalMatrix -> empty
Rule 63    condition -> IF ( expresion ) { body } optionalElse
Rule 64    optionalElse -> ELSE { body }
Rule 65    optionalElse -> empty
Rule 66    dict -> ( type : type )
Rule 67    expresion -> sExp cyExpresion
Rule 68    cyExpresion -> AND expresion
Rule 69    cyExpresion -> OR expresion
Rule 70    cyExpresion -> empty
Rule 71    sExp -> exp cySExp
Rule 72    cySExp -> EQ sExp
Rule 73    cySExp -> DIF sExp
Rule 74    cySExp -> LTOEQ sExp
Rule 75    cySExp -> GTOEQ sExp
Rule 76    cySExp -> > sExp
Rule 77    cySExp -> < sExp
Rule 78    cySExp -> empty
Rule 79    exp -> term cyExp
Rule 80    cyExp -> + term
Rule 81    cyExp -> - term
Rule 82    cyExp -> empty
Rule 83    term -> fact cyTerm
Rule 84    cyTerm -> * fact
Rule 85    cyTerm -> / fact
Rule 86    cyTerm -> empty
Rule 87    fact -> CTES
Rule 88    fact -> cte
Rule 89    fact -> funcCall
Rule 90    fact -> ( expresion )
Rule 91    fact -> ID opAccess
Rule 92    fact -> empty
Rule 93    opAccess -> opStruct
Rule 94    opAccess -> opDictionary
Rule 95    opAccess -> empty
Rule 96    opStruct -> [ expresion ] opMatrix
Rule 97    opMatrix -> [ expresion ]
Rule 98    opMatrix -> empty
Rule 99    opDictionary -> . dictIndex
Rule 100   dictIndex -> FIRST
Rule 101   dictIndex -> LAST
Rule 102   cte -> CTED
Rule 103   cte -> CTEF
Rule 104   cte -> TRUE
Rule 105   cte -> FALSE c
Rule 106   empty -> <empty>

Terminals, with rules where they appear

(                    : 24 32 48 49 56 63 66 90
)                    : 24 32 48 49 56 63 66 90
*                    : 84
+                    : 80
,                    : 39 58
-                    : 81
.                    : 99
/                    : 85
:                    : 24 66
;                    : 13 29 36 37 38 49 49
<                    : 77
=                    : 21 24
>                    : 76
AND                  : 68
BOOL                 : 11
CTED                 : 60 61 102
CTEF                 : 103
CTES                 : 25 87
DICT                 : 38
DIF                  : 73
ELSE                 : 64
EQ                   : 72
FALSE                : 105
FIRST                : 100
FLOAT                : 8
FOR                  : 49
FUNC                 : 31
GTOEQ                : 75
ID                   : 1 27 28 31 36 37 38 39 50 56 91
IF                   : 63
INT                  : 7
LAST                 : 101
LTOEQ                : 74
MAIN                 : 12
OBJECT               : 10
OR                   : 69
PROGRAM              : 1
RETURN               : 
RETURNS              : 34
STRING               : 9
STRUCT               : 37
TRUE                 : 104
VARS                 : 6
WHILE                : 48
[                    : 53 54 60 61 96 97
]                    : 53 54 60 61 96 97
error                : 
{                    : 1 12 31 48 49 63 64
}                    : 1 12 31 48 49 63 64

Nonterminals, with rules where they appear

a                    : 1 12 31
assign               : 16 49 49
assignMatrix         : 53
assignOptions        : 50
b                    : 1 4
body                 : 12 31 45 48 49 63 64
c                    : 13 105
condition            : 14
cte                  : 26 88
cyExp                : 79
cyExpresion          : 67
cyParamCall          : 57
cySExp               : 71
cyTerm               : 83
cycle                : 15
cycleInstruction     : 43
d                    : 18
declare              : 6 41
dict                 : 38
dictIndex            : 99
e                    : 19
empty                : 3 5 30 33 35 40 42 44 55 59 62 65 70 78 82 86 92 95 98
exp                  : 71
expresion            : 22 48 49 53 54 57 63 68 69 90 96 97
f                    : 20
fact                 : 83 84 85
forCycle             : 46
funcCall             : 17 23 89
function             : 4
g                    : 28 36
h                    : 36 37 38
i                    : 21
init                 : 51 53
initDict             : 52
instr                : 45
j                    : 24 24
k                    : 28
main                 : 1
opAccess             : 91
opDictionary         : 94
opMatrix             : 96
opParamCall          : 56 58
opParameters         : 31
opReturns            : 31
opStruct             : 93
optionalElse         : 63
optionalMatrix       : 60
param                : 29 32
program              : 0
sExp                 : 67 72 73 74 75 76 77
struct               : 37
term                 : 79 80 81
type                 : 28 34 36 60 66 66
vars                 : 2
whileCycle           : 47

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID { a b main }

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID { a b main }

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . { a b main }

    {               shift and go to state 4


state 4

    (1) program -> PROGRAM ID { . a b main }
    (2) a -> . vars
    (3) a -> . empty
    (6) vars -> . VARS declare
    (106) empty -> .

    VARS            shift and go to state 6
    FUNC            reduce using rule 106 (empty -> .)
    MAIN            reduce using rule 106 (empty -> .)

    a                              shift and go to state 5
    vars                           shift and go to state 7
    empty                          shift and go to state 8

state 5

    (1) program -> PROGRAM ID { a . b main }
    (4) b -> . function b
    (5) b -> . empty
    (31) function -> . FUNC ID opParameters opReturns { a body }
    (106) empty -> .

    FUNC            shift and go to state 11
    MAIN            reduce using rule 106 (empty -> .)

    function                       shift and go to state 9
    b                              shift and go to state 10
    empty                          shift and go to state 12

state 6

    (6) vars -> VARS . declare
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (36) d -> . type ID g ; h
    (37) e -> . STRUCT ID struct ; h
    (38) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    STRUCT          shift and go to state 24
    DICT            shift and go to state 20
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    e                              shift and go to state 14
    d                              shift and go to state 15
    f                              shift and go to state 16
    type                           shift and go to state 22
    declare                        shift and go to state 23

state 7

    (2) a -> vars .

    IF              reduce using rule 2 (a -> vars .)
    ID              reduce using rule 2 (a -> vars .)
    FOR             reduce using rule 2 (a -> vars .)
    WHILE           reduce using rule 2 (a -> vars .)
    }               reduce using rule 2 (a -> vars .)
    FUNC            reduce using rule 2 (a -> vars .)
    MAIN            reduce using rule 2 (a -> vars .)


state 8

    (3) a -> empty .

    IF              reduce using rule 3 (a -> empty .)
    ID              reduce using rule 3 (a -> empty .)
    FOR             reduce using rule 3 (a -> empty .)
    WHILE           reduce using rule 3 (a -> empty .)
    }               reduce using rule 3 (a -> empty .)
    FUNC            reduce using rule 3 (a -> empty .)
    MAIN            reduce using rule 3 (a -> empty .)


state 9

    (4) b -> function . b
    (4) b -> . function b
    (5) b -> . empty
    (31) function -> . FUNC ID opParameters opReturns { a body }
    (106) empty -> .

    FUNC            shift and go to state 11
    MAIN            reduce using rule 106 (empty -> .)

    function                       shift and go to state 9
    b                              shift and go to state 25
    empty                          shift and go to state 12

state 10

    (1) program -> PROGRAM ID { a b . main }
    (12) main -> . MAIN { a body }

    MAIN            shift and go to state 26

    main                           shift and go to state 27

state 11

    (31) function -> FUNC . ID opParameters opReturns { a body }

    ID              shift and go to state 28


state 12

    (5) b -> empty .

    MAIN            reduce using rule 5 (b -> empty .)


state 13

    (10) type -> OBJECT .

    ID              reduce using rule 10 (type -> OBJECT .)
    {               reduce using rule 10 (type -> OBJECT .)
    )               reduce using rule 10 (type -> OBJECT .)
    [               reduce using rule 10 (type -> OBJECT .)
    :               reduce using rule 10 (type -> OBJECT .)


state 14

    (19) declare -> e .

    FUNC            reduce using rule 19 (declare -> e .)
    MAIN            reduce using rule 19 (declare -> e .)
    IF              reduce using rule 19 (declare -> e .)
    ID              reduce using rule 19 (declare -> e .)
    FOR             reduce using rule 19 (declare -> e .)
    WHILE           reduce using rule 19 (declare -> e .)
    }               reduce using rule 19 (declare -> e .)


state 15

    (18) declare -> d .

    FUNC            reduce using rule 18 (declare -> d .)
    MAIN            reduce using rule 18 (declare -> d .)
    IF              reduce using rule 18 (declare -> d .)
    ID              reduce using rule 18 (declare -> d .)
    FOR             reduce using rule 18 (declare -> d .)
    WHILE           reduce using rule 18 (declare -> d .)
    }               reduce using rule 18 (declare -> d .)


state 16

    (20) declare -> f .

    FUNC            reduce using rule 20 (declare -> f .)
    MAIN            reduce using rule 20 (declare -> f .)
    IF              reduce using rule 20 (declare -> f .)
    ID              reduce using rule 20 (declare -> f .)
    FOR             reduce using rule 20 (declare -> f .)
    WHILE           reduce using rule 20 (declare -> f .)
    }               reduce using rule 20 (declare -> f .)


state 17

    (7) type -> INT .

    ID              reduce using rule 7 (type -> INT .)
    {               reduce using rule 7 (type -> INT .)
    )               reduce using rule 7 (type -> INT .)
    [               reduce using rule 7 (type -> INT .)
    :               reduce using rule 7 (type -> INT .)


state 18

    (8) type -> FLOAT .

    ID              reduce using rule 8 (type -> FLOAT .)
    {               reduce using rule 8 (type -> FLOAT .)
    )               reduce using rule 8 (type -> FLOAT .)
    [               reduce using rule 8 (type -> FLOAT .)
    :               reduce using rule 8 (type -> FLOAT .)


state 19

    (9) type -> STRING .

    ID              reduce using rule 9 (type -> STRING .)
    {               reduce using rule 9 (type -> STRING .)
    )               reduce using rule 9 (type -> STRING .)
    [               reduce using rule 9 (type -> STRING .)
    :               reduce using rule 9 (type -> STRING .)


state 20

    (38) f -> DICT . ID dict ; h

    ID              shift and go to state 29


state 21

    (11) type -> BOOL .

    ID              reduce using rule 11 (type -> BOOL .)
    {               reduce using rule 11 (type -> BOOL .)
    )               reduce using rule 11 (type -> BOOL .)
    [               reduce using rule 11 (type -> BOOL .)
    :               reduce using rule 11 (type -> BOOL .)


state 22

    (36) d -> type . ID g ; h

    ID              shift and go to state 30


state 23

    (6) vars -> VARS declare .

    FUNC            reduce using rule 6 (vars -> VARS declare .)
    MAIN            reduce using rule 6 (vars -> VARS declare .)
    IF              reduce using rule 6 (vars -> VARS declare .)
    ID              reduce using rule 6 (vars -> VARS declare .)
    FOR             reduce using rule 6 (vars -> VARS declare .)
    WHILE           reduce using rule 6 (vars -> VARS declare .)
    }               reduce using rule 6 (vars -> VARS declare .)


state 24

    (37) e -> STRUCT . ID struct ; h

    ID              shift and go to state 31


state 25

    (4) b -> function b .

    MAIN            reduce using rule 4 (b -> function b .)


state 26

    (12) main -> MAIN . { a body }

    {               shift and go to state 32


state 27

    (1) program -> PROGRAM ID { a b main . }

    }               shift and go to state 33


state 28

    (31) function -> FUNC ID . opParameters opReturns { a body }
    (32) opParameters -> . ( param )
    (33) opParameters -> . empty
    (106) empty -> .

    (               shift and go to state 35
    RETURNS         reduce using rule 106 (empty -> .)
    {               reduce using rule 106 (empty -> .)

    opParameters                   shift and go to state 34
    empty                          shift and go to state 36

state 29

    (38) f -> DICT ID . dict ; h
    (66) dict -> . ( type : type )

    (               shift and go to state 37

    dict                           shift and go to state 38

state 30

    (36) d -> type ID . g ; h
    (39) g -> . , ID
    (40) g -> . empty
    (106) empty -> .

    ,               shift and go to state 40
    ;               reduce using rule 106 (empty -> .)

    empty                          shift and go to state 41
    g                              shift and go to state 39

state 31

    (37) e -> STRUCT ID . struct ; h
    (60) struct -> . type [ CTED ] optionalMatrix
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 43
    struct                         shift and go to state 42

state 32

    (12) main -> MAIN { . a body }
    (2) a -> . vars
    (3) a -> . empty
    (6) vars -> . VARS declare
    (106) empty -> .

    VARS            shift and go to state 6
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)

    a                              shift and go to state 44
    empty                          shift and go to state 8
    vars                           shift and go to state 7

state 33

    (1) program -> PROGRAM ID { a b main } .

    $end            reduce using rule 1 (program -> PROGRAM ID { a b main } .)


state 34

    (31) function -> FUNC ID opParameters . opReturns { a body }
    (34) opReturns -> . RETURNS type
    (35) opReturns -> . empty
    (106) empty -> .

    RETURNS         shift and go to state 45
    {               reduce using rule 106 (empty -> .)

    empty                          shift and go to state 46
    opReturns                      shift and go to state 47

state 35

    (32) opParameters -> ( . param )
    (28) param -> . type ID g k
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 49
    param                          shift and go to state 48

state 36

    (33) opParameters -> empty .

    RETURNS         reduce using rule 33 (opParameters -> empty .)
    {               reduce using rule 33 (opParameters -> empty .)


state 37

    (66) dict -> ( . type : type )
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 50

state 38

    (38) f -> DICT ID dict . ; h

    ;               shift and go to state 51


state 39

    (36) d -> type ID g . ; h

    ;               shift and go to state 52


state 40

    (39) g -> , . ID

    ID              shift and go to state 53


state 41

    (40) g -> empty .

    ;               reduce using rule 40 (g -> empty .)
    )               reduce using rule 40 (g -> empty .)


state 42

    (37) e -> STRUCT ID struct . ; h

    ;               shift and go to state 54


state 43

    (60) struct -> type . [ CTED ] optionalMatrix

    [               shift and go to state 55


state 44

    (12) main -> MAIN { a . body }
    (43) body -> . cycleInstruction
    (44) body -> . empty
    (45) cycleInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (63) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 67
    ID              shift and go to state 65
    FOR             shift and go to state 64
    WHILE           shift and go to state 58

    body                           shift and go to state 63
    c                              shift and go to state 68
    funcCall                       shift and go to state 69
    cycleInstruction               shift and go to state 60
    instr                          shift and go to state 56
    forCycle                       shift and go to state 59
    whileCycle                     shift and go to state 57
    condition                      shift and go to state 66
    assign                         shift and go to state 70
    empty                          shift and go to state 62
    cycle                          shift and go to state 61

state 45

    (34) opReturns -> RETURNS . type
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 71

state 46

    (35) opReturns -> empty .

    {               reduce using rule 35 (opReturns -> empty .)


state 47

    (31) function -> FUNC ID opParameters opReturns . { a body }

    {               shift and go to state 72


state 48

    (32) opParameters -> ( param . )

    )               shift and go to state 73


state 49

    (28) param -> type . ID g k

    ID              shift and go to state 74


state 50

    (66) dict -> ( type . : type )

    :               shift and go to state 75


state 51

    (38) f -> DICT ID dict ; . h
    (41) h -> . declare
    (42) h -> . empty
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (106) empty -> .
    (36) d -> . type ID g ; h
    (37) e -> . STRUCT ID struct ; h
    (38) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 106 (empty -> .)
    MAIN            reduce using rule 106 (empty -> .)
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)
    STRUCT          shift and go to state 24
    DICT            shift and go to state 20
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    e                              shift and go to state 14
    d                              shift and go to state 15
    f                              shift and go to state 16
    h                              shift and go to state 76
    type                           shift and go to state 22
    declare                        shift and go to state 77
    empty                          shift and go to state 78

state 52

    (36) d -> type ID g ; . h
    (41) h -> . declare
    (42) h -> . empty
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (106) empty -> .
    (36) d -> . type ID g ; h
    (37) e -> . STRUCT ID struct ; h
    (38) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 106 (empty -> .)
    MAIN            reduce using rule 106 (empty -> .)
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)
    STRUCT          shift and go to state 24
    DICT            shift and go to state 20
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    e                              shift and go to state 14
    d                              shift and go to state 15
    f                              shift and go to state 16
    h                              shift and go to state 79
    type                           shift and go to state 22
    declare                        shift and go to state 77
    empty                          shift and go to state 78

state 53

    (39) g -> , ID .

    ;               reduce using rule 39 (g -> , ID .)
    )               reduce using rule 39 (g -> , ID .)


state 54

    (37) e -> STRUCT ID struct ; . h
    (41) h -> . declare
    (42) h -> . empty
    (18) declare -> . d
    (19) declare -> . e
    (20) declare -> . f
    (106) empty -> .
    (36) d -> . type ID g ; h
    (37) e -> . STRUCT ID struct ; h
    (38) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    FUNC            reduce using rule 106 (empty -> .)
    MAIN            reduce using rule 106 (empty -> .)
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)
    STRUCT          shift and go to state 24
    DICT            shift and go to state 20
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    e                              shift and go to state 14
    d                              shift and go to state 15
    f                              shift and go to state 16
    h                              shift and go to state 80
    type                           shift and go to state 22
    declare                        shift and go to state 77
    empty                          shift and go to state 78

state 55

    (60) struct -> type [ . CTED ] optionalMatrix

    CTED            shift and go to state 81


state 56

    (45) cycleInstruction -> instr . body
    (43) body -> . cycleInstruction
    (44) body -> . empty
    (45) cycleInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (63) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 67
    ID              shift and go to state 65
    FOR             shift and go to state 64
    WHILE           shift and go to state 58

    body                           shift and go to state 82
    c                              shift and go to state 68
    funcCall                       shift and go to state 69
    cycleInstruction               shift and go to state 60
    instr                          shift and go to state 56
    forCycle                       shift and go to state 59
    whileCycle                     shift and go to state 57
    empty                          shift and go to state 62
    assign                         shift and go to state 70
    condition                      shift and go to state 66
    cycle                          shift and go to state 61

state 57

    (47) cycle -> whileCycle .

    IF              reduce using rule 47 (cycle -> whileCycle .)
    ID              reduce using rule 47 (cycle -> whileCycle .)
    FOR             reduce using rule 47 (cycle -> whileCycle .)
    WHILE           reduce using rule 47 (cycle -> whileCycle .)
    }               reduce using rule 47 (cycle -> whileCycle .)


state 58

    (48) whileCycle -> WHILE . ( expresion ) { body }

    (               shift and go to state 83


state 59

    (46) cycle -> forCycle .

    IF              reduce using rule 46 (cycle -> forCycle .)
    ID              reduce using rule 46 (cycle -> forCycle .)
    FOR             reduce using rule 46 (cycle -> forCycle .)
    WHILE           reduce using rule 46 (cycle -> forCycle .)
    }               reduce using rule 46 (cycle -> forCycle .)


state 60

    (43) body -> cycleInstruction .

    }               reduce using rule 43 (body -> cycleInstruction .)


state 61

    (15) instr -> cycle .

    IF              reduce using rule 15 (instr -> cycle .)
    ID              reduce using rule 15 (instr -> cycle .)
    FOR             reduce using rule 15 (instr -> cycle .)
    WHILE           reduce using rule 15 (instr -> cycle .)
    }               reduce using rule 15 (instr -> cycle .)


state 62

    (44) body -> empty .

    }               reduce using rule 44 (body -> empty .)


state 63

    (12) main -> MAIN { a body . }

    }               shift and go to state 84


state 64

    (49) forCycle -> FOR . ( assign ; expresion ; assign ) { body }

    (               shift and go to state 85


state 65

    (50) assign -> ID . assignOptions
    (56) funcCall -> ID . ( opParamCall )
    (51) assignOptions -> . init
    (52) assignOptions -> . initDict
    (53) assignOptions -> . [ expresion ] assignMatrix init
    (21) init -> . = i
    (24) initDict -> . = ( j : j )

    (               shift and go to state 86
    [               shift and go to state 91
    =               shift and go to state 88

    initDict                       shift and go to state 87
    assignOptions                  shift and go to state 89
    init                           shift and go to state 90

state 66

    (14) instr -> condition .

    IF              reduce using rule 14 (instr -> condition .)
    ID              reduce using rule 14 (instr -> condition .)
    FOR             reduce using rule 14 (instr -> condition .)
    WHILE           reduce using rule 14 (instr -> condition .)
    }               reduce using rule 14 (instr -> condition .)


state 67

    (63) condition -> IF . ( expresion ) { body } optionalElse

    (               shift and go to state 92


state 68

    (13) instr -> c . ;

    ;               shift and go to state 93


state 69

    (17) c -> funcCall .

    ;               reduce using rule 17 (c -> funcCall .)
    *               reduce using rule 17 (c -> funcCall .)
    /               reduce using rule 17 (c -> funcCall .)
    +               reduce using rule 17 (c -> funcCall .)
    -               reduce using rule 17 (c -> funcCall .)
    EQ              reduce using rule 17 (c -> funcCall .)
    DIF             reduce using rule 17 (c -> funcCall .)
    LTOEQ           reduce using rule 17 (c -> funcCall .)
    GTOEQ           reduce using rule 17 (c -> funcCall .)
    >               reduce using rule 17 (c -> funcCall .)
    <               reduce using rule 17 (c -> funcCall .)
    AND             reduce using rule 17 (c -> funcCall .)
    OR              reduce using rule 17 (c -> funcCall .)
    )               reduce using rule 17 (c -> funcCall .)
    ,               reduce using rule 17 (c -> funcCall .)
    ]               reduce using rule 17 (c -> funcCall .)
    :               reduce using rule 17 (c -> funcCall .)


state 70

    (16) c -> assign .

    ;               reduce using rule 16 (c -> assign .)
    *               reduce using rule 16 (c -> assign .)
    /               reduce using rule 16 (c -> assign .)
    +               reduce using rule 16 (c -> assign .)
    -               reduce using rule 16 (c -> assign .)
    EQ              reduce using rule 16 (c -> assign .)
    DIF             reduce using rule 16 (c -> assign .)
    LTOEQ           reduce using rule 16 (c -> assign .)
    GTOEQ           reduce using rule 16 (c -> assign .)
    >               reduce using rule 16 (c -> assign .)
    <               reduce using rule 16 (c -> assign .)
    AND             reduce using rule 16 (c -> assign .)
    OR              reduce using rule 16 (c -> assign .)
    )               reduce using rule 16 (c -> assign .)
    ,               reduce using rule 16 (c -> assign .)
    ]               reduce using rule 16 (c -> assign .)
    :               reduce using rule 16 (c -> assign .)


state 71

    (34) opReturns -> RETURNS type .

    {               reduce using rule 34 (opReturns -> RETURNS type .)


state 72

    (31) function -> FUNC ID opParameters opReturns { . a body }
    (2) a -> . vars
    (3) a -> . empty
    (6) vars -> . VARS declare
    (106) empty -> .

    VARS            shift and go to state 6
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)

    a                              shift and go to state 94
    vars                           shift and go to state 7
    empty                          shift and go to state 8

state 73

    (32) opParameters -> ( param ) .

    RETURNS         reduce using rule 32 (opParameters -> ( param ) .)
    {               reduce using rule 32 (opParameters -> ( param ) .)


state 74

    (28) param -> type ID . g k
    (39) g -> . , ID
    (40) g -> . empty
    (106) empty -> .

    ,               shift and go to state 40
    ;               reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)

    empty                          shift and go to state 41
    g                              shift and go to state 95

state 75

    (66) dict -> ( type : . type )
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 96

state 76

    (38) f -> DICT ID dict ; h .

    FUNC            reduce using rule 38 (f -> DICT ID dict ; h .)
    MAIN            reduce using rule 38 (f -> DICT ID dict ; h .)
    IF              reduce using rule 38 (f -> DICT ID dict ; h .)
    ID              reduce using rule 38 (f -> DICT ID dict ; h .)
    FOR             reduce using rule 38 (f -> DICT ID dict ; h .)
    WHILE           reduce using rule 38 (f -> DICT ID dict ; h .)
    }               reduce using rule 38 (f -> DICT ID dict ; h .)


state 77

    (41) h -> declare .

    FUNC            reduce using rule 41 (h -> declare .)
    MAIN            reduce using rule 41 (h -> declare .)
    IF              reduce using rule 41 (h -> declare .)
    ID              reduce using rule 41 (h -> declare .)
    FOR             reduce using rule 41 (h -> declare .)
    WHILE           reduce using rule 41 (h -> declare .)
    }               reduce using rule 41 (h -> declare .)


state 78

    (42) h -> empty .

    FUNC            reduce using rule 42 (h -> empty .)
    MAIN            reduce using rule 42 (h -> empty .)
    IF              reduce using rule 42 (h -> empty .)
    ID              reduce using rule 42 (h -> empty .)
    FOR             reduce using rule 42 (h -> empty .)
    WHILE           reduce using rule 42 (h -> empty .)
    }               reduce using rule 42 (h -> empty .)


state 79

    (36) d -> type ID g ; h .

    FUNC            reduce using rule 36 (d -> type ID g ; h .)
    MAIN            reduce using rule 36 (d -> type ID g ; h .)
    IF              reduce using rule 36 (d -> type ID g ; h .)
    ID              reduce using rule 36 (d -> type ID g ; h .)
    FOR             reduce using rule 36 (d -> type ID g ; h .)
    WHILE           reduce using rule 36 (d -> type ID g ; h .)
    }               reduce using rule 36 (d -> type ID g ; h .)


state 80

    (37) e -> STRUCT ID struct ; h .

    FUNC            reduce using rule 37 (e -> STRUCT ID struct ; h .)
    MAIN            reduce using rule 37 (e -> STRUCT ID struct ; h .)
    IF              reduce using rule 37 (e -> STRUCT ID struct ; h .)
    ID              reduce using rule 37 (e -> STRUCT ID struct ; h .)
    FOR             reduce using rule 37 (e -> STRUCT ID struct ; h .)
    WHILE           reduce using rule 37 (e -> STRUCT ID struct ; h .)
    }               reduce using rule 37 (e -> STRUCT ID struct ; h .)


state 81

    (60) struct -> type [ CTED . ] optionalMatrix

    ]               shift and go to state 97


state 82

    (45) cycleInstruction -> instr body .

    }               reduce using rule 45 (cycleInstruction -> instr body .)


state 83

    (48) whileCycle -> WHILE ( . expresion ) { body }
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 104
    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 84

    (12) main -> MAIN { a body } .

    }               reduce using rule 12 (main -> MAIN { a body } .)


state 85

    (49) forCycle -> FOR ( . assign ; expresion ; assign ) { body }
    (50) assign -> . ID assignOptions

    ID              shift and go to state 113

    assign                         shift and go to state 114

state 86

    (56) funcCall -> ID ( . opParamCall )
    (57) opParamCall -> . expresion cyParamCall
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 116
    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    opParamCall                    shift and go to state 115
    fact                           shift and go to state 112

state 87

    (52) assignOptions -> initDict .

    ;               reduce using rule 52 (assignOptions -> initDict .)
    *               reduce using rule 52 (assignOptions -> initDict .)
    /               reduce using rule 52 (assignOptions -> initDict .)
    +               reduce using rule 52 (assignOptions -> initDict .)
    -               reduce using rule 52 (assignOptions -> initDict .)
    EQ              reduce using rule 52 (assignOptions -> initDict .)
    DIF             reduce using rule 52 (assignOptions -> initDict .)
    LTOEQ           reduce using rule 52 (assignOptions -> initDict .)
    GTOEQ           reduce using rule 52 (assignOptions -> initDict .)
    >               reduce using rule 52 (assignOptions -> initDict .)
    <               reduce using rule 52 (assignOptions -> initDict .)
    AND             reduce using rule 52 (assignOptions -> initDict .)
    OR              reduce using rule 52 (assignOptions -> initDict .)
    )               reduce using rule 52 (assignOptions -> initDict .)
    ,               reduce using rule 52 (assignOptions -> initDict .)
    ]               reduce using rule 52 (assignOptions -> initDict .)
    :               reduce using rule 52 (assignOptions -> initDict .)


state 88

    (21) init -> = . i
    (24) initDict -> = . ( j : j )
    (22) i -> . expresion
    (23) i -> . funcCall
    (67) expresion -> . sExp cyExpresion
    (56) funcCall -> . ID ( opParamCall )
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (106) empty -> .

    (               shift and go to state 117
    ID              shift and go to state 118
    CTES            shift and go to state 105
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 119
    funcCall                       shift and go to state 120
    i                              shift and go to state 121
    term                           shift and go to state 106
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 89

    (50) assign -> ID assignOptions .

    ;               reduce using rule 50 (assign -> ID assignOptions .)
    *               reduce using rule 50 (assign -> ID assignOptions .)
    /               reduce using rule 50 (assign -> ID assignOptions .)
    +               reduce using rule 50 (assign -> ID assignOptions .)
    -               reduce using rule 50 (assign -> ID assignOptions .)
    EQ              reduce using rule 50 (assign -> ID assignOptions .)
    DIF             reduce using rule 50 (assign -> ID assignOptions .)
    LTOEQ           reduce using rule 50 (assign -> ID assignOptions .)
    GTOEQ           reduce using rule 50 (assign -> ID assignOptions .)
    >               reduce using rule 50 (assign -> ID assignOptions .)
    <               reduce using rule 50 (assign -> ID assignOptions .)
    AND             reduce using rule 50 (assign -> ID assignOptions .)
    OR              reduce using rule 50 (assign -> ID assignOptions .)
    )               reduce using rule 50 (assign -> ID assignOptions .)
    ,               reduce using rule 50 (assign -> ID assignOptions .)
    ]               reduce using rule 50 (assign -> ID assignOptions .)
    :               reduce using rule 50 (assign -> ID assignOptions .)


state 90

    (51) assignOptions -> init .

    ;               reduce using rule 51 (assignOptions -> init .)
    *               reduce using rule 51 (assignOptions -> init .)
    /               reduce using rule 51 (assignOptions -> init .)
    +               reduce using rule 51 (assignOptions -> init .)
    -               reduce using rule 51 (assignOptions -> init .)
    EQ              reduce using rule 51 (assignOptions -> init .)
    DIF             reduce using rule 51 (assignOptions -> init .)
    LTOEQ           reduce using rule 51 (assignOptions -> init .)
    GTOEQ           reduce using rule 51 (assignOptions -> init .)
    >               reduce using rule 51 (assignOptions -> init .)
    <               reduce using rule 51 (assignOptions -> init .)
    AND             reduce using rule 51 (assignOptions -> init .)
    OR              reduce using rule 51 (assignOptions -> init .)
    )               reduce using rule 51 (assignOptions -> init .)
    ,               reduce using rule 51 (assignOptions -> init .)
    ]               reduce using rule 51 (assignOptions -> init .)
    :               reduce using rule 51 (assignOptions -> init .)


state 91

    (53) assignOptions -> [ . expresion ] assignMatrix init
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 122
    funcCall                       shift and go to state 108
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    term                           shift and go to state 106
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 92

    (63) condition -> IF ( . expresion ) { body } optionalElse
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 123
    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 93

    (13) instr -> c ; .

    IF              reduce using rule 13 (instr -> c ; .)
    ID              reduce using rule 13 (instr -> c ; .)
    FOR             reduce using rule 13 (instr -> c ; .)
    WHILE           reduce using rule 13 (instr -> c ; .)
    }               reduce using rule 13 (instr -> c ; .)


state 94

    (31) function -> FUNC ID opParameters opReturns { a . body }
    (43) body -> . cycleInstruction
    (44) body -> . empty
    (45) cycleInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (63) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 67
    ID              shift and go to state 65
    FOR             shift and go to state 64
    WHILE           shift and go to state 58

    body                           shift and go to state 124
    c                              shift and go to state 68
    funcCall                       shift and go to state 69
    cycleInstruction               shift and go to state 60
    instr                          shift and go to state 56
    forCycle                       shift and go to state 59
    whileCycle                     shift and go to state 57
    condition                      shift and go to state 66
    cycle                          shift and go to state 61
    assign                         shift and go to state 70
    empty                          shift and go to state 62

state 95

    (28) param -> type ID g . k
    (29) k -> . ; param
    (30) k -> . empty
    (106) empty -> .

    ;               shift and go to state 126
    )               reduce using rule 106 (empty -> .)

    k                              shift and go to state 125
    empty                          shift and go to state 127

state 96

    (66) dict -> ( type : type . )

    )               shift and go to state 128


state 97

    (60) struct -> type [ CTED ] . optionalMatrix
    (61) optionalMatrix -> . [ CTED ]
    (62) optionalMatrix -> . empty
    (106) empty -> .

    [               shift and go to state 130
    ;               reduce using rule 106 (empty -> .)

    optionalMatrix                 shift and go to state 129
    empty                          shift and go to state 131

state 98

    (104) cte -> TRUE .

    *               reduce using rule 104 (cte -> TRUE .)
    /               reduce using rule 104 (cte -> TRUE .)
    +               reduce using rule 104 (cte -> TRUE .)
    -               reduce using rule 104 (cte -> TRUE .)
    EQ              reduce using rule 104 (cte -> TRUE .)
    DIF             reduce using rule 104 (cte -> TRUE .)
    LTOEQ           reduce using rule 104 (cte -> TRUE .)
    GTOEQ           reduce using rule 104 (cte -> TRUE .)
    >               reduce using rule 104 (cte -> TRUE .)
    <               reduce using rule 104 (cte -> TRUE .)
    AND             reduce using rule 104 (cte -> TRUE .)
    OR              reduce using rule 104 (cte -> TRUE .)
    ]               reduce using rule 104 (cte -> TRUE .)
    )               reduce using rule 104 (cte -> TRUE .)
    ;               reduce using rule 104 (cte -> TRUE .)
    ,               reduce using rule 104 (cte -> TRUE .)
    :               reduce using rule 104 (cte -> TRUE .)


state 99

    (90) fact -> ( . expresion )
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 132
    term                           shift and go to state 106
    funcCall                       shift and go to state 108
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 100

    (67) expresion -> sExp . cyExpresion
    (68) cyExpresion -> . AND expresion
    (69) cyExpresion -> . OR expresion
    (70) cyExpresion -> . empty
    (106) empty -> .

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    AND             shift and go to state 133
    OR              shift and go to state 135
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

  ! AND             [ reduce using rule 106 (empty -> .) ]
  ! OR              [ reduce using rule 106 (empty -> .) ]

    cyExpresion                    shift and go to state 134
    empty                          shift and go to state 136

state 101

    (92) fact -> empty .

    ;               reduce using rule 92 (fact -> empty .)
    *               reduce using rule 92 (fact -> empty .)
    /               reduce using rule 92 (fact -> empty .)
    +               reduce using rule 92 (fact -> empty .)
    -               reduce using rule 92 (fact -> empty .)
    EQ              reduce using rule 92 (fact -> empty .)
    DIF             reduce using rule 92 (fact -> empty .)
    LTOEQ           reduce using rule 92 (fact -> empty .)
    GTOEQ           reduce using rule 92 (fact -> empty .)
    >               reduce using rule 92 (fact -> empty .)
    <               reduce using rule 92 (fact -> empty .)
    AND             reduce using rule 92 (fact -> empty .)
    OR              reduce using rule 92 (fact -> empty .)
    )               reduce using rule 92 (fact -> empty .)
    ,               reduce using rule 92 (fact -> empty .)
    ]               reduce using rule 92 (fact -> empty .)
    :               reduce using rule 92 (fact -> empty .)


state 102

    (71) sExp -> exp . cySExp
    (72) cySExp -> . EQ sExp
    (73) cySExp -> . DIF sExp
    (74) cySExp -> . LTOEQ sExp
    (75) cySExp -> . GTOEQ sExp
    (76) cySExp -> . > sExp
    (77) cySExp -> . < sExp
    (78) cySExp -> . empty
    (106) empty -> .

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for DIF resolved as shift
  ! shift/reduce conflict for LTOEQ resolved as shift
  ! shift/reduce conflict for GTOEQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
    EQ              shift and go to state 138
    DIF             shift and go to state 139
    LTOEQ           shift and go to state 141
    GTOEQ           shift and go to state 140
    >               shift and go to state 144
    <               shift and go to state 142
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

  ! EQ              [ reduce using rule 106 (empty -> .) ]
  ! DIF             [ reduce using rule 106 (empty -> .) ]
  ! LTOEQ           [ reduce using rule 106 (empty -> .) ]
  ! GTOEQ           [ reduce using rule 106 (empty -> .) ]
  ! >               [ reduce using rule 106 (empty -> .) ]
  ! <               [ reduce using rule 106 (empty -> .) ]

    cySExp                         shift and go to state 137
    empty                          shift and go to state 143

state 103

    (91) fact -> ID . opAccess
    (56) funcCall -> ID . ( opParamCall )
    (93) opAccess -> . opStruct
    (94) opAccess -> . opDictionary
    (95) opAccess -> . empty
    (96) opStruct -> . [ expresion ] opMatrix
    (99) opDictionary -> . . dictIndex
    (106) empty -> .

    (               shift and go to state 86
    [               shift and go to state 148
    .               shift and go to state 149
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    ;               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    opDictionary                   shift and go to state 150
    opStruct                       shift and go to state 145
    opAccess                       shift and go to state 146
    empty                          shift and go to state 147

state 104

    (48) whileCycle -> WHILE ( expresion . ) { body }

    )               shift and go to state 151


state 105

    (87) fact -> CTES .

    ;               reduce using rule 87 (fact -> CTES .)
    *               reduce using rule 87 (fact -> CTES .)
    /               reduce using rule 87 (fact -> CTES .)
    +               reduce using rule 87 (fact -> CTES .)
    -               reduce using rule 87 (fact -> CTES .)
    EQ              reduce using rule 87 (fact -> CTES .)
    DIF             reduce using rule 87 (fact -> CTES .)
    LTOEQ           reduce using rule 87 (fact -> CTES .)
    GTOEQ           reduce using rule 87 (fact -> CTES .)
    >               reduce using rule 87 (fact -> CTES .)
    <               reduce using rule 87 (fact -> CTES .)
    AND             reduce using rule 87 (fact -> CTES .)
    OR              reduce using rule 87 (fact -> CTES .)
    )               reduce using rule 87 (fact -> CTES .)
    ,               reduce using rule 87 (fact -> CTES .)
    ]               reduce using rule 87 (fact -> CTES .)
    :               reduce using rule 87 (fact -> CTES .)


state 106

    (79) exp -> term . cyExp
    (80) cyExp -> . + term
    (81) cyExp -> . - term
    (82) cyExp -> . empty
    (106) empty -> .

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    +               shift and go to state 154
    -               shift and go to state 153
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

  ! +               [ reduce using rule 106 (empty -> .) ]
  ! -               [ reduce using rule 106 (empty -> .) ]

    cyExp                          shift and go to state 152
    empty                          shift and go to state 155

state 107

    (105) cte -> FALSE . c
    (16) c -> . assign
    (17) c -> . funcCall
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )

    ID              shift and go to state 65

    c                              shift and go to state 156
    assign                         shift and go to state 70
    funcCall                       shift and go to state 69

state 108

    (89) fact -> funcCall .

    ;               reduce using rule 89 (fact -> funcCall .)
    *               reduce using rule 89 (fact -> funcCall .)
    /               reduce using rule 89 (fact -> funcCall .)
    +               reduce using rule 89 (fact -> funcCall .)
    -               reduce using rule 89 (fact -> funcCall .)
    EQ              reduce using rule 89 (fact -> funcCall .)
    DIF             reduce using rule 89 (fact -> funcCall .)
    LTOEQ           reduce using rule 89 (fact -> funcCall .)
    GTOEQ           reduce using rule 89 (fact -> funcCall .)
    >               reduce using rule 89 (fact -> funcCall .)
    <               reduce using rule 89 (fact -> funcCall .)
    AND             reduce using rule 89 (fact -> funcCall .)
    OR              reduce using rule 89 (fact -> funcCall .)
    )               reduce using rule 89 (fact -> funcCall .)
    ,               reduce using rule 89 (fact -> funcCall .)
    ]               reduce using rule 89 (fact -> funcCall .)
    :               reduce using rule 89 (fact -> funcCall .)


state 109

    (88) fact -> cte .

    ;               reduce using rule 88 (fact -> cte .)
    *               reduce using rule 88 (fact -> cte .)
    /               reduce using rule 88 (fact -> cte .)
    +               reduce using rule 88 (fact -> cte .)
    -               reduce using rule 88 (fact -> cte .)
    EQ              reduce using rule 88 (fact -> cte .)
    DIF             reduce using rule 88 (fact -> cte .)
    LTOEQ           reduce using rule 88 (fact -> cte .)
    GTOEQ           reduce using rule 88 (fact -> cte .)
    >               reduce using rule 88 (fact -> cte .)
    <               reduce using rule 88 (fact -> cte .)
    AND             reduce using rule 88 (fact -> cte .)
    OR              reduce using rule 88 (fact -> cte .)
    )               reduce using rule 88 (fact -> cte .)
    ,               reduce using rule 88 (fact -> cte .)
    ]               reduce using rule 88 (fact -> cte .)
    :               reduce using rule 88 (fact -> cte .)


state 110

    (103) cte -> CTEF .

    *               reduce using rule 103 (cte -> CTEF .)
    /               reduce using rule 103 (cte -> CTEF .)
    +               reduce using rule 103 (cte -> CTEF .)
    -               reduce using rule 103 (cte -> CTEF .)
    EQ              reduce using rule 103 (cte -> CTEF .)
    DIF             reduce using rule 103 (cte -> CTEF .)
    LTOEQ           reduce using rule 103 (cte -> CTEF .)
    GTOEQ           reduce using rule 103 (cte -> CTEF .)
    >               reduce using rule 103 (cte -> CTEF .)
    <               reduce using rule 103 (cte -> CTEF .)
    AND             reduce using rule 103 (cte -> CTEF .)
    OR              reduce using rule 103 (cte -> CTEF .)
    ]               reduce using rule 103 (cte -> CTEF .)
    )               reduce using rule 103 (cte -> CTEF .)
    ;               reduce using rule 103 (cte -> CTEF .)
    ,               reduce using rule 103 (cte -> CTEF .)
    :               reduce using rule 103 (cte -> CTEF .)


state 111

    (102) cte -> CTED .

    *               reduce using rule 102 (cte -> CTED .)
    /               reduce using rule 102 (cte -> CTED .)
    +               reduce using rule 102 (cte -> CTED .)
    -               reduce using rule 102 (cte -> CTED .)
    EQ              reduce using rule 102 (cte -> CTED .)
    DIF             reduce using rule 102 (cte -> CTED .)
    LTOEQ           reduce using rule 102 (cte -> CTED .)
    GTOEQ           reduce using rule 102 (cte -> CTED .)
    >               reduce using rule 102 (cte -> CTED .)
    <               reduce using rule 102 (cte -> CTED .)
    AND             reduce using rule 102 (cte -> CTED .)
    OR              reduce using rule 102 (cte -> CTED .)
    ]               reduce using rule 102 (cte -> CTED .)
    )               reduce using rule 102 (cte -> CTED .)
    ;               reduce using rule 102 (cte -> CTED .)
    ,               reduce using rule 102 (cte -> CTED .)
    :               reduce using rule 102 (cte -> CTED .)


state 112

    (83) term -> fact . cyTerm
    (84) cyTerm -> . * fact
    (85) cyTerm -> . / fact
    (86) cyTerm -> . empty
    (106) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 159
    /               shift and go to state 160
    ;               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

  ! *               [ reduce using rule 106 (empty -> .) ]
  ! /               [ reduce using rule 106 (empty -> .) ]

    cyTerm                         shift and go to state 157
    empty                          shift and go to state 158

state 113

    (50) assign -> ID . assignOptions
    (51) assignOptions -> . init
    (52) assignOptions -> . initDict
    (53) assignOptions -> . [ expresion ] assignMatrix init
    (21) init -> . = i
    (24) initDict -> . = ( j : j )

    [               shift and go to state 91
    =               shift and go to state 88

    initDict                       shift and go to state 87
    assignOptions                  shift and go to state 89
    init                           shift and go to state 90

state 114

    (49) forCycle -> FOR ( assign . ; expresion ; assign ) { body }

    ;               shift and go to state 161


state 115

    (56) funcCall -> ID ( opParamCall . )

    )               shift and go to state 162


state 116

    (57) opParamCall -> expresion . cyParamCall
    (58) cyParamCall -> . , opParamCall
    (59) cyParamCall -> . empty
    (106) empty -> .

    ,               shift and go to state 164
    )               reduce using rule 106 (empty -> .)

    cyParamCall                    shift and go to state 163
    empty                          shift and go to state 165

state 117

    (24) initDict -> = ( . j : j )
    (90) fact -> ( . expresion )
    (25) j -> . CTES
    (26) j -> . cte
    (27) j -> . ID
    (67) expresion -> . sExp cyExpresion
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 167
    ID              shift and go to state 166
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    (               shift and go to state 99
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 132
    funcCall                       shift and go to state 108
    j                              shift and go to state 168
    sExp                           shift and go to state 100
    cte                            shift and go to state 169
    empty                          shift and go to state 101
    term                           shift and go to state 106
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 118

    (56) funcCall -> ID . ( opParamCall )
    (91) fact -> ID . opAccess
    (93) opAccess -> . opStruct
    (94) opAccess -> . opDictionary
    (95) opAccess -> . empty
    (96) opStruct -> . [ expresion ] opMatrix
    (99) opDictionary -> . . dictIndex
    (106) empty -> .

    (               shift and go to state 86
    [               shift and go to state 148
    .               shift and go to state 149
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    opDictionary                   shift and go to state 150
    opStruct                       shift and go to state 145
    opAccess                       shift and go to state 146
    empty                          shift and go to state 147

state 119

    (22) i -> expresion .

    ;               reduce using rule 22 (i -> expresion .)
    *               reduce using rule 22 (i -> expresion .)
    /               reduce using rule 22 (i -> expresion .)
    +               reduce using rule 22 (i -> expresion .)
    -               reduce using rule 22 (i -> expresion .)
    EQ              reduce using rule 22 (i -> expresion .)
    DIF             reduce using rule 22 (i -> expresion .)
    LTOEQ           reduce using rule 22 (i -> expresion .)
    GTOEQ           reduce using rule 22 (i -> expresion .)
    >               reduce using rule 22 (i -> expresion .)
    <               reduce using rule 22 (i -> expresion .)
    AND             reduce using rule 22 (i -> expresion .)
    OR              reduce using rule 22 (i -> expresion .)
    )               reduce using rule 22 (i -> expresion .)
    ,               reduce using rule 22 (i -> expresion .)
    ]               reduce using rule 22 (i -> expresion .)
    :               reduce using rule 22 (i -> expresion .)


state 120

    (23) i -> funcCall .
    (89) fact -> funcCall .

  ! reduce/reduce conflict for ; resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for * resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for / resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for + resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for - resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for EQ resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for DIF resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for LTOEQ resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for GTOEQ resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for > resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for < resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for AND resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for OR resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for ) resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for , resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for ] resolved using rule 23 (i -> funcCall .)
  ! reduce/reduce conflict for : resolved using rule 23 (i -> funcCall .)
    ;               reduce using rule 23 (i -> funcCall .)
    *               reduce using rule 23 (i -> funcCall .)
    /               reduce using rule 23 (i -> funcCall .)
    +               reduce using rule 23 (i -> funcCall .)
    -               reduce using rule 23 (i -> funcCall .)
    EQ              reduce using rule 23 (i -> funcCall .)
    DIF             reduce using rule 23 (i -> funcCall .)
    LTOEQ           reduce using rule 23 (i -> funcCall .)
    GTOEQ           reduce using rule 23 (i -> funcCall .)
    >               reduce using rule 23 (i -> funcCall .)
    <               reduce using rule 23 (i -> funcCall .)
    AND             reduce using rule 23 (i -> funcCall .)
    OR              reduce using rule 23 (i -> funcCall .)
    )               reduce using rule 23 (i -> funcCall .)
    ,               reduce using rule 23 (i -> funcCall .)
    ]               reduce using rule 23 (i -> funcCall .)
    :               reduce using rule 23 (i -> funcCall .)

  ! ;               [ reduce using rule 89 (fact -> funcCall .) ]
  ! *               [ reduce using rule 89 (fact -> funcCall .) ]
  ! /               [ reduce using rule 89 (fact -> funcCall .) ]
  ! +               [ reduce using rule 89 (fact -> funcCall .) ]
  ! -               [ reduce using rule 89 (fact -> funcCall .) ]
  ! EQ              [ reduce using rule 89 (fact -> funcCall .) ]
  ! DIF             [ reduce using rule 89 (fact -> funcCall .) ]
  ! LTOEQ           [ reduce using rule 89 (fact -> funcCall .) ]
  ! GTOEQ           [ reduce using rule 89 (fact -> funcCall .) ]
  ! >               [ reduce using rule 89 (fact -> funcCall .) ]
  ! <               [ reduce using rule 89 (fact -> funcCall .) ]
  ! AND             [ reduce using rule 89 (fact -> funcCall .) ]
  ! OR              [ reduce using rule 89 (fact -> funcCall .) ]
  ! )               [ reduce using rule 89 (fact -> funcCall .) ]
  ! ,               [ reduce using rule 89 (fact -> funcCall .) ]
  ! ]               [ reduce using rule 89 (fact -> funcCall .) ]
  ! :               [ reduce using rule 89 (fact -> funcCall .) ]


state 121

    (21) init -> = i .

    ;               reduce using rule 21 (init -> = i .)
    *               reduce using rule 21 (init -> = i .)
    /               reduce using rule 21 (init -> = i .)
    +               reduce using rule 21 (init -> = i .)
    -               reduce using rule 21 (init -> = i .)
    EQ              reduce using rule 21 (init -> = i .)
    DIF             reduce using rule 21 (init -> = i .)
    LTOEQ           reduce using rule 21 (init -> = i .)
    GTOEQ           reduce using rule 21 (init -> = i .)
    >               reduce using rule 21 (init -> = i .)
    <               reduce using rule 21 (init -> = i .)
    AND             reduce using rule 21 (init -> = i .)
    OR              reduce using rule 21 (init -> = i .)
    )               reduce using rule 21 (init -> = i .)
    ,               reduce using rule 21 (init -> = i .)
    ]               reduce using rule 21 (init -> = i .)
    :               reduce using rule 21 (init -> = i .)


state 122

    (53) assignOptions -> [ expresion . ] assignMatrix init

    ]               shift and go to state 170


state 123

    (63) condition -> IF ( expresion . ) { body } optionalElse

    )               shift and go to state 171


state 124

    (31) function -> FUNC ID opParameters opReturns { a body . }

    }               shift and go to state 172


state 125

    (28) param -> type ID g k .

    )               reduce using rule 28 (param -> type ID g k .)


state 126

    (29) k -> ; . param
    (28) param -> . type ID g k
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    OBJECT          shift and go to state 13
    BOOL            shift and go to state 21

    type                           shift and go to state 49
    param                          shift and go to state 173

state 127

    (30) k -> empty .

    )               reduce using rule 30 (k -> empty .)


state 128

    (66) dict -> ( type : type ) .

    ;               reduce using rule 66 (dict -> ( type : type ) .)


state 129

    (60) struct -> type [ CTED ] optionalMatrix .

    ;               reduce using rule 60 (struct -> type [ CTED ] optionalMatrix .)


state 130

    (61) optionalMatrix -> [ . CTED ]

    CTED            shift and go to state 174


state 131

    (62) optionalMatrix -> empty .

    ;               reduce using rule 62 (optionalMatrix -> empty .)


state 132

    (90) fact -> ( expresion . )

    )               shift and go to state 175


state 133

    (68) cyExpresion -> AND . expresion
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 176
    term                           shift and go to state 106
    funcCall                       shift and go to state 108
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 134

    (67) expresion -> sExp cyExpresion .

    ;               reduce using rule 67 (expresion -> sExp cyExpresion .)
    *               reduce using rule 67 (expresion -> sExp cyExpresion .)
    /               reduce using rule 67 (expresion -> sExp cyExpresion .)
    +               reduce using rule 67 (expresion -> sExp cyExpresion .)
    -               reduce using rule 67 (expresion -> sExp cyExpresion .)
    EQ              reduce using rule 67 (expresion -> sExp cyExpresion .)
    DIF             reduce using rule 67 (expresion -> sExp cyExpresion .)
    LTOEQ           reduce using rule 67 (expresion -> sExp cyExpresion .)
    GTOEQ           reduce using rule 67 (expresion -> sExp cyExpresion .)
    >               reduce using rule 67 (expresion -> sExp cyExpresion .)
    <               reduce using rule 67 (expresion -> sExp cyExpresion .)
    AND             reduce using rule 67 (expresion -> sExp cyExpresion .)
    OR              reduce using rule 67 (expresion -> sExp cyExpresion .)
    )               reduce using rule 67 (expresion -> sExp cyExpresion .)
    ,               reduce using rule 67 (expresion -> sExp cyExpresion .)
    ]               reduce using rule 67 (expresion -> sExp cyExpresion .)
    :               reduce using rule 67 (expresion -> sExp cyExpresion .)


state 135

    (69) cyExpresion -> OR . expresion
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 177
    term                           shift and go to state 106
    funcCall                       shift and go to state 108
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 136

    (70) cyExpresion -> empty .

    ;               reduce using rule 70 (cyExpresion -> empty .)
    *               reduce using rule 70 (cyExpresion -> empty .)
    /               reduce using rule 70 (cyExpresion -> empty .)
    +               reduce using rule 70 (cyExpresion -> empty .)
    -               reduce using rule 70 (cyExpresion -> empty .)
    EQ              reduce using rule 70 (cyExpresion -> empty .)
    DIF             reduce using rule 70 (cyExpresion -> empty .)
    LTOEQ           reduce using rule 70 (cyExpresion -> empty .)
    GTOEQ           reduce using rule 70 (cyExpresion -> empty .)
    >               reduce using rule 70 (cyExpresion -> empty .)
    <               reduce using rule 70 (cyExpresion -> empty .)
    AND             reduce using rule 70 (cyExpresion -> empty .)
    OR              reduce using rule 70 (cyExpresion -> empty .)
    )               reduce using rule 70 (cyExpresion -> empty .)
    ,               reduce using rule 70 (cyExpresion -> empty .)
    ]               reduce using rule 70 (cyExpresion -> empty .)
    :               reduce using rule 70 (cyExpresion -> empty .)


state 137

    (71) sExp -> exp cySExp .

    ;               reduce using rule 71 (sExp -> exp cySExp .)
    *               reduce using rule 71 (sExp -> exp cySExp .)
    /               reduce using rule 71 (sExp -> exp cySExp .)
    +               reduce using rule 71 (sExp -> exp cySExp .)
    -               reduce using rule 71 (sExp -> exp cySExp .)
    EQ              reduce using rule 71 (sExp -> exp cySExp .)
    DIF             reduce using rule 71 (sExp -> exp cySExp .)
    LTOEQ           reduce using rule 71 (sExp -> exp cySExp .)
    GTOEQ           reduce using rule 71 (sExp -> exp cySExp .)
    >               reduce using rule 71 (sExp -> exp cySExp .)
    <               reduce using rule 71 (sExp -> exp cySExp .)
    AND             reduce using rule 71 (sExp -> exp cySExp .)
    OR              reduce using rule 71 (sExp -> exp cySExp .)
    )               reduce using rule 71 (sExp -> exp cySExp .)
    ,               reduce using rule 71 (sExp -> exp cySExp .)
    ]               reduce using rule 71 (sExp -> exp cySExp .)
    :               reduce using rule 71 (sExp -> exp cySExp .)


state 138

    (72) cySExp -> EQ . sExp
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 178
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 139

    (73) cySExp -> DIF . sExp
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 179
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 140

    (75) cySExp -> GTOEQ . sExp
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 180
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 141

    (74) cySExp -> LTOEQ . sExp
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 181
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 142

    (77) cySExp -> < . sExp
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 182
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 143

    (78) cySExp -> empty .

    ;               reduce using rule 78 (cySExp -> empty .)
    *               reduce using rule 78 (cySExp -> empty .)
    /               reduce using rule 78 (cySExp -> empty .)
    +               reduce using rule 78 (cySExp -> empty .)
    -               reduce using rule 78 (cySExp -> empty .)
    EQ              reduce using rule 78 (cySExp -> empty .)
    DIF             reduce using rule 78 (cySExp -> empty .)
    LTOEQ           reduce using rule 78 (cySExp -> empty .)
    GTOEQ           reduce using rule 78 (cySExp -> empty .)
    >               reduce using rule 78 (cySExp -> empty .)
    <               reduce using rule 78 (cySExp -> empty .)
    AND             reduce using rule 78 (cySExp -> empty .)
    OR              reduce using rule 78 (cySExp -> empty .)
    )               reduce using rule 78 (cySExp -> empty .)
    ,               reduce using rule 78 (cySExp -> empty .)
    ]               reduce using rule 78 (cySExp -> empty .)
    :               reduce using rule 78 (cySExp -> empty .)


state 144

    (76) cySExp -> > . sExp
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 183
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 145

    (93) opAccess -> opStruct .

    *               reduce using rule 93 (opAccess -> opStruct .)
    /               reduce using rule 93 (opAccess -> opStruct .)
    +               reduce using rule 93 (opAccess -> opStruct .)
    -               reduce using rule 93 (opAccess -> opStruct .)
    EQ              reduce using rule 93 (opAccess -> opStruct .)
    DIF             reduce using rule 93 (opAccess -> opStruct .)
    LTOEQ           reduce using rule 93 (opAccess -> opStruct .)
    GTOEQ           reduce using rule 93 (opAccess -> opStruct .)
    >               reduce using rule 93 (opAccess -> opStruct .)
    <               reduce using rule 93 (opAccess -> opStruct .)
    AND             reduce using rule 93 (opAccess -> opStruct .)
    OR              reduce using rule 93 (opAccess -> opStruct .)
    )               reduce using rule 93 (opAccess -> opStruct .)
    ,               reduce using rule 93 (opAccess -> opStruct .)
    ]               reduce using rule 93 (opAccess -> opStruct .)
    ;               reduce using rule 93 (opAccess -> opStruct .)
    :               reduce using rule 93 (opAccess -> opStruct .)


state 146

    (91) fact -> ID opAccess .

    ;               reduce using rule 91 (fact -> ID opAccess .)
    *               reduce using rule 91 (fact -> ID opAccess .)
    /               reduce using rule 91 (fact -> ID opAccess .)
    +               reduce using rule 91 (fact -> ID opAccess .)
    -               reduce using rule 91 (fact -> ID opAccess .)
    EQ              reduce using rule 91 (fact -> ID opAccess .)
    DIF             reduce using rule 91 (fact -> ID opAccess .)
    LTOEQ           reduce using rule 91 (fact -> ID opAccess .)
    GTOEQ           reduce using rule 91 (fact -> ID opAccess .)
    >               reduce using rule 91 (fact -> ID opAccess .)
    <               reduce using rule 91 (fact -> ID opAccess .)
    AND             reduce using rule 91 (fact -> ID opAccess .)
    OR              reduce using rule 91 (fact -> ID opAccess .)
    )               reduce using rule 91 (fact -> ID opAccess .)
    ,               reduce using rule 91 (fact -> ID opAccess .)
    ]               reduce using rule 91 (fact -> ID opAccess .)
    :               reduce using rule 91 (fact -> ID opAccess .)


state 147

    (95) opAccess -> empty .

    *               reduce using rule 95 (opAccess -> empty .)
    /               reduce using rule 95 (opAccess -> empty .)
    +               reduce using rule 95 (opAccess -> empty .)
    -               reduce using rule 95 (opAccess -> empty .)
    EQ              reduce using rule 95 (opAccess -> empty .)
    DIF             reduce using rule 95 (opAccess -> empty .)
    LTOEQ           reduce using rule 95 (opAccess -> empty .)
    GTOEQ           reduce using rule 95 (opAccess -> empty .)
    >               reduce using rule 95 (opAccess -> empty .)
    <               reduce using rule 95 (opAccess -> empty .)
    AND             reduce using rule 95 (opAccess -> empty .)
    OR              reduce using rule 95 (opAccess -> empty .)
    )               reduce using rule 95 (opAccess -> empty .)
    ,               reduce using rule 95 (opAccess -> empty .)
    ]               reduce using rule 95 (opAccess -> empty .)
    ;               reduce using rule 95 (opAccess -> empty .)
    :               reduce using rule 95 (opAccess -> empty .)


state 148

    (96) opStruct -> [ . expresion ] opMatrix
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 184
    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 149

    (99) opDictionary -> . . dictIndex
    (100) dictIndex -> . FIRST
    (101) dictIndex -> . LAST

    FIRST           shift and go to state 185
    LAST            shift and go to state 186

    dictIndex                      shift and go to state 187

state 150

    (94) opAccess -> opDictionary .

    *               reduce using rule 94 (opAccess -> opDictionary .)
    /               reduce using rule 94 (opAccess -> opDictionary .)
    +               reduce using rule 94 (opAccess -> opDictionary .)
    -               reduce using rule 94 (opAccess -> opDictionary .)
    EQ              reduce using rule 94 (opAccess -> opDictionary .)
    DIF             reduce using rule 94 (opAccess -> opDictionary .)
    LTOEQ           reduce using rule 94 (opAccess -> opDictionary .)
    GTOEQ           reduce using rule 94 (opAccess -> opDictionary .)
    >               reduce using rule 94 (opAccess -> opDictionary .)
    <               reduce using rule 94 (opAccess -> opDictionary .)
    AND             reduce using rule 94 (opAccess -> opDictionary .)
    OR              reduce using rule 94 (opAccess -> opDictionary .)
    )               reduce using rule 94 (opAccess -> opDictionary .)
    ,               reduce using rule 94 (opAccess -> opDictionary .)
    ]               reduce using rule 94 (opAccess -> opDictionary .)
    ;               reduce using rule 94 (opAccess -> opDictionary .)
    :               reduce using rule 94 (opAccess -> opDictionary .)


state 151

    (48) whileCycle -> WHILE ( expresion ) . { body }

    {               shift and go to state 188


state 152

    (79) exp -> term cyExp .

    ;               reduce using rule 79 (exp -> term cyExp .)
    *               reduce using rule 79 (exp -> term cyExp .)
    /               reduce using rule 79 (exp -> term cyExp .)
    +               reduce using rule 79 (exp -> term cyExp .)
    -               reduce using rule 79 (exp -> term cyExp .)
    EQ              reduce using rule 79 (exp -> term cyExp .)
    DIF             reduce using rule 79 (exp -> term cyExp .)
    LTOEQ           reduce using rule 79 (exp -> term cyExp .)
    GTOEQ           reduce using rule 79 (exp -> term cyExp .)
    >               reduce using rule 79 (exp -> term cyExp .)
    <               reduce using rule 79 (exp -> term cyExp .)
    AND             reduce using rule 79 (exp -> term cyExp .)
    OR              reduce using rule 79 (exp -> term cyExp .)
    )               reduce using rule 79 (exp -> term cyExp .)
    ,               reduce using rule 79 (exp -> term cyExp .)
    ]               reduce using rule 79 (exp -> term cyExp .)
    :               reduce using rule 79 (exp -> term cyExp .)


state 153

    (81) cyExp -> - . term
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    term                           shift and go to state 189
    funcCall                       shift and go to state 108
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    fact                           shift and go to state 112

state 154

    (80) cyExp -> + . term
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    term                           shift and go to state 190
    funcCall                       shift and go to state 108
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    fact                           shift and go to state 112

state 155

    (82) cyExp -> empty .

    ;               reduce using rule 82 (cyExp -> empty .)
    *               reduce using rule 82 (cyExp -> empty .)
    /               reduce using rule 82 (cyExp -> empty .)
    +               reduce using rule 82 (cyExp -> empty .)
    -               reduce using rule 82 (cyExp -> empty .)
    EQ              reduce using rule 82 (cyExp -> empty .)
    DIF             reduce using rule 82 (cyExp -> empty .)
    LTOEQ           reduce using rule 82 (cyExp -> empty .)
    GTOEQ           reduce using rule 82 (cyExp -> empty .)
    >               reduce using rule 82 (cyExp -> empty .)
    <               reduce using rule 82 (cyExp -> empty .)
    AND             reduce using rule 82 (cyExp -> empty .)
    OR              reduce using rule 82 (cyExp -> empty .)
    )               reduce using rule 82 (cyExp -> empty .)
    ,               reduce using rule 82 (cyExp -> empty .)
    ]               reduce using rule 82 (cyExp -> empty .)
    :               reduce using rule 82 (cyExp -> empty .)


state 156

    (105) cte -> FALSE c .

    *               reduce using rule 105 (cte -> FALSE c .)
    /               reduce using rule 105 (cte -> FALSE c .)
    +               reduce using rule 105 (cte -> FALSE c .)
    -               reduce using rule 105 (cte -> FALSE c .)
    EQ              reduce using rule 105 (cte -> FALSE c .)
    DIF             reduce using rule 105 (cte -> FALSE c .)
    LTOEQ           reduce using rule 105 (cte -> FALSE c .)
    GTOEQ           reduce using rule 105 (cte -> FALSE c .)
    >               reduce using rule 105 (cte -> FALSE c .)
    <               reduce using rule 105 (cte -> FALSE c .)
    AND             reduce using rule 105 (cte -> FALSE c .)
    OR              reduce using rule 105 (cte -> FALSE c .)
    ]               reduce using rule 105 (cte -> FALSE c .)
    )               reduce using rule 105 (cte -> FALSE c .)
    ;               reduce using rule 105 (cte -> FALSE c .)
    ,               reduce using rule 105 (cte -> FALSE c .)
    :               reduce using rule 105 (cte -> FALSE c .)


state 157

    (83) term -> fact cyTerm .

    ;               reduce using rule 83 (term -> fact cyTerm .)
    *               reduce using rule 83 (term -> fact cyTerm .)
    /               reduce using rule 83 (term -> fact cyTerm .)
    +               reduce using rule 83 (term -> fact cyTerm .)
    -               reduce using rule 83 (term -> fact cyTerm .)
    EQ              reduce using rule 83 (term -> fact cyTerm .)
    DIF             reduce using rule 83 (term -> fact cyTerm .)
    LTOEQ           reduce using rule 83 (term -> fact cyTerm .)
    GTOEQ           reduce using rule 83 (term -> fact cyTerm .)
    >               reduce using rule 83 (term -> fact cyTerm .)
    <               reduce using rule 83 (term -> fact cyTerm .)
    AND             reduce using rule 83 (term -> fact cyTerm .)
    OR              reduce using rule 83 (term -> fact cyTerm .)
    )               reduce using rule 83 (term -> fact cyTerm .)
    ,               reduce using rule 83 (term -> fact cyTerm .)
    ]               reduce using rule 83 (term -> fact cyTerm .)
    :               reduce using rule 83 (term -> fact cyTerm .)


state 158

    (86) cyTerm -> empty .

    ;               reduce using rule 86 (cyTerm -> empty .)
    *               reduce using rule 86 (cyTerm -> empty .)
    /               reduce using rule 86 (cyTerm -> empty .)
    +               reduce using rule 86 (cyTerm -> empty .)
    -               reduce using rule 86 (cyTerm -> empty .)
    EQ              reduce using rule 86 (cyTerm -> empty .)
    DIF             reduce using rule 86 (cyTerm -> empty .)
    LTOEQ           reduce using rule 86 (cyTerm -> empty .)
    GTOEQ           reduce using rule 86 (cyTerm -> empty .)
    >               reduce using rule 86 (cyTerm -> empty .)
    <               reduce using rule 86 (cyTerm -> empty .)
    AND             reduce using rule 86 (cyTerm -> empty .)
    OR              reduce using rule 86 (cyTerm -> empty .)
    )               reduce using rule 86 (cyTerm -> empty .)
    ,               reduce using rule 86 (cyTerm -> empty .)
    ]               reduce using rule 86 (cyTerm -> empty .)
    :               reduce using rule 86 (cyTerm -> empty .)


state 159

    (84) cyTerm -> * . fact
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    funcCall                       shift and go to state 108
    cte                            shift and go to state 109
    fact                           shift and go to state 191
    empty                          shift and go to state 101

state 160

    (85) cyTerm -> / . fact
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    funcCall                       shift and go to state 108
    cte                            shift and go to state 109
    fact                           shift and go to state 192
    empty                          shift and go to state 101

state 161

    (49) forCycle -> FOR ( assign ; . expresion ; assign ) { body }
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    ;               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 193
    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 162

    (56) funcCall -> ID ( opParamCall ) .

    *               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    /               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    +               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    -               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    EQ              reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    DIF             reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    LTOEQ           reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    GTOEQ           reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    >               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    <               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    AND             reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    OR              reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    )               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    ]               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    ;               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    ,               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)
    :               reduce using rule 56 (funcCall -> ID ( opParamCall ) .)


state 163

    (57) opParamCall -> expresion cyParamCall .

    )               reduce using rule 57 (opParamCall -> expresion cyParamCall .)


state 164

    (58) cyParamCall -> , . opParamCall
    (57) opParamCall -> . expresion cyParamCall
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 116
    funcCall                       shift and go to state 108
    term                           shift and go to state 106
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    opParamCall                    shift and go to state 194
    fact                           shift and go to state 112

state 165

    (59) cyParamCall -> empty .

    )               reduce using rule 59 (cyParamCall -> empty .)


state 166

    (27) j -> ID .
    (91) fact -> ID . opAccess
    (56) funcCall -> ID . ( opParamCall )
    (93) opAccess -> . opStruct
    (94) opAccess -> . opDictionary
    (95) opAccess -> . empty
    (96) opStruct -> . [ expresion ] opMatrix
    (99) opDictionary -> . . dictIndex
    (106) empty -> .

    :               reduce using rule 27 (j -> ID .)
    (               shift and go to state 86
    [               shift and go to state 148
    .               shift and go to state 149
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)

    opDictionary                   shift and go to state 150
    opStruct                       shift and go to state 145
    opAccess                       shift and go to state 146
    empty                          shift and go to state 147

state 167

    (25) j -> CTES .
    (87) fact -> CTES .

    :               reduce using rule 25 (j -> CTES .)
    *               reduce using rule 87 (fact -> CTES .)
    /               reduce using rule 87 (fact -> CTES .)
    +               reduce using rule 87 (fact -> CTES .)
    -               reduce using rule 87 (fact -> CTES .)
    EQ              reduce using rule 87 (fact -> CTES .)
    DIF             reduce using rule 87 (fact -> CTES .)
    LTOEQ           reduce using rule 87 (fact -> CTES .)
    GTOEQ           reduce using rule 87 (fact -> CTES .)
    >               reduce using rule 87 (fact -> CTES .)
    <               reduce using rule 87 (fact -> CTES .)
    AND             reduce using rule 87 (fact -> CTES .)
    OR              reduce using rule 87 (fact -> CTES .)
    )               reduce using rule 87 (fact -> CTES .)


state 168

    (24) initDict -> = ( j . : j )

    :               shift and go to state 195


state 169

    (26) j -> cte .
    (88) fact -> cte .

    :               reduce using rule 26 (j -> cte .)
    *               reduce using rule 88 (fact -> cte .)
    /               reduce using rule 88 (fact -> cte .)
    +               reduce using rule 88 (fact -> cte .)
    -               reduce using rule 88 (fact -> cte .)
    EQ              reduce using rule 88 (fact -> cte .)
    DIF             reduce using rule 88 (fact -> cte .)
    LTOEQ           reduce using rule 88 (fact -> cte .)
    GTOEQ           reduce using rule 88 (fact -> cte .)
    >               reduce using rule 88 (fact -> cte .)
    <               reduce using rule 88 (fact -> cte .)
    AND             reduce using rule 88 (fact -> cte .)
    OR              reduce using rule 88 (fact -> cte .)
    )               reduce using rule 88 (fact -> cte .)


state 170

    (53) assignOptions -> [ expresion ] . assignMatrix init
    (54) assignMatrix -> . [ expresion ]
    (55) assignMatrix -> . empty
    (106) empty -> .

    [               shift and go to state 197
    =               reduce using rule 106 (empty -> .)

    assignMatrix                   shift and go to state 196
    empty                          shift and go to state 198

state 171

    (63) condition -> IF ( expresion ) . { body } optionalElse

    {               shift and go to state 199


state 172

    (31) function -> FUNC ID opParameters opReturns { a body } .

    FUNC            reduce using rule 31 (function -> FUNC ID opParameters opReturns { a body } .)
    MAIN            reduce using rule 31 (function -> FUNC ID opParameters opReturns { a body } .)


state 173

    (29) k -> ; param .

    )               reduce using rule 29 (k -> ; param .)


state 174

    (61) optionalMatrix -> [ CTED . ]

    ]               shift and go to state 200


state 175

    (90) fact -> ( expresion ) .

    ;               reduce using rule 90 (fact -> ( expresion ) .)
    *               reduce using rule 90 (fact -> ( expresion ) .)
    /               reduce using rule 90 (fact -> ( expresion ) .)
    +               reduce using rule 90 (fact -> ( expresion ) .)
    -               reduce using rule 90 (fact -> ( expresion ) .)
    EQ              reduce using rule 90 (fact -> ( expresion ) .)
    DIF             reduce using rule 90 (fact -> ( expresion ) .)
    LTOEQ           reduce using rule 90 (fact -> ( expresion ) .)
    GTOEQ           reduce using rule 90 (fact -> ( expresion ) .)
    >               reduce using rule 90 (fact -> ( expresion ) .)
    <               reduce using rule 90 (fact -> ( expresion ) .)
    AND             reduce using rule 90 (fact -> ( expresion ) .)
    OR              reduce using rule 90 (fact -> ( expresion ) .)
    )               reduce using rule 90 (fact -> ( expresion ) .)
    ,               reduce using rule 90 (fact -> ( expresion ) .)
    ]               reduce using rule 90 (fact -> ( expresion ) .)
    :               reduce using rule 90 (fact -> ( expresion ) .)


state 176

    (68) cyExpresion -> AND expresion .

    ;               reduce using rule 68 (cyExpresion -> AND expresion .)
    *               reduce using rule 68 (cyExpresion -> AND expresion .)
    /               reduce using rule 68 (cyExpresion -> AND expresion .)
    +               reduce using rule 68 (cyExpresion -> AND expresion .)
    -               reduce using rule 68 (cyExpresion -> AND expresion .)
    EQ              reduce using rule 68 (cyExpresion -> AND expresion .)
    DIF             reduce using rule 68 (cyExpresion -> AND expresion .)
    LTOEQ           reduce using rule 68 (cyExpresion -> AND expresion .)
    GTOEQ           reduce using rule 68 (cyExpresion -> AND expresion .)
    >               reduce using rule 68 (cyExpresion -> AND expresion .)
    <               reduce using rule 68 (cyExpresion -> AND expresion .)
    AND             reduce using rule 68 (cyExpresion -> AND expresion .)
    OR              reduce using rule 68 (cyExpresion -> AND expresion .)
    )               reduce using rule 68 (cyExpresion -> AND expresion .)
    ,               reduce using rule 68 (cyExpresion -> AND expresion .)
    ]               reduce using rule 68 (cyExpresion -> AND expresion .)
    :               reduce using rule 68 (cyExpresion -> AND expresion .)


state 177

    (69) cyExpresion -> OR expresion .

    ;               reduce using rule 69 (cyExpresion -> OR expresion .)
    *               reduce using rule 69 (cyExpresion -> OR expresion .)
    /               reduce using rule 69 (cyExpresion -> OR expresion .)
    +               reduce using rule 69 (cyExpresion -> OR expresion .)
    -               reduce using rule 69 (cyExpresion -> OR expresion .)
    EQ              reduce using rule 69 (cyExpresion -> OR expresion .)
    DIF             reduce using rule 69 (cyExpresion -> OR expresion .)
    LTOEQ           reduce using rule 69 (cyExpresion -> OR expresion .)
    GTOEQ           reduce using rule 69 (cyExpresion -> OR expresion .)
    >               reduce using rule 69 (cyExpresion -> OR expresion .)
    <               reduce using rule 69 (cyExpresion -> OR expresion .)
    AND             reduce using rule 69 (cyExpresion -> OR expresion .)
    OR              reduce using rule 69 (cyExpresion -> OR expresion .)
    )               reduce using rule 69 (cyExpresion -> OR expresion .)
    ,               reduce using rule 69 (cyExpresion -> OR expresion .)
    ]               reduce using rule 69 (cyExpresion -> OR expresion .)
    :               reduce using rule 69 (cyExpresion -> OR expresion .)


state 178

    (72) cySExp -> EQ sExp .

    ;               reduce using rule 72 (cySExp -> EQ sExp .)
    *               reduce using rule 72 (cySExp -> EQ sExp .)
    /               reduce using rule 72 (cySExp -> EQ sExp .)
    +               reduce using rule 72 (cySExp -> EQ sExp .)
    -               reduce using rule 72 (cySExp -> EQ sExp .)
    EQ              reduce using rule 72 (cySExp -> EQ sExp .)
    DIF             reduce using rule 72 (cySExp -> EQ sExp .)
    LTOEQ           reduce using rule 72 (cySExp -> EQ sExp .)
    GTOEQ           reduce using rule 72 (cySExp -> EQ sExp .)
    >               reduce using rule 72 (cySExp -> EQ sExp .)
    <               reduce using rule 72 (cySExp -> EQ sExp .)
    AND             reduce using rule 72 (cySExp -> EQ sExp .)
    OR              reduce using rule 72 (cySExp -> EQ sExp .)
    )               reduce using rule 72 (cySExp -> EQ sExp .)
    ,               reduce using rule 72 (cySExp -> EQ sExp .)
    ]               reduce using rule 72 (cySExp -> EQ sExp .)
    :               reduce using rule 72 (cySExp -> EQ sExp .)


state 179

    (73) cySExp -> DIF sExp .

    ;               reduce using rule 73 (cySExp -> DIF sExp .)
    *               reduce using rule 73 (cySExp -> DIF sExp .)
    /               reduce using rule 73 (cySExp -> DIF sExp .)
    +               reduce using rule 73 (cySExp -> DIF sExp .)
    -               reduce using rule 73 (cySExp -> DIF sExp .)
    EQ              reduce using rule 73 (cySExp -> DIF sExp .)
    DIF             reduce using rule 73 (cySExp -> DIF sExp .)
    LTOEQ           reduce using rule 73 (cySExp -> DIF sExp .)
    GTOEQ           reduce using rule 73 (cySExp -> DIF sExp .)
    >               reduce using rule 73 (cySExp -> DIF sExp .)
    <               reduce using rule 73 (cySExp -> DIF sExp .)
    AND             reduce using rule 73 (cySExp -> DIF sExp .)
    OR              reduce using rule 73 (cySExp -> DIF sExp .)
    )               reduce using rule 73 (cySExp -> DIF sExp .)
    ,               reduce using rule 73 (cySExp -> DIF sExp .)
    ]               reduce using rule 73 (cySExp -> DIF sExp .)
    :               reduce using rule 73 (cySExp -> DIF sExp .)


state 180

    (75) cySExp -> GTOEQ sExp .

    ;               reduce using rule 75 (cySExp -> GTOEQ sExp .)
    *               reduce using rule 75 (cySExp -> GTOEQ sExp .)
    /               reduce using rule 75 (cySExp -> GTOEQ sExp .)
    +               reduce using rule 75 (cySExp -> GTOEQ sExp .)
    -               reduce using rule 75 (cySExp -> GTOEQ sExp .)
    EQ              reduce using rule 75 (cySExp -> GTOEQ sExp .)
    DIF             reduce using rule 75 (cySExp -> GTOEQ sExp .)
    LTOEQ           reduce using rule 75 (cySExp -> GTOEQ sExp .)
    GTOEQ           reduce using rule 75 (cySExp -> GTOEQ sExp .)
    >               reduce using rule 75 (cySExp -> GTOEQ sExp .)
    <               reduce using rule 75 (cySExp -> GTOEQ sExp .)
    AND             reduce using rule 75 (cySExp -> GTOEQ sExp .)
    OR              reduce using rule 75 (cySExp -> GTOEQ sExp .)
    )               reduce using rule 75 (cySExp -> GTOEQ sExp .)
    ,               reduce using rule 75 (cySExp -> GTOEQ sExp .)
    ]               reduce using rule 75 (cySExp -> GTOEQ sExp .)
    :               reduce using rule 75 (cySExp -> GTOEQ sExp .)


state 181

    (74) cySExp -> LTOEQ sExp .

    ;               reduce using rule 74 (cySExp -> LTOEQ sExp .)
    *               reduce using rule 74 (cySExp -> LTOEQ sExp .)
    /               reduce using rule 74 (cySExp -> LTOEQ sExp .)
    +               reduce using rule 74 (cySExp -> LTOEQ sExp .)
    -               reduce using rule 74 (cySExp -> LTOEQ sExp .)
    EQ              reduce using rule 74 (cySExp -> LTOEQ sExp .)
    DIF             reduce using rule 74 (cySExp -> LTOEQ sExp .)
    LTOEQ           reduce using rule 74 (cySExp -> LTOEQ sExp .)
    GTOEQ           reduce using rule 74 (cySExp -> LTOEQ sExp .)
    >               reduce using rule 74 (cySExp -> LTOEQ sExp .)
    <               reduce using rule 74 (cySExp -> LTOEQ sExp .)
    AND             reduce using rule 74 (cySExp -> LTOEQ sExp .)
    OR              reduce using rule 74 (cySExp -> LTOEQ sExp .)
    )               reduce using rule 74 (cySExp -> LTOEQ sExp .)
    ,               reduce using rule 74 (cySExp -> LTOEQ sExp .)
    ]               reduce using rule 74 (cySExp -> LTOEQ sExp .)
    :               reduce using rule 74 (cySExp -> LTOEQ sExp .)


state 182

    (77) cySExp -> < sExp .

    ;               reduce using rule 77 (cySExp -> < sExp .)
    *               reduce using rule 77 (cySExp -> < sExp .)
    /               reduce using rule 77 (cySExp -> < sExp .)
    +               reduce using rule 77 (cySExp -> < sExp .)
    -               reduce using rule 77 (cySExp -> < sExp .)
    EQ              reduce using rule 77 (cySExp -> < sExp .)
    DIF             reduce using rule 77 (cySExp -> < sExp .)
    LTOEQ           reduce using rule 77 (cySExp -> < sExp .)
    GTOEQ           reduce using rule 77 (cySExp -> < sExp .)
    >               reduce using rule 77 (cySExp -> < sExp .)
    <               reduce using rule 77 (cySExp -> < sExp .)
    AND             reduce using rule 77 (cySExp -> < sExp .)
    OR              reduce using rule 77 (cySExp -> < sExp .)
    )               reduce using rule 77 (cySExp -> < sExp .)
    ,               reduce using rule 77 (cySExp -> < sExp .)
    ]               reduce using rule 77 (cySExp -> < sExp .)
    :               reduce using rule 77 (cySExp -> < sExp .)


state 183

    (76) cySExp -> > sExp .

    ;               reduce using rule 76 (cySExp -> > sExp .)
    *               reduce using rule 76 (cySExp -> > sExp .)
    /               reduce using rule 76 (cySExp -> > sExp .)
    +               reduce using rule 76 (cySExp -> > sExp .)
    -               reduce using rule 76 (cySExp -> > sExp .)
    EQ              reduce using rule 76 (cySExp -> > sExp .)
    DIF             reduce using rule 76 (cySExp -> > sExp .)
    LTOEQ           reduce using rule 76 (cySExp -> > sExp .)
    GTOEQ           reduce using rule 76 (cySExp -> > sExp .)
    >               reduce using rule 76 (cySExp -> > sExp .)
    <               reduce using rule 76 (cySExp -> > sExp .)
    AND             reduce using rule 76 (cySExp -> > sExp .)
    OR              reduce using rule 76 (cySExp -> > sExp .)
    )               reduce using rule 76 (cySExp -> > sExp .)
    ,               reduce using rule 76 (cySExp -> > sExp .)
    ]               reduce using rule 76 (cySExp -> > sExp .)
    :               reduce using rule 76 (cySExp -> > sExp .)


state 184

    (96) opStruct -> [ expresion . ] opMatrix

    ]               shift and go to state 201


state 185

    (100) dictIndex -> FIRST .

    *               reduce using rule 100 (dictIndex -> FIRST .)
    /               reduce using rule 100 (dictIndex -> FIRST .)
    +               reduce using rule 100 (dictIndex -> FIRST .)
    -               reduce using rule 100 (dictIndex -> FIRST .)
    EQ              reduce using rule 100 (dictIndex -> FIRST .)
    DIF             reduce using rule 100 (dictIndex -> FIRST .)
    LTOEQ           reduce using rule 100 (dictIndex -> FIRST .)
    GTOEQ           reduce using rule 100 (dictIndex -> FIRST .)
    >               reduce using rule 100 (dictIndex -> FIRST .)
    <               reduce using rule 100 (dictIndex -> FIRST .)
    AND             reduce using rule 100 (dictIndex -> FIRST .)
    OR              reduce using rule 100 (dictIndex -> FIRST .)
    )               reduce using rule 100 (dictIndex -> FIRST .)
    ,               reduce using rule 100 (dictIndex -> FIRST .)
    ]               reduce using rule 100 (dictIndex -> FIRST .)
    ;               reduce using rule 100 (dictIndex -> FIRST .)
    :               reduce using rule 100 (dictIndex -> FIRST .)


state 186

    (101) dictIndex -> LAST .

    *               reduce using rule 101 (dictIndex -> LAST .)
    /               reduce using rule 101 (dictIndex -> LAST .)
    +               reduce using rule 101 (dictIndex -> LAST .)
    -               reduce using rule 101 (dictIndex -> LAST .)
    EQ              reduce using rule 101 (dictIndex -> LAST .)
    DIF             reduce using rule 101 (dictIndex -> LAST .)
    LTOEQ           reduce using rule 101 (dictIndex -> LAST .)
    GTOEQ           reduce using rule 101 (dictIndex -> LAST .)
    >               reduce using rule 101 (dictIndex -> LAST .)
    <               reduce using rule 101 (dictIndex -> LAST .)
    AND             reduce using rule 101 (dictIndex -> LAST .)
    OR              reduce using rule 101 (dictIndex -> LAST .)
    )               reduce using rule 101 (dictIndex -> LAST .)
    ,               reduce using rule 101 (dictIndex -> LAST .)
    ]               reduce using rule 101 (dictIndex -> LAST .)
    ;               reduce using rule 101 (dictIndex -> LAST .)
    :               reduce using rule 101 (dictIndex -> LAST .)


state 187

    (99) opDictionary -> . dictIndex .

    *               reduce using rule 99 (opDictionary -> . dictIndex .)
    /               reduce using rule 99 (opDictionary -> . dictIndex .)
    +               reduce using rule 99 (opDictionary -> . dictIndex .)
    -               reduce using rule 99 (opDictionary -> . dictIndex .)
    EQ              reduce using rule 99 (opDictionary -> . dictIndex .)
    DIF             reduce using rule 99 (opDictionary -> . dictIndex .)
    LTOEQ           reduce using rule 99 (opDictionary -> . dictIndex .)
    GTOEQ           reduce using rule 99 (opDictionary -> . dictIndex .)
    >               reduce using rule 99 (opDictionary -> . dictIndex .)
    <               reduce using rule 99 (opDictionary -> . dictIndex .)
    AND             reduce using rule 99 (opDictionary -> . dictIndex .)
    OR              reduce using rule 99 (opDictionary -> . dictIndex .)
    )               reduce using rule 99 (opDictionary -> . dictIndex .)
    ;               reduce using rule 99 (opDictionary -> . dictIndex .)
    ,               reduce using rule 99 (opDictionary -> . dictIndex .)
    ]               reduce using rule 99 (opDictionary -> . dictIndex .)
    :               reduce using rule 99 (opDictionary -> . dictIndex .)


state 188

    (48) whileCycle -> WHILE ( expresion ) { . body }
    (43) body -> . cycleInstruction
    (44) body -> . empty
    (45) cycleInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (63) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 67
    ID              shift and go to state 65
    FOR             shift and go to state 64
    WHILE           shift and go to state 58

    body                           shift and go to state 202
    c                              shift and go to state 68
    funcCall                       shift and go to state 69
    cycleInstruction               shift and go to state 60
    instr                          shift and go to state 56
    forCycle                       shift and go to state 59
    whileCycle                     shift and go to state 57
    condition                      shift and go to state 66
    assign                         shift and go to state 70
    empty                          shift and go to state 62
    cycle                          shift and go to state 61

state 189

    (81) cyExp -> - term .

    ;               reduce using rule 81 (cyExp -> - term .)
    *               reduce using rule 81 (cyExp -> - term .)
    /               reduce using rule 81 (cyExp -> - term .)
    +               reduce using rule 81 (cyExp -> - term .)
    -               reduce using rule 81 (cyExp -> - term .)
    EQ              reduce using rule 81 (cyExp -> - term .)
    DIF             reduce using rule 81 (cyExp -> - term .)
    LTOEQ           reduce using rule 81 (cyExp -> - term .)
    GTOEQ           reduce using rule 81 (cyExp -> - term .)
    >               reduce using rule 81 (cyExp -> - term .)
    <               reduce using rule 81 (cyExp -> - term .)
    AND             reduce using rule 81 (cyExp -> - term .)
    OR              reduce using rule 81 (cyExp -> - term .)
    )               reduce using rule 81 (cyExp -> - term .)
    ,               reduce using rule 81 (cyExp -> - term .)
    ]               reduce using rule 81 (cyExp -> - term .)
    :               reduce using rule 81 (cyExp -> - term .)


state 190

    (80) cyExp -> + term .

    ;               reduce using rule 80 (cyExp -> + term .)
    *               reduce using rule 80 (cyExp -> + term .)
    /               reduce using rule 80 (cyExp -> + term .)
    +               reduce using rule 80 (cyExp -> + term .)
    -               reduce using rule 80 (cyExp -> + term .)
    EQ              reduce using rule 80 (cyExp -> + term .)
    DIF             reduce using rule 80 (cyExp -> + term .)
    LTOEQ           reduce using rule 80 (cyExp -> + term .)
    GTOEQ           reduce using rule 80 (cyExp -> + term .)
    >               reduce using rule 80 (cyExp -> + term .)
    <               reduce using rule 80 (cyExp -> + term .)
    AND             reduce using rule 80 (cyExp -> + term .)
    OR              reduce using rule 80 (cyExp -> + term .)
    )               reduce using rule 80 (cyExp -> + term .)
    ,               reduce using rule 80 (cyExp -> + term .)
    ]               reduce using rule 80 (cyExp -> + term .)
    :               reduce using rule 80 (cyExp -> + term .)


state 191

    (84) cyTerm -> * fact .

    ;               reduce using rule 84 (cyTerm -> * fact .)
    *               reduce using rule 84 (cyTerm -> * fact .)
    /               reduce using rule 84 (cyTerm -> * fact .)
    +               reduce using rule 84 (cyTerm -> * fact .)
    -               reduce using rule 84 (cyTerm -> * fact .)
    EQ              reduce using rule 84 (cyTerm -> * fact .)
    DIF             reduce using rule 84 (cyTerm -> * fact .)
    LTOEQ           reduce using rule 84 (cyTerm -> * fact .)
    GTOEQ           reduce using rule 84 (cyTerm -> * fact .)
    >               reduce using rule 84 (cyTerm -> * fact .)
    <               reduce using rule 84 (cyTerm -> * fact .)
    AND             reduce using rule 84 (cyTerm -> * fact .)
    OR              reduce using rule 84 (cyTerm -> * fact .)
    )               reduce using rule 84 (cyTerm -> * fact .)
    ,               reduce using rule 84 (cyTerm -> * fact .)
    ]               reduce using rule 84 (cyTerm -> * fact .)
    :               reduce using rule 84 (cyTerm -> * fact .)


state 192

    (85) cyTerm -> / fact .

    ;               reduce using rule 85 (cyTerm -> / fact .)
    *               reduce using rule 85 (cyTerm -> / fact .)
    /               reduce using rule 85 (cyTerm -> / fact .)
    +               reduce using rule 85 (cyTerm -> / fact .)
    -               reduce using rule 85 (cyTerm -> / fact .)
    EQ              reduce using rule 85 (cyTerm -> / fact .)
    DIF             reduce using rule 85 (cyTerm -> / fact .)
    LTOEQ           reduce using rule 85 (cyTerm -> / fact .)
    GTOEQ           reduce using rule 85 (cyTerm -> / fact .)
    >               reduce using rule 85 (cyTerm -> / fact .)
    <               reduce using rule 85 (cyTerm -> / fact .)
    AND             reduce using rule 85 (cyTerm -> / fact .)
    OR              reduce using rule 85 (cyTerm -> / fact .)
    )               reduce using rule 85 (cyTerm -> / fact .)
    ,               reduce using rule 85 (cyTerm -> / fact .)
    ]               reduce using rule 85 (cyTerm -> / fact .)
    :               reduce using rule 85 (cyTerm -> / fact .)


state 193

    (49) forCycle -> FOR ( assign ; expresion . ; assign ) { body }

    ;               shift and go to state 203


state 194

    (58) cyParamCall -> , opParamCall .

    )               reduce using rule 58 (cyParamCall -> , opParamCall .)


state 195

    (24) initDict -> = ( j : . j )
    (25) j -> . CTES
    (26) j -> . cte
    (27) j -> . ID
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c

    CTES            shift and go to state 204
    ID              shift and go to state 207
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107

    cte                            shift and go to state 206
    j                              shift and go to state 205

state 196

    (53) assignOptions -> [ expresion ] assignMatrix . init
    (21) init -> . = i

    =               shift and go to state 209

    init                           shift and go to state 208

state 197

    (54) assignMatrix -> [ . expresion ]
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 210
    term                           shift and go to state 106
    funcCall                       shift and go to state 108
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 198

    (55) assignMatrix -> empty .

    =               reduce using rule 55 (assignMatrix -> empty .)


state 199

    (63) condition -> IF ( expresion ) { . body } optionalElse
    (43) body -> . cycleInstruction
    (44) body -> . empty
    (45) cycleInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (63) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 67
    ID              shift and go to state 65
    FOR             shift and go to state 64
    WHILE           shift and go to state 58

    body                           shift and go to state 211
    c                              shift and go to state 68
    funcCall                       shift and go to state 69
    cycleInstruction               shift and go to state 60
    instr                          shift and go to state 56
    forCycle                       shift and go to state 59
    whileCycle                     shift and go to state 57
    condition                      shift and go to state 66
    assign                         shift and go to state 70
    empty                          shift and go to state 62
    cycle                          shift and go to state 61

state 200

    (61) optionalMatrix -> [ CTED ] .

    ;               reduce using rule 61 (optionalMatrix -> [ CTED ] .)


state 201

    (96) opStruct -> [ expresion ] . opMatrix
    (97) opMatrix -> . [ expresion ]
    (98) opMatrix -> . empty
    (106) empty -> .

    [               shift and go to state 212
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    ;               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    empty                          shift and go to state 213
    opMatrix                       shift and go to state 214

state 202

    (48) whileCycle -> WHILE ( expresion ) { body . }

    }               shift and go to state 215


state 203

    (49) forCycle -> FOR ( assign ; expresion ; . assign ) { body }
    (50) assign -> . ID assignOptions

    ID              shift and go to state 113

    assign                         shift and go to state 216

state 204

    (25) j -> CTES .

    )               reduce using rule 25 (j -> CTES .)


state 205

    (24) initDict -> = ( j : j . )

    )               shift and go to state 217


state 206

    (26) j -> cte .

    )               reduce using rule 26 (j -> cte .)


state 207

    (27) j -> ID .

    )               reduce using rule 27 (j -> ID .)


state 208

    (53) assignOptions -> [ expresion ] assignMatrix init .

    ;               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    *               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    /               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    +               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    -               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    EQ              reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    DIF             reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    LTOEQ           reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    GTOEQ           reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    >               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    <               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    AND             reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    OR              reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    )               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    ,               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    ]               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)
    :               reduce using rule 53 (assignOptions -> [ expresion ] assignMatrix init .)


state 209

    (21) init -> = . i
    (22) i -> . expresion
    (23) i -> . funcCall
    (67) expresion -> . sExp cyExpresion
    (56) funcCall -> . ID ( opParamCall )
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (106) empty -> .

    ID              shift and go to state 118
    CTES            shift and go to state 105
    (               shift and go to state 99
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    ;               reduce using rule 106 (empty -> .)
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    )               reduce using rule 106 (empty -> .)
    ,               reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)
    :               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 119
    funcCall                       shift and go to state 120
    i                              shift and go to state 121
    term                           shift and go to state 106
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 210

    (54) assignMatrix -> [ expresion . ]

    ]               shift and go to state 218


state 211

    (63) condition -> IF ( expresion ) { body . } optionalElse

    }               shift and go to state 219


state 212

    (97) opMatrix -> [ . expresion ]
    (67) expresion -> . sExp cyExpresion
    (71) sExp -> . exp cySExp
    (79) exp -> . term cyExp
    (83) term -> . fact cyTerm
    (87) fact -> . CTES
    (88) fact -> . cte
    (89) fact -> . funcCall
    (90) fact -> . ( expresion )
    (91) fact -> . ID opAccess
    (92) fact -> . empty
    (102) cte -> . CTED
    (103) cte -> . CTEF
    (104) cte -> . TRUE
    (105) cte -> . FALSE c
    (56) funcCall -> . ID ( opParamCall )
    (106) empty -> .

    CTES            shift and go to state 105
    (               shift and go to state 99
    ID              shift and go to state 103
    CTED            shift and go to state 111
    CTEF            shift and go to state 110
    TRUE            shift and go to state 98
    FALSE           shift and go to state 107
    *               reduce using rule 106 (empty -> .)
    /               reduce using rule 106 (empty -> .)
    +               reduce using rule 106 (empty -> .)
    -               reduce using rule 106 (empty -> .)
    EQ              reduce using rule 106 (empty -> .)
    DIF             reduce using rule 106 (empty -> .)
    LTOEQ           reduce using rule 106 (empty -> .)
    GTOEQ           reduce using rule 106 (empty -> .)
    >               reduce using rule 106 (empty -> .)
    <               reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    ]               reduce using rule 106 (empty -> .)

    expresion                      shift and go to state 220
    term                           shift and go to state 106
    funcCall                       shift and go to state 108
    sExp                           shift and go to state 100
    cte                            shift and go to state 109
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    fact                           shift and go to state 112

state 213

    (98) opMatrix -> empty .

    *               reduce using rule 98 (opMatrix -> empty .)
    /               reduce using rule 98 (opMatrix -> empty .)
    +               reduce using rule 98 (opMatrix -> empty .)
    -               reduce using rule 98 (opMatrix -> empty .)
    EQ              reduce using rule 98 (opMatrix -> empty .)
    DIF             reduce using rule 98 (opMatrix -> empty .)
    LTOEQ           reduce using rule 98 (opMatrix -> empty .)
    GTOEQ           reduce using rule 98 (opMatrix -> empty .)
    >               reduce using rule 98 (opMatrix -> empty .)
    <               reduce using rule 98 (opMatrix -> empty .)
    AND             reduce using rule 98 (opMatrix -> empty .)
    OR              reduce using rule 98 (opMatrix -> empty .)
    )               reduce using rule 98 (opMatrix -> empty .)
    ,               reduce using rule 98 (opMatrix -> empty .)
    ]               reduce using rule 98 (opMatrix -> empty .)
    ;               reduce using rule 98 (opMatrix -> empty .)
    :               reduce using rule 98 (opMatrix -> empty .)


state 214

    (96) opStruct -> [ expresion ] opMatrix .

    ;               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    *               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    /               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    +               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    -               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    EQ              reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    DIF             reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    LTOEQ           reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    GTOEQ           reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    >               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    <               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    AND             reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    OR              reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    )               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    ,               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    ]               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)
    :               reduce using rule 96 (opStruct -> [ expresion ] opMatrix .)


state 215

    (48) whileCycle -> WHILE ( expresion ) { body } .

    IF              reduce using rule 48 (whileCycle -> WHILE ( expresion ) { body } .)
    ID              reduce using rule 48 (whileCycle -> WHILE ( expresion ) { body } .)
    FOR             reduce using rule 48 (whileCycle -> WHILE ( expresion ) { body } .)
    WHILE           reduce using rule 48 (whileCycle -> WHILE ( expresion ) { body } .)
    }               reduce using rule 48 (whileCycle -> WHILE ( expresion ) { body } .)


state 216

    (49) forCycle -> FOR ( assign ; expresion ; assign . ) { body }

    )               shift and go to state 221


state 217

    (24) initDict -> = ( j : j ) .

    ;               reduce using rule 24 (initDict -> = ( j : j ) .)
    *               reduce using rule 24 (initDict -> = ( j : j ) .)
    /               reduce using rule 24 (initDict -> = ( j : j ) .)
    +               reduce using rule 24 (initDict -> = ( j : j ) .)
    -               reduce using rule 24 (initDict -> = ( j : j ) .)
    EQ              reduce using rule 24 (initDict -> = ( j : j ) .)
    DIF             reduce using rule 24 (initDict -> = ( j : j ) .)
    LTOEQ           reduce using rule 24 (initDict -> = ( j : j ) .)
    GTOEQ           reduce using rule 24 (initDict -> = ( j : j ) .)
    >               reduce using rule 24 (initDict -> = ( j : j ) .)
    <               reduce using rule 24 (initDict -> = ( j : j ) .)
    AND             reduce using rule 24 (initDict -> = ( j : j ) .)
    OR              reduce using rule 24 (initDict -> = ( j : j ) .)
    )               reduce using rule 24 (initDict -> = ( j : j ) .)
    ,               reduce using rule 24 (initDict -> = ( j : j ) .)
    ]               reduce using rule 24 (initDict -> = ( j : j ) .)
    :               reduce using rule 24 (initDict -> = ( j : j ) .)


state 218

    (54) assignMatrix -> [ expresion ] .

    =               reduce using rule 54 (assignMatrix -> [ expresion ] .)


state 219

    (63) condition -> IF ( expresion ) { body } . optionalElse
    (64) optionalElse -> . ELSE { body }
    (65) optionalElse -> . empty
    (106) empty -> .

    ELSE            shift and go to state 222
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    }               reduce using rule 106 (empty -> .)

    optionalElse                   shift and go to state 223
    empty                          shift and go to state 224

state 220

    (97) opMatrix -> [ expresion . ]

    ]               shift and go to state 225


state 221

    (49) forCycle -> FOR ( assign ; expresion ; assign ) . { body }

    {               shift and go to state 226


state 222

    (64) optionalElse -> ELSE . { body }

    {               shift and go to state 227


state 223

    (63) condition -> IF ( expresion ) { body } optionalElse .

    IF              reduce using rule 63 (condition -> IF ( expresion ) { body } optionalElse .)
    ID              reduce using rule 63 (condition -> IF ( expresion ) { body } optionalElse .)
    FOR             reduce using rule 63 (condition -> IF ( expresion ) { body } optionalElse .)
    WHILE           reduce using rule 63 (condition -> IF ( expresion ) { body } optionalElse .)
    }               reduce using rule 63 (condition -> IF ( expresion ) { body } optionalElse .)


state 224

    (65) optionalElse -> empty .

    IF              reduce using rule 65 (optionalElse -> empty .)
    ID              reduce using rule 65 (optionalElse -> empty .)
    FOR             reduce using rule 65 (optionalElse -> empty .)
    WHILE           reduce using rule 65 (optionalElse -> empty .)
    }               reduce using rule 65 (optionalElse -> empty .)


state 225

    (97) opMatrix -> [ expresion ] .

    *               reduce using rule 97 (opMatrix -> [ expresion ] .)
    /               reduce using rule 97 (opMatrix -> [ expresion ] .)
    +               reduce using rule 97 (opMatrix -> [ expresion ] .)
    -               reduce using rule 97 (opMatrix -> [ expresion ] .)
    EQ              reduce using rule 97 (opMatrix -> [ expresion ] .)
    DIF             reduce using rule 97 (opMatrix -> [ expresion ] .)
    LTOEQ           reduce using rule 97 (opMatrix -> [ expresion ] .)
    GTOEQ           reduce using rule 97 (opMatrix -> [ expresion ] .)
    >               reduce using rule 97 (opMatrix -> [ expresion ] .)
    <               reduce using rule 97 (opMatrix -> [ expresion ] .)
    AND             reduce using rule 97 (opMatrix -> [ expresion ] .)
    OR              reduce using rule 97 (opMatrix -> [ expresion ] .)
    )               reduce using rule 97 (opMatrix -> [ expresion ] .)
    ,               reduce using rule 97 (opMatrix -> [ expresion ] .)
    ]               reduce using rule 97 (opMatrix -> [ expresion ] .)
    ;               reduce using rule 97 (opMatrix -> [ expresion ] .)
    :               reduce using rule 97 (opMatrix -> [ expresion ] .)


state 226

    (49) forCycle -> FOR ( assign ; expresion ; assign ) { . body }
    (43) body -> . cycleInstruction
    (44) body -> . empty
    (45) cycleInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (63) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 67
    ID              shift and go to state 65
    FOR             shift and go to state 64
    WHILE           shift and go to state 58

    body                           shift and go to state 228
    c                              shift and go to state 68
    funcCall                       shift and go to state 69
    cycleInstruction               shift and go to state 60
    instr                          shift and go to state 56
    forCycle                       shift and go to state 59
    whileCycle                     shift and go to state 57
    condition                      shift and go to state 66
    assign                         shift and go to state 70
    empty                          shift and go to state 62
    cycle                          shift and go to state 61

state 227

    (64) optionalElse -> ELSE { . body }
    (43) body -> . cycleInstruction
    (44) body -> . empty
    (45) cycleInstruction -> . instr body
    (106) empty -> .
    (13) instr -> . c ;
    (14) instr -> . condition
    (15) instr -> . cycle
    (16) c -> . assign
    (17) c -> . funcCall
    (63) condition -> . IF ( expresion ) { body } optionalElse
    (46) cycle -> . forCycle
    (47) cycle -> . whileCycle
    (50) assign -> . ID assignOptions
    (56) funcCall -> . ID ( opParamCall )
    (49) forCycle -> . FOR ( assign ; expresion ; assign ) { body }
    (48) whileCycle -> . WHILE ( expresion ) { body }

    }               reduce using rule 106 (empty -> .)
    IF              shift and go to state 67
    ID              shift and go to state 65
    FOR             shift and go to state 64
    WHILE           shift and go to state 58

    body                           shift and go to state 229
    c                              shift and go to state 68
    funcCall                       shift and go to state 69
    cycleInstruction               shift and go to state 60
    instr                          shift and go to state 56
    forCycle                       shift and go to state 59
    whileCycle                     shift and go to state 57
    empty                          shift and go to state 62
    assign                         shift and go to state 70
    condition                      shift and go to state 66
    cycle                          shift and go to state 61

state 228

    (49) forCycle -> FOR ( assign ; expresion ; assign ) { body . }

    }               shift and go to state 230


state 229

    (64) optionalElse -> ELSE { body . }

    }               shift and go to state 231


state 230

    (49) forCycle -> FOR ( assign ; expresion ; assign ) { body } .

    IF              reduce using rule 49 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    ID              reduce using rule 49 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    FOR             reduce using rule 49 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    WHILE           reduce using rule 49 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)
    }               reduce using rule 49 (forCycle -> FOR ( assign ; expresion ; assign ) { body } .)


state 231

    (64) optionalElse -> ELSE { body } .

    IF              reduce using rule 64 (optionalElse -> ELSE { body } .)
    ID              reduce using rule 64 (optionalElse -> ELSE { body } .)
    FOR             reduce using rule 64 (optionalElse -> ELSE { body } .)
    WHILE           reduce using rule 64 (optionalElse -> ELSE { body } .)
    }               reduce using rule 64 (optionalElse -> ELSE { body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 100 resolved as shift
WARNING: shift/reduce conflict for OR in state 100 resolved as shift
WARNING: shift/reduce conflict for EQ in state 102 resolved as shift
WARNING: shift/reduce conflict for DIF in state 102 resolved as shift
WARNING: shift/reduce conflict for LTOEQ in state 102 resolved as shift
WARNING: shift/reduce conflict for GTOEQ in state 102 resolved as shift
WARNING: shift/reduce conflict for > in state 102 resolved as shift
WARNING: shift/reduce conflict for < in state 102 resolved as shift
WARNING: shift/reduce conflict for + in state 106 resolved as shift
WARNING: shift/reduce conflict for - in state 106 resolved as shift
WARNING: shift/reduce conflict for * in state 112 resolved as shift
WARNING: shift/reduce conflict for / in state 112 resolved as shift
WARNING: reduce/reduce conflict in state 120 resolved using rule (i -> funcCall)
WARNING: rejected rule (fact -> funcCall) in state 120
