Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    RETURN
    DIF
    WHILE
    LTOEQ
    TRUE
    FOR
    ELSE
    RETURNS
    FUNC
    EQ
    IF
    AND
    CTES
    FALSE
    CTEF
    CTED
    GTOEQ
    OR

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID { a b main }
Rule 2     a -> vars
Rule 3     a -> empty
Rule 4     b -> function b
Rule 5     b -> empty
Rule 6     vars -> VARS declare
Rule 7     type -> INT
Rule 8     type -> FLOAT
Rule 9     type -> STRING
Rule 10    type -> OBJECT
Rule 11    type -> BOOL
Rule 12    main -> MAIN { a body }
Rule 13    instr -> c ;
Rule 14    instr -> condition
Rule 15    instr -> cycle
Rule 16    c -> assign
Rule 17    c -> funcCall
Rule 18    function -> empty
Rule 19    declare -> d
Rule 20    declare -> e
Rule 21    declare -> f
Rule 22    d -> type ID g ; h
Rule 23    e -> STRUCT ID struct ; h
Rule 24    f -> DICT ID dict ; h
Rule 25    g -> , ID
Rule 26    g -> empty
Rule 27    h -> declare
Rule 28    h -> empty
Rule 29    body -> empty
Rule 30    cycle -> empty
Rule 31    assign -> empty
Rule 32    funcCall -> empty
Rule 33    struct -> empty
Rule 34    condition -> empty
Rule 35    dict -> empty
Rule 36    empty -> <empty>

Terminals, with rules where they appear

,                    : 25
;                    : 13 22 23 24
AND                  : 
BOOL                 : 11
CTED                 : 
CTEF                 : 
CTES                 : 
DICT                 : 24
DIF                  : 
ELSE                 : 
EQ                   : 
FALSE                : 
FLOAT                : 8
FOR                  : 
FUNC                 : 
GTOEQ                : 
ID                   : 1 22 23 24 25
IF                   : 
INT                  : 7
LTOEQ                : 
MAIN                 : 12
OBJECT               : 10
OR                   : 
PROGRAM              : 1
RETURN               : 
RETURNS              : 
STRING               : 9
STRUCT               : 23
TRUE                 : 
VARS                 : 6
WHILE                : 
error                : 
{                    : 1 12
}                    : 1 12

Nonterminals, with rules where they appear

a                    : 1 12
assign               : 16
b                    : 1 4
body                 : 12
c                    : 13
condition            : 14
cycle                : 15
d                    : 19
declare              : 6 27
dict                 : 24
e                    : 20
empty                : 3 5 18 26 28 29 30 31 32 33 34 35
f                    : 21
funcCall             : 17
function             : 4
g                    : 22
h                    : 22 23 24
instr                : 
main                 : 1
program              : 0
struct               : 23
type                 : 22
vars                 : 2

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID { a b main }

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID { a b main }

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . { a b main }

    {               shift and go to state 4


state 4

    (1) program -> PROGRAM ID { . a b main }
    (2) a -> . vars
    (3) a -> . empty
    (6) vars -> . VARS declare
    (36) empty -> .

    VARS            shift and go to state 6
    MAIN            reduce using rule 36 (empty -> .)

    a                              shift and go to state 5
    vars                           shift and go to state 7
    empty                          shift and go to state 8

state 5

    (1) program -> PROGRAM ID { a . b main }
    (4) b -> . function b
    (5) b -> . empty
    (18) function -> . empty
    (36) empty -> .

    MAIN            reduce using rule 36 (empty -> .)

    function                       shift and go to state 9
    b                              shift and go to state 10
    empty                          shift and go to state 11

state 6

    (6) vars -> VARS . declare
    (19) declare -> . d
    (20) declare -> . e
    (21) declare -> . f
    (22) d -> . type ID g ; h
    (23) e -> . STRUCT ID struct ; h
    (24) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    STRUCT          shift and go to state 23
    DICT            shift and go to state 19
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    OBJECT          shift and go to state 12
    BOOL            shift and go to state 20

    e                              shift and go to state 13
    d                              shift and go to state 14
    f                              shift and go to state 15
    type                           shift and go to state 21
    declare                        shift and go to state 22

state 7

    (2) a -> vars .

    MAIN            reduce using rule 2 (a -> vars .)
    }               reduce using rule 2 (a -> vars .)


state 8

    (3) a -> empty .

    MAIN            reduce using rule 3 (a -> empty .)
    }               reduce using rule 3 (a -> empty .)


state 9

    (4) b -> function . b
    (4) b -> . function b
    (5) b -> . empty
    (18) function -> . empty
    (36) empty -> .

    MAIN            reduce using rule 36 (empty -> .)

    function                       shift and go to state 9
    b                              shift and go to state 24
    empty                          shift and go to state 11

state 10

    (1) program -> PROGRAM ID { a b . main }
    (12) main -> . MAIN { a body }

    MAIN            shift and go to state 25

    main                           shift and go to state 26

state 11

    (5) b -> empty .
    (18) function -> empty .

  ! reduce/reduce conflict for MAIN resolved using rule 5 (b -> empty .)
    MAIN            reduce using rule 5 (b -> empty .)

  ! MAIN            [ reduce using rule 18 (function -> empty .) ]


state 12

    (10) type -> OBJECT .

    ID              reduce using rule 10 (type -> OBJECT .)


state 13

    (20) declare -> e .

    MAIN            reduce using rule 20 (declare -> e .)
    }               reduce using rule 20 (declare -> e .)


state 14

    (19) declare -> d .

    MAIN            reduce using rule 19 (declare -> d .)
    }               reduce using rule 19 (declare -> d .)


state 15

    (21) declare -> f .

    MAIN            reduce using rule 21 (declare -> f .)
    }               reduce using rule 21 (declare -> f .)


state 16

    (7) type -> INT .

    ID              reduce using rule 7 (type -> INT .)


state 17

    (8) type -> FLOAT .

    ID              reduce using rule 8 (type -> FLOAT .)


state 18

    (9) type -> STRING .

    ID              reduce using rule 9 (type -> STRING .)


state 19

    (24) f -> DICT . ID dict ; h

    ID              shift and go to state 27


state 20

    (11) type -> BOOL .

    ID              reduce using rule 11 (type -> BOOL .)


state 21

    (22) d -> type . ID g ; h

    ID              shift and go to state 28


state 22

    (6) vars -> VARS declare .

    }               reduce using rule 6 (vars -> VARS declare .)
    MAIN            reduce using rule 6 (vars -> VARS declare .)


state 23

    (23) e -> STRUCT . ID struct ; h

    ID              shift and go to state 29


state 24

    (4) b -> function b .

    MAIN            reduce using rule 4 (b -> function b .)


state 25

    (12) main -> MAIN . { a body }

    {               shift and go to state 30


state 26

    (1) program -> PROGRAM ID { a b main . }

    }               shift and go to state 31


state 27

    (24) f -> DICT ID . dict ; h
    (35) dict -> . empty
    (36) empty -> .

    ;               reduce using rule 36 (empty -> .)

    dict                           shift and go to state 32
    empty                          shift and go to state 33

state 28

    (22) d -> type ID . g ; h
    (25) g -> . , ID
    (26) g -> . empty
    (36) empty -> .

    ,               shift and go to state 35
    ;               reduce using rule 36 (empty -> .)

    empty                          shift and go to state 36
    g                              shift and go to state 34

state 29

    (23) e -> STRUCT ID . struct ; h
    (33) struct -> . empty
    (36) empty -> .

    ;               reduce using rule 36 (empty -> .)

    struct                         shift and go to state 37
    empty                          shift and go to state 38

state 30

    (12) main -> MAIN { . a body }
    (2) a -> . vars
    (3) a -> . empty
    (6) vars -> . VARS declare
    (36) empty -> .

    VARS            shift and go to state 6
    }               reduce using rule 36 (empty -> .)

    a                              shift and go to state 39
    empty                          shift and go to state 8
    vars                           shift and go to state 7

state 31

    (1) program -> PROGRAM ID { a b main } .

    $end            reduce using rule 1 (program -> PROGRAM ID { a b main } .)


state 32

    (24) f -> DICT ID dict . ; h

    ;               shift and go to state 40


state 33

    (35) dict -> empty .

    ;               reduce using rule 35 (dict -> empty .)


state 34

    (22) d -> type ID g . ; h

    ;               shift and go to state 41


state 35

    (25) g -> , . ID

    ID              shift and go to state 42


state 36

    (26) g -> empty .

    ;               reduce using rule 26 (g -> empty .)


state 37

    (23) e -> STRUCT ID struct . ; h

    ;               shift and go to state 43


state 38

    (33) struct -> empty .

    ;               reduce using rule 33 (struct -> empty .)


state 39

    (12) main -> MAIN { a . body }
    (29) body -> . empty
    (36) empty -> .

    }               reduce using rule 36 (empty -> .)

    body                           shift and go to state 44
    empty                          shift and go to state 45

state 40

    (24) f -> DICT ID dict ; . h
    (27) h -> . declare
    (28) h -> . empty
    (19) declare -> . d
    (20) declare -> . e
    (21) declare -> . f
    (36) empty -> .
    (22) d -> . type ID g ; h
    (23) e -> . STRUCT ID struct ; h
    (24) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    MAIN            reduce using rule 36 (empty -> .)
    }               reduce using rule 36 (empty -> .)
    STRUCT          shift and go to state 23
    DICT            shift and go to state 19
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    OBJECT          shift and go to state 12
    BOOL            shift and go to state 20

    e                              shift and go to state 13
    d                              shift and go to state 14
    f                              shift and go to state 15
    h                              shift and go to state 46
    type                           shift and go to state 21
    declare                        shift and go to state 47
    empty                          shift and go to state 48

state 41

    (22) d -> type ID g ; . h
    (27) h -> . declare
    (28) h -> . empty
    (19) declare -> . d
    (20) declare -> . e
    (21) declare -> . f
    (36) empty -> .
    (22) d -> . type ID g ; h
    (23) e -> . STRUCT ID struct ; h
    (24) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    MAIN            reduce using rule 36 (empty -> .)
    }               reduce using rule 36 (empty -> .)
    STRUCT          shift and go to state 23
    DICT            shift and go to state 19
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    OBJECT          shift and go to state 12
    BOOL            shift and go to state 20

    e                              shift and go to state 13
    d                              shift and go to state 14
    f                              shift and go to state 15
    h                              shift and go to state 49
    type                           shift and go to state 21
    declare                        shift and go to state 47
    empty                          shift and go to state 48

state 42

    (25) g -> , ID .

    ;               reduce using rule 25 (g -> , ID .)


state 43

    (23) e -> STRUCT ID struct ; . h
    (27) h -> . declare
    (28) h -> . empty
    (19) declare -> . d
    (20) declare -> . e
    (21) declare -> . f
    (36) empty -> .
    (22) d -> . type ID g ; h
    (23) e -> . STRUCT ID struct ; h
    (24) f -> . DICT ID dict ; h
    (7) type -> . INT
    (8) type -> . FLOAT
    (9) type -> . STRING
    (10) type -> . OBJECT
    (11) type -> . BOOL

    MAIN            reduce using rule 36 (empty -> .)
    }               reduce using rule 36 (empty -> .)
    STRUCT          shift and go to state 23
    DICT            shift and go to state 19
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    OBJECT          shift and go to state 12
    BOOL            shift and go to state 20

    e                              shift and go to state 13
    d                              shift and go to state 14
    f                              shift and go to state 15
    h                              shift and go to state 50
    type                           shift and go to state 21
    declare                        shift and go to state 47
    empty                          shift and go to state 48

state 44

    (12) main -> MAIN { a body . }

    }               shift and go to state 51


state 45

    (29) body -> empty .

    }               reduce using rule 29 (body -> empty .)


state 46

    (24) f -> DICT ID dict ; h .

    MAIN            reduce using rule 24 (f -> DICT ID dict ; h .)
    }               reduce using rule 24 (f -> DICT ID dict ; h .)


state 47

    (27) h -> declare .

    MAIN            reduce using rule 27 (h -> declare .)
    }               reduce using rule 27 (h -> declare .)


state 48

    (28) h -> empty .

    MAIN            reduce using rule 28 (h -> empty .)
    }               reduce using rule 28 (h -> empty .)


state 49

    (22) d -> type ID g ; h .

    MAIN            reduce using rule 22 (d -> type ID g ; h .)
    }               reduce using rule 22 (d -> type ID g ; h .)


state 50

    (23) e -> STRUCT ID struct ; h .

    MAIN            reduce using rule 23 (e -> STRUCT ID struct ; h .)
    }               reduce using rule 23 (e -> STRUCT ID struct ; h .)


state 51

    (12) main -> MAIN { a body } .

    }               reduce using rule 12 (main -> MAIN { a body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 11 resolved using rule (b -> empty)
WARNING: rejected rule (function -> empty) in state 11
WARNING: Rule (function -> empty) is never reduced
